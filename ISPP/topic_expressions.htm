<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1251" />
<meta http-equiv="X-UA-Compatible" content="IE=8" />
<title>Inno Setup Preprocessor: Синтаксис выражений</title>
<link rel="stylesheet" type="text/css" href="../styles.css" />
<script type="text/javascript" src="../topic.js"></script>
</head>
<body>
<h1 class="topicheading">Inno Setup Preprocessor: Синтаксис выражений</h1>
<div class="topicbody">
  <p>ISPP использует C/C++ подобный синтаксис выражений. Он поддерживает простые и составные операторы присваивания, условный оператор, и оператор следования. Хотя ISPP является интерпретатором, он поддерживает короткие оценки логический контур, и никогда не вычисляет выражения (вызовы, ни любые макросы, упомянутых в этих выражениях), которые не должны быть оценены из-за специфических правил (например, когда условный оператор используется, всегда вычисляются только 2 из 3-х операнда).</p>
  <p>Файл <a href="topic_builtinsiss.htm">BUILTINS.ISS</a> содержит много примеров выражений.</p>
  <h2 class="heading">Различия между синтаксисом выражений С и ISPP</h2>
  <ul>
    <li>ISPP не поддерживает ряд операторов (ссылка, разыменования, разрешения пространства имен т.д.).&nbsp;</li>
    <li>ISPP относит идентификатор и знак равенства как имя аргумента, если он используется в списке аргументов.&nbsp;</li>
    <li>Арифметический оператор деления (косая черта) выполняет целочисленное деление, так как ISPP не поддерживает арифметику с плавающей точкой.&nbsp;</li>
    <li>ISPP не проверяет действия выражений в некоторых случаях. Например, в условном выражении, &quot;истинный&quot; операнд может быть строкового типа, тогда как &quot;ложный&quot; операнд может быть целого типа.&nbsp;</li>
    <li>Строковые литералы могут быть заключены и в одинарные и двойные кавычки. Если литерал начинается одинарной кавычкой, то она должна закончиться тоже на одинарную кавычку. Двойные кавычки можно использовать в одинарных, а одинарные в двойных без экранирования этих символов. <span id="result_box" lang="ru" tabindex="-1" xml:lang="ru">Внутри строки символ, используемый для цитирования чего-либо, наоборот, должен быть экранирован (способ зависит от текущего состояния опции <span id="result_box2" lang="ru" tabindex="-1" xml:lang="ru">синтаксического анализатора</span> (парсер) &quot;строкове литералы в стиле Паскаль&quot;, см. <tt><a href="topic_pragma.htm">pragma</a></tt>).</span> </li>
    <li>Строковые литералы могут быть заключены в кавычки как одинарные и двойные кавычки (в обоих режимах - C-стиле или стиле Pascal). Если литерал начинается с одиночной кавычки, оно должно заканчиваться&nbsp;также одиночной&nbsp;кавычкой. Двойные кавычки могут быть использованы в одной строке&nbsp;в одиночных кавычках, и наоборот. В строке символ, используемый для цитаты строкой, должен быть экранирован (способ зависит от текущего состояния опции <span id="result_box3" lang="ru" tabindex="-1" xml:lang="ru">синтаксического анализатора</span> (парсер) &quot;строкове литералы в стиле Паскаль&quot;, см. <tt><a href="topic_pragma.htm">pragma</a></tt>).</li>
  </ul>
  <h2 class="heading">Типы данных</h2>
  <p>В ISPP существуют три типа данных: void, integer и string. Переменная типа void определяется просто указанием ее имени после директивы <tt><a href="topic_define.htm">define</a></tt> без каких либо значений. Такие переменные должны использоваться в директиве <tt><a href="topic_ifdef.htm">ifdef</a></tt> или функции <tt><a href="topic_defined.htm">Defined</a></tt>.</p>
  <p>Если опция синтаксического анализатора &quot;позволить необъявленные идентификаторы&quot; отключена (состояние по умолчанию, см. <tt><a href="topic_pragma.htm">pragma</a></tt>), то при использовании не определенных переменных возникнет ошибка. Иначе, эта переменная обрабатывается как имеющее значение типа void.</p>
  <p>В выражениях&nbsp;void совместимых с типами integer и string. Например, можно использовать оператор сложения с пустыми (void) и целочисленными (integer) операндами, в этом случае пустой операнд будет обработан как нуль. В соединении со строкой (string) пустой операнд обрабатывается как пустая строка.</p>
  <h2 class="heading">Комментарии</h2>
  <p>Комментарии могут быть встроены в выражение с использованием наклонной черты (/) и звездочки (*). Например:</p>
  <p><tt>#emit Var1 /* this is a comment */ + Var2 /* this is a comment */<br />
  </tt></p>
  <p>Также поддерживаются однострочные комментарии. Эти комментарии должны начаться с точки с запятой. Весь текст после точки с запятой до конца строки считается комментарием.</p>
  <p><tt>#emit Var1 + Var2 ; this is a comment<br />
  </tt></p>
  <p>Комментарий можно разделить на несколько строк, используя &quot;\&quot;:</p>
  <p><tt>#emit Var1 + Var2 ; this is \<br />
    &nbsp;&nbsp;a comment<br />
  </tt></p>
  <h2 class="heading">Расширенный синтаксис вызова макроопределений</h2>
  <p>В ISPP возможно использовать именованные аргументы при вызове созданных пользователем макроопределений. Пример объявления:</p>
  <p><tt>#define MyMacro(int A = 2, int B = 2) A + B<br />
  </tt></p>
  <p>Этот макрос можно вызвать, передавая имена параметров:</p>
  <p><tt>#emit MyMacro(A = 5, B = 10)<br />
    #emit MyMacro(B = 3)<br />
    #emit MyMacro(B = 10, A = 5)<br />
  </tt></p>
  <ul>
    <li>Если имя определяется для одного параметра, то все (необходимые) параметры в списке нужно также назвать.</li>
    <li>Порядок параметров, передаваемых по имени, не имеет значения.</li>
    <li>
      <p>Из-за этого расширения выражение присвоения должно быть включено в круглые скобки, чтобы избежать неоднозначности, если не используется расширенный синтаксис вызова:</p>
      <p><tt>#emit MyMacro((MyVar = 5), 10)<br />
      </tt></p>
      <p>В вышеупомянутом примере знак равенства обрабатывается как&nbsp;оператор прямого присваивания.</p>
      <p>Хотя у функций нет параметров, передаваемых по имени, это все же обязательно нужно включить выражение присвоения в круглые скобки при вызове этих функций.</p>
    </li>
    <li>
      <p>По стандартному правилу запятая используется, чтобы разделить фактические параметры. Если Вы должны использовать последовательный оператор оценки, следует включать выражение в круглые скобки:</p>
      <p><tt>#emit MyMacro((SaveToFile(&quot;script.txt&quot;), 5), 10)<br />
      </tt></p>
      <p>В вышеупомянутом примере первая запятая обрабатывается как последовательный оператор оценки, тогда как второй как параметр delimitter.</p>
    </li>
  </ul>
</div>
</body>
</html>