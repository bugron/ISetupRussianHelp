<HTML><HEAD><META content="text/html; charset=windows-1251" http-equiv=Content-Type><STYLE type=text/css>BODY{FONT-FAMILY:Verdana,Arial,Helvetica,sans-serif}TD{FONT-WEIGHT:normal;FONT-SIZE:10pt;VERTICAL-ALIGN:top;FONT-FAMILY:Verdana,Arial,Helvetica,sans-serif}</STYLE></HEAD><BODY><H3><CENTER>Подборка полезных примеров из топика по <A href=http://forum.ru-board.com/topic.cgi?forum=5&amp;topic=27438 target=_newwindow>Inno Setup</A>. Составил <A href=http://forum.ru-board.com/profile.cgi?action=show&amp;member=fty target=_newwindow>fty</A>.</CENTER></H3><P><TABLE border=1 width=99% align=center><THEAD><TR bgColor=#e6e6e6><TD width=35% align=center><B>Вопрос</B></TD><TD width=90% align=center><B>Ответ</B></TD></TR><TBODY><TR><TD>Реально ли из архива .bin, созданного Inno, распаковать отдельные (нужные) файлы или только unpacker’ом весь разархивировать придется?</TD><TD><DT>Для Far и Total Commander есть примочки (см. описание innounp.htm в конце). Или воспользуйся синтаксисом командной строки: <DD><B>innounp -e setup.exe &lt;нужный файл&gt;</B> <DT>где &lt;нужный файл&gt; со всеми {...}-путями получаем так: <DD><B>innounp -v setup.exe</B> <DT>setup.exe - естественно то, что нужно распаковать. <DT>---<P></P><DT>Распаковать закриптованный инсталлятор: <DD><B>innounp setup.exe -x -m -f(pass.txt)</B> <DT>Pass узнаем, выдирая плагином compiledcode.bin. <DT>---<P></P><DT>Прекрасно выдирается хоть фаром, хоть командной строкой: <DD><B>innounp -x -m kppp10-0.bin embedded\CompiledCode.bin</B> <DT>---<P></P><DT>Извлечь правильный CompiledCode: <DD><B>innounp -v -m setup.exe</B></DD><TR><TD>Можно ли запустить рег-файлик "невидимым", чтобы без "Вы хотите....", "Данные успешно внесены" и т.д.? Как это изобразить в скрипте?</TD><TD><DT><B>regedit.exe /s file.reg</B> <FONT color=olive>;в командной строке или батнике</FONT><P></P><DT>В скрипте: <DD><FONT color=olive>[Run]</FONT><BR>Filename: {sys}\regedit.exe; Parameters: -s {app}\file.reg; WorkingDir: {sys}; StatusMsg: Внесение изменений в реестр...;<P></P><DT>А вообще-то для этого есть секция <FONT color=red>[Registry]</FONT>... <DT><FONT color=olive>(Или конвертировать .reg файлы с помощью конвертера, автор которого Serega, в скрипт Inno и использовать в секции</FONT> <FONT color=red>[Registry]</FONT>)</DT><TR><TD>Данные из reg-файла "тихо" занести в реестр.</TD><TD><DT>WinExec ПУТЬ_К_ФАЙЛУ -s</DT><TR><TD>Как сделать backup реестра (нескольких веток) и сохранить в нужном месте в виде reg-файла?</TD><TD><DT><FONT color=red>[Run]</FONT> <DT>Filename: {sys}\dllcache\regedit.exe; Parameters: -EA {win}\cursors\beeline\backup.reg "HKEY_CURRENT_USER\Control Panel\Cursors"; WorkingDir: {sys}; StatusMsg: Внесение изменений в реестр...;</DT><TR><TD>Мне нужно сделать backup реестра (нескольких веток) и сохранить в нужном месте в виде reg-файла ПЕРЕД ИНСТАЛЛЯЦИЕЙ.</TD><TD><DT>1. Перед инсталяцией - процедурой Procedure BeforeInstall; <DT>Вот пример: <DD><FONT color=red>[Code]</FONT> <DD>var <DD>ResultCode: Integer; <DD>Procedure MyBeforeInstall; <DD>Begin <DD>Exec(ExpandConstant('{pf}\QIP\Skins\{code:GetSkinName}\Smilies\DirRen.exe'), '', '', SW_SHOW, ewWaitUntilTerminated, ResultCode) <DD>end;<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "C:\123\Animated1\*.ini"; DestDir: "{app}"; BeforeInstall: MyBeforeInstall; Flags: ignoreversion; Components: first<P>Вот только как в один файл запихать несколько веток я не знаю. Теоретически может как-то так:</P><DT>copy all.reg+1.reg+2.reg+3.reg <FONT color=olive>;в коммандной строке или батнике</FONT><P></P><DT>2. Можно также сделать с помощью bat-файла такого содержания: <DD>start /wait regedit /ea Save1.reg "HKEY_CURRENT_USER\Software\Programs1" <DD>start /wait regedit /ea Save2.reg "HKEY_CURRENT_USER\Software\Programs2" <DD>start /wait regedit /ea Save3.reg "HKEY_CURRENT_USER\Software\Programs3" <DD>copy Save1.reg+Save2.reg+Save3.reg <DT>В файл Save1.reg будут скопированы все остальные файлы, что вроде и требовалось.</DT><TR><TD>Как сделать так, чтобы к пути, который инсталлятор ищет в реестре, прибавить еще название нужной папки? <DT>Скажем: <DT>DefaultDirName={reg:HKLM\Software\VST,VSTPluginsPath|{pf}\Vmd} <DT>инсталлятор нашел путь и указал при установке: C:\VstPlugs <DT>как прибавить название папки, чтобы автоматически получилось C:\VstPlugs\Vmd</DT></TD><TD>Можно написать функцию, возвращающую строку. В функции получить путь из реестра и приклеить к нему то, что надо и вернуть как результат. <DT>Тогда, наверное, можно будет написать:<P></P><DT>DefaultDirName={code:FunctionRegPath|{pf}\Vmd}<P></P><DT>где FunctionRegPath - это имя функции, возвращающей то, что надо.</DT><TR><TD>Мне нужно, чтобы инсталлятор искал в реестре ключ, копировал оттуда значение пути, а потом просто устанавливал этот путь как "корневой" для установочных файлов. Окно выбора папки для установки при этом выводиться ВООБЩЕ не должно (если значения в реестре нет - инсталлятор просто завершает работу).</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>DefaultDirName={reg:HKLM\Software\My Program, Path}<P></P><DT>где будет браться путь из HKLM\Software\My Program , где ключ обозван Path , где в ключе Path хранится путь до того, что тебе надо. <DT>Вот как отключить окно выбора пути установки:<P></P><DD><FONT color=red>[Setup]</FONT> <DD>DefaultDirName={pf}\My Program <DD>DisableDirPage=yes<P></P><DT>Если же тебе надо, чтобы при отсутствии пути в реестре установка отменялась, то тебе надо задать проверку в реестре наличия ключа Path. Хотя я допускаю, что возможно, если установка не найдет этот ключ в реестре, то она в любом случае отменит сама себя.</DT><TR><TD>Как сделать, чтобы на странице приветствия инсталлятор проверял наличие игры в системе пользователя через реестр, и, если она есть, вместо кнопки "Начать установку" была кнопка "Играть", при нажатии на которую инсталлятор бы вырубался и включался exe игры (путь к exe будет в реестре)?</TD><TD><DD><FONT color=red>[Code]</FONT> <DD>var ResultCode:Integer; <DD>ResultReg:string; <DD>procedure CurPageChanged(CurPageID:Integer); <DD>begin <DD>if CurPageID=wpWelcome then <DD>begin <DD>if RegValueExists(HKEY_LOCAL_MACHINE, 'Software\GSC Game World\STALKER-SHOC','InstallPath') then <DD>If WizardForm.FindComponent('NextButton') is TButton then <DD>TButton(WizardForm.FindComponent('NextButton')).Caption:='Играть'; <DD>end; <DD>end;<P></P><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>begin <DD>if RegValueExists(HKEY_LOCAL_MACHINE, 'Software\GSC Game World\STALKER-SHOC','InstallPath') then <DD>begin <DD>RegQueryStringValue(HKEY_LOCAL_MACHINE, 'Software\GSC Game World\STALKER-SHOC','InstallPath', ResultReg) <DD>Result:=False; <DD>Exec(ResultReg+'\XR_3DA.exe', '', '', SW_SHOW,ewNoWait, ResultCode) <DD>WizardForm.Close; <DD>end <DD>else <DD>Result:=True; <DD>end;<P></P><DD>procedure CancelButtonClick(CurPageID: Integer; var Cancel, Confirm: Boolean); <DD>begin <DD>Cancel:=True; <DD>if CurPageID=wpWelcome then <DD>begin <DD>if RegValueExists(HKEY_LOCAL_MACHINE, 'Software\GSC Game World\STALKER-SHOC','InstallPath') then <DD>Confirm:=False; <DD>end; <DD>end;<P></P><DT>P.S. Только есть одна проблема - если пользователь удалит игру не через деинсталлятор, а вручную, то потом он её не сможет установить из-за ветки в реестре.</DT><TR><TD>Есть задача: <DT>1. Имеется 4 версии exe файла программы и к каждому свои значения в реестре (установить на компьютер только один). <DT>2. Нужно при установке выбрать один из них и, соответственно, чтобы автоматически прописывалось в реестре именно к этому файлу значение и плюс один файл в системную папку.</DT></TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program 1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Types]</FONT> <DD>Name: custom; Description: Custom; Flags: iscustom<P></P><DD><FONT color=red>[Components]</FONT> <DD>Name: Component1; Description: Component1; Flags: exclusive <DD>Name: Component2; Description: Component2; Flags: exclusive <DD>Name: Component3; Description: Component3; Flags: exclusive <DD>Name: Component4; Description: Component4; Flags: exclusive<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: 1.exe; DestDir: {app}; Components: Component1 <DD>Source: 2.exe; DestDir: {app}; Components: Component2 <DD>Source: 3.exe; DestDir: {app}; Components: Component3 <DD>Source: 4.exe; DestDir: {app}; Components: Component4 <DD>Source: system.exe; DestDir: {sys}<P></P><DD><FONT color=red>[Registry]</FONT> <DD>Root: HKLM; Subkey: SOFTWARE\My Program; ValueType: String; ValueName: 1; ValueData: {app}\1.exe; Flags: uninsdeletekey; Components: Component1 <DD>Root: HKLM; Subkey: SOFTWARE\My Program; ValueType: String; ValueName: 2; ValueData: {app}\2.exe; Flags: uninsdeletekey; Components: Component2 <DD>Root: HKLM; Subkey: SOFTWARE\My Program; ValueType: String; ValueName: 3; ValueData: {app}\3.exe; Flags: uninsdeletekey; Components: Component3 <DD>Root: HKLM; Subkey: SOFTWARE\My Program; ValueType: String; ValueName: 4; ValueData: {app}\4.exe; Flags: uninsdeletekey; Components: Component4</DD><TR><TD>Можно ли в Inno Setup задать, чтобы установка начиналась только если в реестре присутствует некоторый ключ?</TD><TD>Вот готовый скрипт.<P><DD>#define DateTime GetDateTimeString('ddddd','','')<P></P><DD><FONT color=red>[Setup]</FONT> <DD>AppName=CheckRegValue <DD>AppVerName=CheckRegValue and select Component <DD>DefaultDirName={pf}\My Program <DD>OutputBaseFilename=Setup (сборка от {#DateTime})<P></P><DD><FONT color=red>[Tasks]</FONT> <DD>Name: eng; Description: Английская версия; Check: CheckKey <DD>Name: rus; Description: Русская версия; Check: not CheckKey<P></P><DD><FONT color=red>[Code]</FONT> <DD>Function CheckKey: Boolean; <DD>Begin <DD>if ExpandConstant('{reg:HKLM\Software\LucasArts\Star Wars Empire at War\1.0,CD Key}') = 'fc4c-3d8-05f-d411-uk20' then Result:= True <DD>End;<P></P><DD>Function InitializeSetup: Boolean; <DD>Begin <DD>If RegValueExists(HKLM, 'Software\LucasArts\Star Wars Empire at War\1.0\ExePath', ExpandConstant('{#SetupSetting("DefaultDirName")}')) then Result:= <DD>True else MsgBox('Программа ' + '{#SetupSetting("AppName")}' + ' не установлена!', mbInformation, mb_Ok) <DD>End;</DD><TR><TD>У меня с предыдущим примером проблема. Вобщем, сам ключ в реестре присутствует, но все равно светит то сообщение, которое должно быть только если ключа нет.</TD><TD>Вариант 1- укажи DefaultDirName равным ExePath в реестре, например: <DD><FONT color=red>[Setup]</FONT><BR>DefaultDirName={pf}\Star Wars Empire at War<P></P><DD><FONT color=red>[Code]</FONT><BR>function InitializeSetup: Boolean; var Str: string; Begin <DD>RegQueryStringValue(HKLM, 'Software\LucasArts\Star Wars Empire at War\1.0', 'ExePath', Str) <DD>If Uppercase(Str) = Uppercase(ExpandConstant('{#SetupSetting("DefaultDirName")}\GameData\sweaw.exe')) then Result:= True else MsgBox('Программа {#SetupSetting("AppName")} не установлена!', mbInformation, mb_Ok) <DD>End;<P></P><DT>Второй вариант более универсальный, считывает оба ключа из реестра и не зависит от папки установки: <DD><FONT color=red>[Code]</FONT><BR>function InitializeSetup: Boolean; Begin <DD>If Uppercase(ExpandConstant('{reg:HKLM\Software\Microsoft\Windows\CurrentVersion\Uninstall\{#SetupSetting("AppName")}_is1,InstallLocation}\GameData\sweaw.exe')) = Uppercase(ExpandConstant('{reg:HKLM\Software\LucasArts\Star Wars Empire at War\1.0,ExePath}')) then Result:= True else MsgBox('{#SetupSetting("AppName")} не найдена!', mbInformation, mb_Ok) <DD>End;</DD><TR><TD>А как сделать чтобы ПЕРЕД НАЧАЛОМ ИНСТАЛЛЯЦИИ если система ХР, то запускался File1.exe, а если Vista, то File2.exe?</TD><TD><DD><FONT color=red>[Code]</FONT><BR>function InitializeSetup (): Boolean; <DD>var Version: TWindowsVersion;<P></P><DD>begin <DD>GetWindowsVersionEx(Version); <DD>if Version.NTPlatform and (Version.Major = 6) and (Version.Minor = 0) then <DD>begin <DD>MsgBox('You OS Windows Vista' ,mbInformation, mb_Ok); <DD>//Exec <DD>Result:= True; <DD>end;<P></P><DD>begin <DD>GetWindowsVersionEx(Version); <DD>if Version.NTPlatform and (Version.Major = 5) and (Version.Minor = 1) then <DD>begin <DD>MsgBox('You OS Windows XP' ,mbInformation, mb_Ok); <DD>//Exec <DD>Result:= True; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Как сделать, чтобы после удаления удалились абсолютно ВСЕ ключи, созданные во время установки?</TD><TD>К каждому параметру добавь флаг <B>uninsdeletevalue</B><TR><TD>Как изменить размер и текст кнопки "Далее" на одной странице, чтобы это изменение не влияло на все другие страницы?</TD><TD>Никак. Кнопки Далее, Назад и Отмена находятся на WizardForm, а не на странице. Другими словами, кнопка Далее всего одна. <DT>Максимум, что можно сделать, это изменить размер и текст при переходе на одну страницу и восстановить размер и текст при переходе на следующую или предыдущую.<P></P><DT>Возможный вариант: <DD><FONT color=red>[Code]</FONT> <DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>if CurPageID = wpWelcome then <DD>begin <DD>WizardForm.NextButton.Width:=75 <DD>WizardForm.NextButton.Left:=327 <DD>end; <DD>if CurPageID = wpSelectDir then <DD>begin <DD>WizardForm.BackButton.Left:=180 <DD>WizardForm.NextButton.Width:=150 <DD>WizardForm.NextButton.Left:=255 <DD>WizardForm.NextButton.Caption:='Инициализировать дискету' <DD>end; <DD>if CurPageID = wpReady then <DD>begin <DD>WizardForm.NextButton.Width:=75 <DD>WizardForm.NextButton.Left:=327 <DD>WizardForm.BackButton.Left:=252 <DD>end; <DD>end;</DD><TR><TD>Как сделать неактивной кнопку 'Далее' на createcustompage?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Page: TWizardPage;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>Page := CreateCustomPage(wpWelcome, 'Custom wizard page', 'Disable Next button'); <DD>end;<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>if CurPageID = Page.ID then <DD>WizardForm.NextButton.Enabled:=false; <DD>end;</DD><TR><TD>Как добиться такого, чтобы кнопка "Далее" становилась неактивна, когда не выбран ни один компонент <FONT color=red>[Components]</FONT> во время установки? Ведь нет никакого смысла ставить, если ничего не выбрано!</TD><TD>Вариант 1: <DD><FONT color=red>[Code]</FONT><BR>function NextButtonClick(CurPageID: Integer): Boolean; <DD>begin <DD>Result:= True; <DD>if WizardSelectedComponents(False) = '' then <DD>begin <DD>MsgBox('Ни один из компонентов не выбран!', mbInformation, MB_OK); <DD>Result:= False; <DD>end; <DD>end;<P></P><DT>Вариант 2: <DD><FONT color=red>[Code]</FONT><BR>procedure ComponentOnClick(Sender: TObject); <DD>begin <DD>if WizardSelectedComponents(False) = '' then <DD>WizardForm.NextButton.Enabled:= False <DD>else WizardForm.NextButton.Enabled:= True; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.ComponentsList.OnClick := @ComponentOnClick; <DD>end;<P></P><DT>2-ой вариант работает только при выборе компонентов мышкой (обработка нажатия пробела - на ваше усмотрение).</DT><TR><TD>Как в InnoSetup сделать выбор установки компонентов?</TD><TD>1. Нужно определиться, сколько и каких компонентов должно содержаться: <DD><FONT color=red>[Components]</FONT> <DD>Name: main; Description: Программные файлы; Flags: fixed; Types: custom compact full <DD>Name: Component1; Description: Факультатив 1; Flags: checkablealone; Types: full <DD>Name: Component2; Description: Факультатив 2; Flags: checkablealone; Types: full<P>2. Нужно разложить исходные файлы по каталогам, в каждом из которых ты разместишь файлы того или иного компонента:</P><DD>C:\temp\MyApp\main <DD>C:\temp\MyApp\comp1 <DD>C:\temp\MyApp\comp2<P>3. Нужно прописать размещение исходных файлов в скрипте, указав для них привязку к тому или иному компоненту:</P><DD><FONT color=red>[Files]</FONT> <DD>Source: C:\temp\MyApp\main\*; DestDir: {app}; Flags: ignoreversion; Components: main <DD>Source: C:\temp\MyApp\comp1\*; DestDir: {app}; Flags: ignoreversion; Components: Component1 <DD>Source: C:\temp\MyApp\comp2\*; DestDir: {app}; Flags: ignoreversion; Components: Component2</DD><TR><TD>Подскажите, откуда взять размер выбранных компонентов на странице <B>wpSelectComponents</B>? Где он хранится?</TD><TD>WizardForm.ComponentsList.ItemSubItem[Index: Integer]<P><DT>Пример:<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>var <DD>str: string; <DD>i: integer; <DD>begin <DD>if CurPageID = wpSelectComponents then <DD>begin <DD>for i:= 0 to WizardForm.ComponentsList.Items.Count - 1 do <DD>begin <DD>str:= str + WizardForm.ComponentsList.ItemCaption[i] + ' - size: ' + WizardForm.ComponentsList.ItemSubItem[i] + #10#13; <DD>end; <DD>MsgBox(str, mbInformation, MB_OK); <DD>end; <DD>end;</DD><TR><TD>Мне нужно получить размер места на диске, который нужен для выбранных компонентов. Например, из списка выбрана часть компонентов и Inno Setup пишет внизу страницы, сколько потребуется для них места. Где хранится это число, чтобы использовать его в дальнейшем?</TD><TD><DD>function GetComponentSpace(): Currency; <DD>var <DD>ComponentSpace: string; <DD>StartLen, EndLen, SpaceLen: integer; <DD>begin <DD>ComponentSpace:= SetupMessage(msgComponentsDiskSpaceMBLabel); <DD>StartLen:= Pos('[', ComponentSpace); <DD>EndLen:= Length(ComponentSpace) - Pos(']', ComponentSpace); <DD>ComponentSpace:= WizardForm.ComponentsDiskSpaceLabel.Caption; <DD>SpaceLen:= Length(ComponentSpace) - StartLen - EndLen + 2; <DD>ComponentSpace:= Copy(ComponentSpace, StartLen, SpaceLen);<P></P><DD>Result:= StrToFloat(Trim(ComponentSpace)); <DD>end;<P></P><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>begin <DD>if CurPageID = wpSelectComponents then <DD>MsgBox(FloatToStr(GetComponentSpace), mbInformation, MB_OK); <DD>Result:= True; <DD>end;<P></P><DT>Можно слегка упростить:<P></P><DD>function GetComponentSpace(): Currency; <DD>var <DD>ComponentSpace, LabelSpace: string; <DD>StartLen, EndLen, SpaceLen: integer; <DD>begin <DD>ComponentSpace:= SetupMessage(msgComponentsDiskSpaceMBLabel); <DD>LabelSpace:= WizardForm.ComponentsDiskSpaceLabel.Caption;<P></P><DD>StartLen:= Pos('[mb]', ComponentSpace); <DD>SpaceLen:= Length(LabelSpace) - Length(ComponentSpace) + 4; <DD>ComponentSpace:= Copy(LabelSpace, StartLen, SpaceLen);<P></P><DD>Result:= StrToFloat(Trim(ComponentSpace)); <DD>end;<P></P><DT>А можно использовать и другой прием:<P></P><DD><FONT color=red>[Messages]</FONT> <DD>ComponentsDiskSpaceMBLabel=[mb]<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Lbl: TLabel;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>Lbl := TLabel.Create(WizardForm); <DD>with WizardForm.ComponentsDiskSpaceLabel do <DD>begin <DD>Lbl.Top := Top; <DD>Lbl.Left:= Left; <DD>Lbl.AutoSize := True; <DD>Lbl.Caption := 'Disk space requires (Mb): '; <DD>Lbl.Parent := Parent; <DD>Left:= Lbl.Left + Lbl.Width; <DD>end; <DD>end;<P></P><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>var <DD>str: string; <DD>begin <DD>if CurPageID = wpSelectComponents then <DD>begin <DD>MsgBox(WizardForm.ComponentsDiskSpaceLabel.Caption, mbInformation, MB_OK); <DD>end; <DD>Result:= True; <DD>end;</DD><TR><TD>Как сделать, чтобы при установке можно было выбрать загрузку приложения вместе с Windows?</TD><TD><DD><FONT color=red>[Tasks]</FONT> <DD>Name: RunMyProgrammInStartup; Description: "Запускать программу при загрузке Windows?"; <DD><FONT color=red>[Registry]</FONT> <DD>Root: HKCU; Subkey: "Software\Microsoft\Windows\CurrentVersion\Run\"; ValueType: string; ValueName: "MyProgramm"; ValueData: "{app}\MyProgramm.exe"; Flags: uninsdeletevalue; Tasks: RunMyProgrammInStartup;<P>Можно и в LOCAL MACHINE записать, но тут уже нужно думать, а надо ли?</P><DD><FONT color=red>[Registry]</FONT> <DD>Root: HKLM; Subkey: "Software\Microsoft\Windows\CurrentVersion\Run\"; ValueType: string; ValueName: "MyProgramm"; ValueData: "{app}\MyProgramm.exe"; Flags: uninsdeletevalue; Tasks: RunMyProgrammInStartup;</DD><TR><TD>Подскажите, как убрать все окошки с приветствиями и диалогами?</TD><TD>Попробовать в разделе <FONT color=red>[Setup]</FONT> выставить разные DisableProgramGroupPage=yes, DisableDirPage=yes, DisableFinishedPage=yes, DisableReadyPage=yes, DisableStartupPrompt=yes. Выбирай, что из этого нужно.<P>Если надо, чтобы совсем без диалогов, щелкнул по сетапу и все, то: <DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableDirPage=yes <DD>DisableProgramGroupPage=yes <DD>DisableReadyPage=yes <DD>DisableFinishedPage=yes <DD>OutputBaseFilename=setup <DD>Compression=lzma <DD>SolidCompression=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "C:\My Program\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>If CurPageID=wpWelcome then <DD>begin <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 513, 0, 0) <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 514, 0, 0) <DD>end; <DD>end;</DD><TR><TD>Мне надо, чтобы изо всех диалоговых окон, типа страницы приветствия, страницы выбора папки установки, страницы выбора ярлыков и т.д., показываемых пользователю при установке готовой программы, выдавалось только одно - диалог выбора папки установки и всё.</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program <DD>DefaultDirName={pf}\My Program <DD>DisableReadyPage=True <DD>DisableFinishedPage=True<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>If CurPageID=wpWelcome then <DD>begin <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 513, 0, 0) <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 514, 0, 0) <DD>end <DD>end;</DD><TR><TD>Как убрать самую первую страницу?</TD><TD><DD><FONT color=red>[Code]</FONT> <DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>If CurPageID=wpWelcome then <DD>begin <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 513, 0, 0) <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 514, 0, 0) <DD>end; <DD>end;</DD><TR><TD>Как сделать, чтобы в конце установки выскакивало окошечко с надписью: "Программа (Имя программы) установлена!", т.к. я отключил страницу конца установки.</TD><TD><DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>begin <DD>if CurStep = ssDone then <DD>MsgBox('Программа ' + '{#SetupSetting("AppName")}' + ' установлена!', mbInformation, MB_OK); <DD>end;</DD><TR><TD>А как для предыдущего случая сделать 2 кнопочки: Ок и Сancel? При нажатии на ОК запускается игра, а на Cancel, соответсвенно, нет.</TD><TD><DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>var <DD>ResultCode: Integer; <DD>begin <DD>if CurStep = ssDone then <DD>if MsgBox('Программа ' + '{#SetupSetting("AppName")}' + ' установлена!' + #10#10#13 + 'Запустить ' + '{#SetupSetting("AppName")}' + '?' , mbInformation, MB_OKCANCEL) = IDOK then <DD>Exec(ExpandConstant('{app}\bin\XR_3DA.exe'), '', '', SW_SHOW, ewNoWait, ResultCode); <DD>end;</DD><TR><TD>Сделал DisableDirPage=true. Как теперь проверять свободное место и выдавать сообщение в случае, если его недостаточно? Можно ли не отключать эту страницу, а просто сделать неактивным выбор папки?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.DirBrowseButton.Enabled:=False <DD>WizardForm.DirEdit.Enabled:=False <DD>end;</DD><TR><TD>Хочу прикрутить wave, чтобы при установке играла музыка. Но не получается, компилируется, устанавливается, а музыки нет.</TD><TD>Для проигрывания wave (без всяких ISSI) следует дописать следующее: <DD><FONT color=red>[Files]</FONT> <DD>Source: "C:\sound.wav"; DestDir: "{tmp}"; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>function sndPlaySound(lpszSoundName: string; uFlags: cardinal):integer; <DD>external 'sndPlaySoundA@winmm.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ExtractTemporaryFile(ExpandConstant('sound.wav'));<FONT color=green> //Извлекаем звуковой файл во временную папку</FONT> <DD>sndPlaySound(ExpandConstant('{tmp}\sound.wav'), $0001 or $0008);<FONT color=green> //Проигрываем файл. Здесь указаны параметры для повторного проигрывания. Если мы хотим проиграть файл единожды, удаляем параметр 'or $0008'</FONT> <DD>end;<P></P><DT>Для проигрывания MIDI делаем так: <DD><FONT color=red>[Files]</FONT> <DD>Source: "C:\sound.mid"; DestDir: "{tmp}"; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>function mciSendString(lpstrCommand: string; lpstrReturnString: string; uReturnLength:integer; hwndCallback:integer):integer; <DD>external 'mciSendStringA@winmm.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ExtractTemporaryFile(ExpandConstant('sound.mid')); <DD>mciSendString(ExpandConstant('play {tmp}\sound.mid'),'NULL',0,0); <DD>end;<P></P><DT>Как сделать повторение воспроизведения midi я не знаю.</DT><TR><TD>Пример скрипта, в котором в секции <FONT color=red>[Code]</FONT> реализовано проигрывание музыки в wav и фоновое изображение bmp.</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: "C:\sound.wav"; DestDir: "{tmp}"; Flags: dontcopy <DD>Source: "C:\background.bmp"; DestDir: "{tmp}"; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>function sndPlaySound(lpszSoundName: string; uFlags: cardinal):integer; <DD>external 'sndPlaySoundA@winmm.dll stdcall';<P></P><DD>function GetSystemMetrics(nIndex:Integer):Integer; <DD>external 'GetSystemMetrics@user32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>BackgroundBitmapImage: TBitmapImage; <DD>s:string; <DD>width, height:Integer; <DD>bitmap:TBitmap; <DD>begin <DD>ExtractTemporaryFile('background.bmp'); <DD>ExtractTemporaryFile('sound.wav'); <DD>sndPlaySound(ExpandConstant('{tmp}\sound.wav'), $0001 or $0008); <DD>WizardForm.Position:=poScreenCenter; <DD>MainForm.BORDERSTYLE:=bsNone; <DD>width:=GetSystemMetrics(61); <DD>height:=GetSystemMetrics(62); <DD>MainForm.Width:=width; <DD>MainForm.Height:=height; <DD>width:=MainForm.ClientWidth; <DD>height:=MainForm.ClientHeight; <DD>s:=ExpandConstant('{tmp}')+'\background.bmp'; <DD>BackgroundBitmapImage := TBitmapImage.Create(MainForm); <DD>BackgroundBitmapImage.Bitmap.LoadFromFile(s); <DD>BackgroundBitmapImage.Align := alClient; <DD>BackgroundBitmapImage.Parent := MainForm; <DD>BackgroundBitmapImage.Stretch:=True; <DD>MainForm.Visible:=True; <DD>end;</DD><TR><TD>Как через какую-либо кнопку прекратить воспроизведение звука?</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: compiler:sound.wav; DestDir: "{tmp}"; Flags: dontcopy nocompression<P></P><DD><FONT color=red>[Code]</FONT> <DD>function sndPlaySound(lpszSoundName: string; uFlags: cardinal):integer; <DD>external 'sndPlaySoundA@winmm.dll stdcall';<P></P><DD>procedure StopSound(Sender: TObject); <DD>begin <DD>sndPlaySound(ExpandConstant(''), $0001 or $0008); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>var <DD>ButtonStop: TButton; <DD>begin <DD>ExtractTemporaryFile(ExpandConstant('sound.wav')); <DD>sndPlaySound(ExpandConstant('{tmp}\sound.wav'), $0001 or $0008);<P></P><DD>ButtonStop := TButton.Create(WizardForm); <DD>with ButtonStop do <DD>begin <DD>Parent := WizardForm; <DD>Caption :='stop'; <DD>Left := ScaleX(8); <DD>Top :=320 <DD>Width := ScaleX(43); <DD>Height := ScaleY(33); <DD>TabOrder := 0; <DD>OnClick:=@StopSound <DD>end; <DD>end;</DD><TR><TD>Как вставить в инсталлятор трекерную музыку?</TD><TD>Кто вставляет в инсталлятор трекерную музыку, даю свое решение по проигрыванию трекерной музыки через библиотеку BassMod.dll, взять которую можно отсюда: <A href=http://un4seen.com/files/bassmod20.zip target=_newwindow>http://un4seen.com/files/bassmod20.zip</A> <DT>Дело в том, что она поддерживает почти все трекерные форматы и проигрывает более корректно некоторые чипы, чем ранее предложенная MiniFMod.dll. <DT>Вот код: <DD><FONT color=red>[Files]</FONT> <DD>Source: "C:\BASSMOD.dll"; DestDir: "{tmp}"; Flags: dontcopy <DD>Source: "C:\music.mod"; DestDir: "{tmp}"; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>BASS_MUSIC_LOOP = 4;<P></P><DD>function BASSMOD_Init(device: Integer; freq, flags: DWORD): Boolean; <DD>external 'BASSMOD_Init@files:BASSMOD.dll stdcall delayload';<P></P><DD>procedure BASSMOD_MusicFree(); <DD>external 'BASSMOD_MusicFree@files:BASSMOD.dll stdcall delayload';<P></P><DD>function BASSMOD_MusicLoad(mem: BOOL; f: PChar; offset: DWORD; length: DWORD; flags: DWORD): Boolean; <DD>external 'BASSMOD_MusicLoad@files:BASSMOD.dll stdcall delayload';<P></P><DD>function BASSMOD_MusicPlay(): Boolean; <DD>external 'BASSMOD_MusicPlay@files:BASSMOD.dll stdcall delayload';<P></P><DD>procedure BASSMOD_Free(); <DD>external 'BASSMOD_Free@files:BASSMOD.dll stdcall delayload';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>hMod: Integer; <DD>Name1: string; <DD>begin <DD>ExtractTemporaryFile(ExpandConstant('BASSMOD.dll')); <DD>ExtractTemporaryFile(ExpandConstant('music.mod')); <DD>if not BASSMOD_Init(-1,44100,0) then begin <DD>MsgBox('BASSMOD не смогла инициализироваться, проигрывание музыки невозможно.', mbInformation, MB_OK) <DD>BASSMOD_Free; <DD>end; <DD>begin <DD>Name1:=ExpandConstant('{tmp}\music.mod'); <DD>BASSMOD_MusicFree; <DD>if BASSMOD_MusicLoad(FALSE, PChar(Name1), 0, 0, BASS_MUSIC_LOOP) then <DD>BASSMOD_MusicPlay; <DD>end; <DD>end;<P></P><DT>А также смотрим примеры библиотеки для указания дополнительных параметров воспроизведения.</DT><TR><TD>Пример 1 – музыка воспроизводится только при нажатии кнопки «play»</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program 1.5 <DD>AppPublisher=My Company, Inc. <DD>DefaultDirName=C:\example<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: BASS.dll; DestDir: " {tmp} "; Flags: dontcopy noencryption <DD>Source: sound.mp3; DestDir: "{tmp}"; Flags: dontcopy noencryption nocompression<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>BASS_ACTIVE_STOPPED = 0; <DD>BASS_ACTIVE_PLAYING = 1; <DD>BASS_ACTIVE_STALLED = 2; <DD>BASS_ACTIVE_PAUSED = 3; <DD>BASS_SAMPLE_LOOP = 4;<P></P><DD>var <DD>mp3Handle: HWND; <DD>mp3Name: string;<P></P><DD>function BASS_Init(device: Integer; freq, flags: DWORD; win: hwnd; CLSID: Integer): Boolean; <DD>external 'BASS_Init@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_StreamCreateFile(mem: BOOL; f: PChar; offset: DWORD; length: DWORD; flags: DWORD): DWORD; <DD>external 'BASS_StreamCreateFile@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Start(): Boolean; <DD>external 'BASS_Start@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelPlay(handle: DWORD; restart: BOOL): Boolean; <DD>external 'BASS_ChannelPlay@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelIsActive(handle: DWORD): Integer; <DD>external 'BASS_ChannelIsActive@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelPause(handle: DWORD): Boolean; <DD>external 'BASS_ChannelPause@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Stop(): Boolean; <DD>external 'BASS_Stop@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Pause(): Boolean; <DD>external 'BASS_Pause@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Free(): Boolean; <DD>external 'BASS_Free@files:BASS.dll stdcall delayload';<P></P><DD>function InitializeSetup(): Boolean; <DD>begin <DD>ExtractTemporaryFile('BASS.dll'); <DD>ExtractTemporaryFile('sound.mp3'); <DD>mp3Name := ExpandConstant('{tmp}\sound.mp3'); <DD>mp3Handle := BASS_StreamCreateFile(FALSE, PChar(mp3Name), 0, 0, BASS_SAMPLE_LOOP); <DD>Result := True; <DD>end;<P></P><DD>procedure PlayButtonOnClick(Sender: TObject); <DD>begin <DD>case BASS_ChannelIsActive(mp3Handle) of <DD>BASS_ACTIVE_PAUSED: <DD>begin <DD>BASS_ChannelPlay(mp3Handle, False); <DD>end; <DD>BASS_ACTIVE_STOPPED: <DD>begin <DD>BASS_Init(-1, 44100, 0, 0, 0); <DD>mp3Handle := BASS_StreamCreateFile(FALSE, PChar(mp3Name), 0, 0, BASS_SAMPLE_LOOP); <DD>BASS_Start(); <DD>BASS_ChannelPlay(mp3Handle, False); <DD>end; <DD>end; <DD>end;<P></P><DD>procedure PauseButtonOnClick(Sender: TObject); <DD>begin <DD>BASS_ChannelPause(mp3Handle); <DD>end;<P></P><DD>procedure StopButtonOnClick(Sender: TObject); <DD>begin <DD>BASS_Stop(); <DD>BASS_Free(); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>var <DD>Name1: string; <DD>PlayButton, PauseButton, StopButton: TButton; <DD>Text: TNewStaticText; <DD>Panel1: TPanel; <DD>begin <DD>WizardForm.Position := poScreenCenter; <DD>WizardForm.CancelButton.BringToFront; <DD>begin <DD>Panel1 := TPanel.Create(WizardForm); <DD>with Panel1 do <DD>begin <DD>Panel1.Parent := WizardForm; <DD>Panel1.Left := ScaleX(1); <DD>Panel1.Top := ScaleY(315); <DD>Panel1.Width := ScaleX(165); <DD>Panel1.Height := ScaleY(46); <DD>Panel1.TabOrder := 0; <DD>Panel1.Color := clWhite; <DD>Panel1.BevelInner := bvLowered; <DD>Panel1.BevelOuter := bvRaised; <DD>Panel1.BorderStyle := bsSingle;<P></P><DD>PlayButton := TButton.Create(WizardForm); <DD>PlayButton.Left := 5; <DD>PlayButton.Top := 335; <DD>PlayButton.Width := 50; <DD>PlayButton.Height := 20; <DD>PlayButton.Caption := 'play'; <DD>PlayButton.OnClick := @PlayButtonOnClick; <DD>PlayButton.Parent := WizardForm; <DD>PlayButton.Cursor := crHand;<P></P><DD>PauseButton := TButton.Create(WizardForm); <DD>PauseButton.Left := 58; <DD>PauseButton.Top := 335; <DD>PauseButton.Width := 50; <DD>PauseButton.Height := 20; <DD>PauseButton.Caption := 'pause'; <DD>PauseButton.OnClick := @PauseButtonOnClick; <DD>PauseButton.Parent := WizardForm; <DD>PauseButton.Cursor := crHand;<P></P><DD>StopButton := TButton.Create(WizardForm); <DD>StopButton.Left := 111; <DD>StopButton.Top := 335; <DD>StopButton.Width := 50; <DD>StopButton.Height := 20; <DD>StopButton.Caption := 'stop'; <DD>StopButton.OnClick := @StopButtonOnClick; <DD>StopButton.Parent := WizardForm; <DD>StopButton.Cursor := crHand;<P></P><DD>Text := TNewStaticText.Create(WizardForm); <DD>Text.Caption := 'music'; <DD>Text.Parent := WizardForm; <DD>Text.Font.Style := Text.Font.Style + [fsUnderline]; <DD>Text.Font.Color := clNavy; <DD>Text.Top := 319; <DD>Text.Left := 71; <DD>Text.Color := clWhite; <DD>end; <DD>end; <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>begin <DD>BASS_Stop(); <DD>BASS_Free(); <DD>end;</DD><TR><TD>Пример 2 – музыка воспроизводится сразу при запуске</TD><TD><DD>AppName=My Program <DD>AppVerName=My Program 1.5 <DD>AppPublisher=My Company, Inc. <DD>DefaultDirName=C:\example<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: BASS.dll; DestDir: " {tmp} "; Flags: dontcopy noencryption <DD>Source: sound.mp3; DestDir: "{tmp}"; Flags: dontcopy noencryption nocompression<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>BASS_ACTIVE_STOPPED = 0; <DD>BASS_ACTIVE_PLAYING = 1; <DD>BASS_ACTIVE_STALLED = 2; <DD>BASS_ACTIVE_PAUSED = 3; <DD>BASS_SAMPLE_LOOP = 4;<P></P><DD>var <DD>mp3Handle: HWND; <DD>mp3Name: string;<P></P><DD>function BASS_Init(device: Integer; freq, flags: DWORD; win: hwnd; CLSID: Integer): Boolean; <DD>external 'BASS_Init@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_StreamCreateFile(mem: BOOL; f: PChar; offset: DWORD; length: DWORD; flags: DWORD): DWORD; <DD>external 'BASS_StreamCreateFile@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Start(): Boolean; <DD>external 'BASS_Start@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelPlay(handle: DWORD; restart: BOOL): Boolean; <DD>external 'BASS_ChannelPlay@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelIsActive(handle: DWORD): Integer; <DD>external 'BASS_ChannelIsActive@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelPause(handle: DWORD): Boolean; <DD>external 'BASS_ChannelPause@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Stop(): Boolean; <DD>external 'BASS_Stop@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Pause(): Boolean; <DD>external 'BASS_Pause@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Free(): Boolean; <DD>external 'BASS_Free@files:BASS.dll stdcall delayload';<P></P><DD>function InitializeSetup(): Boolean; <DD>begin <DD>ExtractTemporaryFile('BASS.dll'); <DD>ExtractTemporaryFile('sound.mp3'); <DD>mp3Name := ExpandConstant('{tmp}\sound.mp3'); <DD>BASS_Init(-1, 44100, 0, 0, 0); <DD>mp3Handle := BASS_StreamCreateFile(FALSE, PChar(mp3Name), 0, 0, BASS_SAMPLE_LOOP); <DD>BASS_Start(); <DD>BASS_ChannelPlay(mp3Handle, False); <DD>Result := True; <DD>end;<P></P><DD>procedure PlayButtonOnClick(Sender: TObject); <DD>begin <DD>case BASS_ChannelIsActive(mp3Handle) of <DD>BASS_ACTIVE_PAUSED: <DD>begin <DD>BASS_ChannelPlay(mp3Handle, False); <DD>end; <DD>BASS_ACTIVE_STOPPED: <DD>begin <DD>BASS_Init(-1, 44100, 0, 0, 0); <DD>mp3Handle := BASS_StreamCreateFile(FALSE, PChar(mp3Name), 0, 0, BASS_SAMPLE_LOOP); <DD>BASS_Start(); <DD>BASS_ChannelPlay(mp3Handle, False); <DD>end; <DD>end; <DD>end;<P></P><DD>procedure PauseButtonOnClick(Sender: TObject); <DD>begin <DD>BASS_ChannelPause(mp3Handle); <DD>end;<P></P><DD>procedure StopButtonOnClick(Sender: TObject); <DD>begin <DD>BASS_Stop(); <DD>BASS_Free(); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>var <DD>Name1: string; <DD>PlayButton, PauseButton, StopButton: TButton; <DD>Text: TNewStaticText; <DD>Panel1: TPanel; <DD>begin <DD>WizardForm.Position := poScreenCenter; <DD>WizardForm.CancelButton.BringToFront; <DD>begin <DD>Panel1 := TPanel.Create(WizardForm); <DD>with Panel1 do <DD>begin <DD>Panel1.Parent := WizardForm; <DD>Panel1.Left := ScaleX(1); <DD>Panel1.Top := ScaleY(315); <DD>Panel1.Width := ScaleX(165); <DD>Panel1.Height := ScaleY(46); <DD>Panel1.TabOrder := 0; <DD>Panel1.Color := clWhite; <DD>Panel1.BevelInner := bvLowered; <DD>Panel1.BevelOuter := bvRaised; <DD>Panel1.BorderStyle := bsSingle;<P></P><DD>PlayButton := TButton.Create(WizardForm); <DD>PlayButton.Left := 5; <DD>PlayButton.Top := 335; <DD>PlayButton.Width := 50; <DD>PlayButton.Height := 20; <DD>PlayButton.Caption := 'play'; <DD>PlayButton.OnClick := @PlayButtonOnClick; <DD>PlayButton.Parent := WizardForm; <DD>PlayButton.Cursor := crHand;<P></P><DD>PauseButton := TButton.Create(WizardForm); <DD>PauseButton.Left := 58; <DD>PauseButton.Top := 335; <DD>PauseButton.Width := 50; <DD>PauseButton.Height := 20; <DD>PauseButton.Caption := 'pause'; <DD>PauseButton.OnClick := @PauseButtonOnClick; <DD>PauseButton.Parent := WizardForm; <DD>PauseButton.Cursor := crHand;<P></P><DD>StopButton := TButton.Create(WizardForm); <DD>StopButton.Left := 111; <DD>StopButton.Top := 335; <DD>StopButton.Width := 50; <DD>StopButton.Height := 20; <DD>StopButton.Caption := 'stop'; <DD>StopButton.OnClick := @StopButtonOnClick; <DD>StopButton.Parent := WizardForm; <DD>StopButton.Cursor := crHand;<P></P><DD>Text := TNewStaticText.Create(WizardForm); <DD>Text.Caption := 'music'; <DD>Text.Parent := WizardForm; <DD>Text.Font.Style := Text.Font.Style + [fsUnderline]; <DD>Text.Font.Color := clNavy; <DD>Text.Top := 319; <DD>Text.Left := 71; <DD>Text.Color := clWhite; <DD>end; <DD>end; <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>begin <DD>BASS_Stop(); <DD>BASS_Free(); <DD>end;</DD><TR><TD>Код, в котором при нажатии на кнопку (только для музыкальных кнопок) меняется рисунок.</TD><TD><DD><FONT color=red>[Files]</FONT> <DD><FONT color=green>;Использован рисунок размером 180х20</FONT> <DD>Source: MusicButton.bmp; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>PlayButton, PauseButton, StopButton: TPanel; <DD>PlayImage, PauseImage, StopImage: TBitmapImage; <DD>PlayLabel, PauseLabel, StopLabel: TLabel;<P></P><DD>procedure PlayMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>if PlayLabel.Enabled then <DD>PlayImage.Left:=-90 <DD>end;<P></P><DD>procedure PlayMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>PlayImage.Left:=0 <DD>end;<P></P><DD>procedure PauseMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>if PauseLabel.Enabled then <DD>PauseImage.Left:=-120 <DD>end;<P></P><DD>procedure PauseMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>PauseImage.Left:=-30 <DD>end;<P></P><DD>procedure StopMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>if StopLabel.Enabled then <DD>StopImage.Left:=-150 <DD>end;<P></P><DD>procedure StopMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>StopImage.Left:=-60 <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ExtractTemporaryFile('MusicButton.bmp')<P></P><DD>PlayButton:=TPanel.Create(WizardForm) <DD>PlayButton.Left:=33 <DD>PlayButton.Top:=328 <DD>PlayButton.Width:=30 <DD>PlayButton.Height:=20 <DD>PlayButton.Cursor:=crHand <DD>PlayButton.ShowHint:=True <DD>PlayButton.Hint:='Воспроизведение музыки' <DD>PlayButton.OnClick:=@PlayButtonOnClick <DD>PlayButton.Parent:=WizardForm<P></P><DD>PlayImage:=TBitmapImage.Create(WizardForm) <DD>PlayImage.Left:=0 <DD>PlayImage.Top:=0 <DD>PlayImage.Width:=180 <DD>PlayImage.Height:=20 <DD>PlayImage.Enabled:=False <DD>PlayImage.Bitmap.LoadFromFile(ExpandConstant('{tmp}\MusicButton.bmp')) <DD>PlayImage.Parent:=PlayButton<P></P><DD>PlayLabel:=TLabel.Create(WizardForm) <DD>PlayLabel.Width:=PlayButton.Width <DD>PlayLabel.Height:=PlayButton.Height <DD>PlayLabel.Autosize:=False <DD>PlayLabel.Transparent:=True <DD>PlayLabel.OnClick:=@PlayButtonOnClick <DD>PlayLabel.OnMouseDown:=@PlayMouseDown <DD>PlayLabel.OnMouseUp:=@PlayMouseUp <DD>PlayLabel.Parent:=PlayButton<P></P><DD>PauseButton:=TPanel.Create(WizardForm) <DD>PauseButton.Left:=66 <DD>PauseButton.Top:=328 <DD>PauseButton.Width:=30 <DD>PauseButton.Height:=20 <DD>PauseButton.Cursor:=crHand <DD>PauseButton.ShowHint:=True <DD>PauseButton.Hint:='Приостановить музыку' <DD>PauseButton.OnClick:=@PauseButtonOnClick <DD>PauseButton.Parent:=WizardForm<P></P><DD>PauseImage:=TBitmapImage.Create(WizardForm) <DD>PauseImage.Left:=-30 <DD>PauseImage.Top:=0 <DD>PauseImage.Width:=180 <DD>PauseImage.Height:=20 <DD>PauseImage.Enabled:=False <DD>PauseImage.Bitmap.LoadFromFile(ExpandConstant('{tmp}\MusicButton.bmp')) <DD>PauseImage.Parent:=PauseButton<P></P><DD>PauseLabel:=TLabel.Create(WizardForm) <DD>PauseLabel.Width:=PauseButton.Width <DD>PauseLabel.Height:=PauseButton.Height <DD>PauseLabel.Autosize:=False <DD>PauseLabel.Transparent:=True <DD>PauseLabel.OnClick:=@PauseButtonOnClick <DD>PauseLabel.OnMouseDown:=@PauseMouseDown <DD>PauseLabel.OnMouseUp:=@PauseMouseUp <DD>PauseLabel.Parent:=PauseButton<P></P><DD>StopButton:=TPanel.Create(WizardForm) <DD>StopButton.Left:=99 <DD>StopButton.Top:=328 <DD>StopButton.Width:=30 <DD>StopButton.Height:=20 <DD>StopButton.Cursor:=crHand <DD>StopButton.ShowHint:=True <DD>StopButton.Hint:='Остановить музыку' <DD>StopButton.OnClick:=@StopButtonOnClick <DD>StopButton.Parent:=WizardForm<P></P><DD>StopImage:=TBitmapImage.Create(WizardForm) <DD>StopImage.Left:=-60 <DD>StopImage.Top:=0 <DD>StopImage.Width:=180 <DD>StopImage.Height:=20 <DD>StopImage.Enabled:=False <DD>StopImage.Bitmap.LoadFromFile(ExpandConstant('{tmp}\MusicButton.bmp')) <DD>StopImage.Parent:=StopButton<P></P><DD>StopLabel:=TLabel.Create(WizardForm) <DD>StopLabel.Width:=StopButton.Width <DD>StopLabel.Height:=StopButton.Height <DD>StopLabel.Autosize:=False <DD>StopLabel.Transparent:=True <DD>StopLabel.OnClick:=@StopButtonOnClick <DD>StopLabel.OnMouseDown:=@StopMouseDown <DD>StopLabel.OnMouseUp:=@StopMouseUp <DD>StopLabel.Parent:=StopButton <DD>end;</DD><TR><TD>Код для скина Slate с кнопками управления музыкой в формате MP3</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program 1.5 <DD>AppPublisher=My Company, Inc. <DD>DefaultDirName=C:\example<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: BASS.dll; DestDir: " {tmp} "; Flags: dontcopy noencryption <DD>Source: music.mp3; DestDir: "{tmp}"; Flags: dontcopy noencryption nocompression<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>BASS_ACTIVE_STOPPED = 0; <DD>BASS_ACTIVE_PLAYING = 1; <DD>BASS_ACTIVE_STALLED = 2; <DD>BASS_ACTIVE_PAUSED = 3; <DD>BASS_SAMPLE_LOOP = 4;<P></P><DD>var <DD>mp3Handle: HWND; <DD>mp3Name: string;<P></P><DD>function BASS_Init(device: Integer; freq, flags: DWORD; win: hwnd; CLSID: Integer): Boolean; <DD>external 'BASS_Init@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_StreamCreateFile(mem: BOOL; f: PChar; offset: DWORD; length: DWORD; flags: DWORD): DWORD; <DD>external 'BASS_StreamCreateFile@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Start(): Boolean; <DD>external 'BASS_Start@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelPlay(handle: DWORD; restart: BOOL): Boolean; <DD>external 'BASS_ChannelPlay@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelIsActive(handle: DWORD): Integer; <DD>external 'BASS_ChannelIsActive@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_ChannelPause(handle: DWORD): Boolean; <DD>external 'BASS_ChannelPause@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Stop(): Boolean; <DD>external 'BASS_Stop@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Pause(): Boolean; <DD>external 'BASS_Pause@files:BASS.dll stdcall delayload';<P></P><DD>function BASS_Free(): Boolean; <DD>external 'BASS_Free@files:BASS.dll stdcall delayload';<P></P><DD>function InitializeSetup(): Boolean; <DD>begin <DD>ExtractTemporaryFile('BASS.dll'); <DD>ExtractTemporaryFile('music.mp3'); <DD>mp3Name := ExpandConstant('{tmp}\music.mp3'); <DD>mp3Handle := BASS_StreamCreateFile(FALSE, PChar(mp3Name), 0, 0, BASS_SAMPLE_LOOP); <DD>Result := True; <DD>end;<P></P><DD>procedure PlayButtonOnClick(Sender: TObject); <DD>begin <DD>case BASS_ChannelIsActive(mp3Handle) of <DD>BASS_ACTIVE_PAUSED: <DD>begin <DD>BASS_ChannelPlay(mp3Handle, False); <DD>end; <DD>BASS_ACTIVE_STOPPED: <DD>begin <DD>BASS_Init(-1, 44100, 0, 0, 0); <DD>mp3Handle := BASS_StreamCreateFile(FALSE, PChar(mp3Name), 0, 0, BASS_SAMPLE_LOOP); <DD>BASS_Start(); <DD>BASS_ChannelPlay(mp3Handle, False); <DD>end; <DD>end; <DD>end;<P></P><DD>procedure PauseButtonOnClick(Sender: TObject); <DD>begin <DD>BASS_ChannelPause(mp3Handle); <DD>end;<P></P><DD>procedure StopButtonOnClick(Sender: TObject); <DD>begin <DD>BASS_Stop(); <DD>BASS_Free(); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>var <DD>Name: string; <DD>PlayButton, PauseButton, StopButton: TButton; <DD>Text: TNewStaticText; <DD>Panel: TPanel; <DD>begin <DD>WizardForm.Position := poScreenCenter; <DD>WizardForm.CancelButton.BringToFront; <DD>begin <DD>Panel := TPanel.Create(WizardForm); <DD>with Panel do <DD>begin <DD>Parent := WizardForm; <DD>Left := ScaleX(1); <DD>Top := ScaleY(315); <DD>Width := ScaleX(165); <DD>Height := ScaleY(46); <DD>TabOrder := 0; <DD>Color := clWhite; <DD>BevelInner := bvLowered; <DD>BevelOuter := bvRaised; <DD>BorderStyle := bsSingle; <DD>end <DD>PlayButton := TButton.Create(WizardForm); <DD>with PlayButton do <DD>begin <DD>Left := 5; <DD>Top := 335; <DD>Width := 50; <DD>Height := 20; <DD>Caption := 'Play'; <DD>OnClick := @PlayButtonOnClick; <DD>Parent := WizardForm; <DD>Cursor := crHand; <DD>ShowHint := True; <DD>Hint := '<FONT color=green>&amp;#194;&amp;#238;&amp;#241;&amp;#239;&amp;#240;&amp;#238;&amp;#232;&amp;#231;&amp;#226;&amp;#229;&amp;#228;&amp;#229;&amp;#237; &amp;#232;&amp;#229; &amp;#236;&amp;#243;&amp;#231;&amp;#251;&amp;#234;&amp;#232;</FONT>'; <DD>end <DD>PauseButton := TButton.Create(WizardForm); <DD>with PauseButton do <DD>begin <DD>Left := 58; <DD>Top := 335; <DD>Width := 50; <DD>Height := 20; <DD>Caption := 'Pause'; <DD>OnClick := @PauseButtonOnClick; <DD>Parent := WizardForm; <DD>Cursor := crHand; <DD>ShowHint := True; <DD>Hint := '<FONT color=green>&amp;#207;&amp;#240;&amp;#232;&amp;#238;&amp;#241;&amp;#242;&amp;#224;&amp;#237;&amp;#238;&amp;#226;&amp;#232;&amp;#242;&amp;#252; &amp;#236;&amp;#243;&amp;#231;&amp;#251;&amp;#234;&amp;#243;</FONT>'; <DD>end <DD>StopButton := TButton.Create(WizardForm); <DD>with StopButton do <DD>begin <DD>Left := 111; <DD>Top := 335; <DD>Width := 50; <DD>Height := 20; <DD>Caption := 'Stop'; <DD>OnClick := @StopButtonOnClick; <DD>Parent := WizardForm; <DD>Cursor := crHand; <DD>ShowHint := True; <DD>Hint := '<FONT color=green>&amp;#206;&amp;#241;&amp;#242;&amp;#224;&amp;#237;&amp;#238;&amp;#226;&amp;#232;&amp;#242;&amp;#252; &amp;#236;&amp;#243;&amp;#231;&amp;#251;&amp;#234;&amp;#243;</FONT>'; <DD>end<P></P><DD>Text := TNewStaticText.Create(WizardForm); <DD>with Text do <DD>begin <DD>Caption := 'Music Box'; <DD>Parent := WizardForm; <DD>Font.Style := Text.Font.Style + [fsUnderline]; <DD>Font.Color := clNavy; <DD>Top := 319; <DD>Left := 57; <DD>Color := clWhite; <DD>end <DD>end; <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>begin <DD>BASS_Stop(); <DD>BASS_Free(); <DD>end;</DD><TR><TD>Как музыку на задний план поставить?</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: Sound.mp3; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>function mciSendString(lpstrCommand: string; lpstrReturnString: string; uReturnLength:integer; hwndCallback:integer):integer; <DD>external 'mciSendStringA@winmm.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ExtractTemporaryFile(ExpandConstant('Sound.mp3')) <DD>mciSendString(ExpandConstant('play {tmp}\Sound.mp3 repeat'),'NULL',0,0) <DD>end;</DD><TR><TD>Запуск инсталла из командной строки, чтобы было без музыки</TD><TD>Запусти инсталл с параметром <B>/NoMusic=1</B> и музыки не будет!<TR><TD>Пример, когда картинка из BMP и слайд-шоу из JPG и с параметром WindowVisible=no и они подгоняются под любой размер экрана.</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>WindowVisible=no<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "x:\License.rtf"; DestDir: {tmp}; Flags: dontcopy noencryption <DD>Source: "other_files"; DestDir: {tmp};<P></P><DD>Source: C:\1.jpg; DestDir: {tmp}; Flags: dontcopy <DD>Source: C:\2.jpg; DestDir: {tmp}; Flags: dontcopy <DD>Source: C:\3.jpg; DestDir: {tmp}; Flags: dontcopy <DD>Source: C:\4.jpg; DestDir: {tmp}; Flags: dontcopy <DD>Source: C:\Fon.bmp; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>BACKGROUND = 6; <FONT color=green>// "5"-по центру, "6"-растянуто на весь экран, "1,2,3,4"-в разных углах экрана</FONT> <DD>TIMER = 16; <DD>function isxbb_AddImage(Image: PChar; Flags: Cardinal): Integer; <DD>external 'isxbb_AddImage@files:isxbb.dll stdcall'; <DD>function isxbb_Init(hWnd: Integer): Integer; <DD>external 'isxbb_Init@files:isxbb.dll stdcall'; <DD>function isxbb_StartTimer(Seconds: Integer; Flags: Cardinal): Integer; <DD>external 'isxbb_StartTimer@files:isxbb.dll stdcall'; <DD>function isxbb_KillTimer(Flags: Cardinal): Integer; <DD>external 'isxbb_KillTimer@files:isxbb.dll stdcall'; <DD>function GetSystemMetrics(nIndex: Integer): Integer; <DD>external 'GetSystemMetrics@user32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>BackgroundBitmapImage: TBitmapImage; <DD>s: string; <DD>License: string; <DD>width, height: Integer; <DD>begin <DD><FONT color=green>{********************Для корректного отображения заголовков**********}</FONT> <DD>WizardForm.Position := poScreenCenter; <DD><FONT color=green>{********************Для корректного отображения заголовков**********}</FONT> <DD>MainForm.BORDERSTYLE := bsNone; <DD><FONT color=green>{********************Для корректного отображения rtf файлов**********}</FONT> <DD>ExtractTemporaryFile('License.rtf'); <DD>LoadStringFromFile(ExpandConstant('{tmp}') + '\License.rtf', License) <DD>WizardForm.LicenseMemo.RTFText := License; <DD><FONT color=green>{********************Для корректного отображения rtf файлов**********}</FONT><P></P><DD>width := GetSystemMetrics(0); <DD>height := GetSystemMetrics(1); <DD>MainForm.Width := width; <DD>MainForm.Height := height; <DD>width := MainForm.ClientWidth; <DD>height := MainForm.ClientHeight; <DD>ExtractTemporaryFile('Fon.bmp'); <DD>s := ExpandConstant('{tmp}') + '\Fon.bmp'; <DD>BackgroundBitmapImage := TBitmapImage.Create(MainForm); <DD>BackgroundBitmapImage.Bitmap.LoadFromFile(s); <DD>BackgroundBitmapImage.Left := 0; <DD>BackgroundBitmapImage.Top := 0; <DD>BackgroundBitmapImage.Width := width; <DD>BackgroundBitmapImage.Height := height; <DD>BackgroundBitmapImage.Parent := MainForm; <DD>BackgroundBitmapImage.Stretch := True; <DD>MainForm.Visible := True; <DD>end;<P></P><DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>begin <DD>if CurStep = ssInstall <DD>then <DD>begin <DD>ExtractTemporaryFile('1.jpg'); <FONT color=green>//это файлы для слайд-шоу, их может быть и больше</FONT> <DD>ExtractTemporaryFile('2.jpg'); <DD>ExtractTemporaryFile('3.jpg'); <DD>isxbb_AddImage(ExpandConstant('{tmp}') + '\1.jpg', BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}') + '\2.jpg', BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}') + '\3.jpg', BACKGROUND or TIMER); <DD>isxbb_Init(StrToInt(ExpandConstant('{hwnd}'))); <DD>isxbb_StartTimer(3, BACKGROUND) <FONT color=green>//это таймер для слайд-шоу в секундах</FONT> <DD>end <DD>else if CurStep = ssPostInstall then <DD>isxbb_KillTimer(BACKGROUND); <DD>end;</DD><TR><TD>А больше 10 секунд слайд можно сделать? <DD>const <DD>BACKGROUND = 5; <DD>TIMER = 21; <DT>Как ни ставлю, один фиг, 10 секунд показывает картинку!</DT></TD><TD>Таймер выставляй в этой строке: <DD>isxbb_StartTimer(10,BackGround) <DT>или замени эту строку на эту: <DD>isxbb_StartTimer(TIMER,BackGround) <DT>и выставляй в константе.</DT><TR><TD>Как сделать, чтобы были свои картинки (отображаются с левой стороны инсталлятора и справа вверху)?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>WizardImageFile=C:\картинка.bmp 164x314 <DD>WizardSmallImageFile=C:\картинка.bmp 55x55</DD><TR><TD>Можно ли сделать, чтобы синего фона, на который ложится My_Image.bmp, вообще не было видно?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DefaultGroupName=My Program <DD>UninstallDisplayIcon={app}\MyProg.exe <DD>WindowVisible=No<P></P><DD><FONT color=red>[Types]</FONT> <DD>Name: "full"; Description: "Full installation" <DD>Name: "compact"; Description: "Compact installation" <DD>Name: "custom"; Description: "Custom installation"; Flags: iscustom<P></P><DD><FONT color=red>[Components]</FONT> <DD>Name: "program"; Description: "Program Files"; Types: full compact custom; Flags: fixed <DD>Name: "help"; Description: "Help File"; Types: full <DD>Name: "readme"; Description: "Readme File"; Types: full <DD>Name: "readme\en"; Description: "English"; Flags: exclusive <DD>Name: "readme\de"; Description: "German"; Flags: exclusive<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "MyProg.exe"; DestDir: "{app}"; Components: program <DD>Source: "MyProg.chm"; DestDir: "{app}"; Components: help <DD>Source: "Readme.txt"; DestDir: "{app}"; Components: readme\en; Flags: isreadme <DD>Source: "Readme-German.txt"; DestName: "Liesmich.txt"; DestDir: "{app}"; Components: readme\de; Flags: isreadme<P></P><DD><FONT color=red>[Icons]</FONT> <DD>Name: "{group}\My Program"; Filename: "{app}\MyProg.exe"<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Form: TForm;<P></P><DD>function ShowWindow(hWnd: LongWord; nCmdShow: LongWord): LongWord; <DD>external 'ShowWindow@user32.dll stdcall';<P></P><DD>procedure FormOnActivate(Sender: TObject); <DD>begin <DD>WizardForm.Show; <DD>end;<P></P><DD>function InitializeSetup(): Boolean; <DD>begin <DD>Form := CreateCustomForm(); <DD>Form.BorderStyle:= bsNone; <DD>Form.Color:= clGreen; <DD>ShowWindow(Form.Handle, SW_SHOWMAXIMIZED);<P></P><DD>Result:= True; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>Form.OnActivate:= @FormOnActivate; <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>begin <DD>Form.Free; <DD>end;</DD><TR><TD>Возможно ли как-нибудь сделать фон из JPG картинки и смену JPG картинок во время установки БЕЗ WindowVisible=yes и синей формы с названием проги?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>WindowVisible=yes <DD>WindowShowCaption=no <DD>BackColor=$000000<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: C:\isxbb.dll; DestDir: {tmp}; Flags: dontcopy <DD>Source: C:\1.jpg; DestDir: {tmp}; Flags: dontcopy <DD>Source: C:\2.jpg; DestDir: {tmp}; Flags: dontcopy <DD>Source: C:\3.jpg; DestDir: {tmp}; Flags: dontcopy <DD>Source: C:\4.jpg; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>BACKGROUND=5; <FONT color=green>// "5"-по центру, "6"-растянуто на весь экран, "1,2,3,4"-в разных углах экрана</FONT> <DD>TIMER=16;<P></P><DD>function isxbb_AddImage(Image: PChar; Flags: Cardinal): Integer; <DD>external 'isxbb_AddImage@files:isxbb.dll stdcall'; <DD>function isxbb_Init(hWnd: Integer): Integer; <DD>external 'isxbb_Init@files:isxbb.dll stdcall'; <DD>function isxbb_StartTimer(Seconds: Integer; Flags: Cardinal): Integer; <DD>external 'isxbb_StartTimer@files:isxbb.dll stdcall'; <DD>function isxbb_KillTimer(Flags: Cardinal): Integer; <DD>external 'isxbb_KillTimer@files:isxbb.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ExtractTemporaryFile('1.jpg'); <FONT color=green>//1.jpg-это фоновый рисунок, он показывается как в начале, так и в конце установки</FONT> <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\1.jpg',BACKGROUND); <DD>isxbb_Init(StrToInt(ExpandConstant('{hwnd}'))); <DD>end; <DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>begin <DD>if CurStep=ssInstall <DD>then <DD>begin <DD>ExtractTemporaryFile('2.jpg'); <FONT color=green>//это файлы для слайд-шоу, их может быть и больше</FONT> <DD>ExtractTemporaryFile('3.jpg'); <DD>ExtractTemporaryFile('4.jpg'); <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\2.jpg',BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\3.jpg',BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\4.jpg',BACKGROUND or TIMER); <DD>isxbb_Init(StrToInt(ExpandConstant('{hwnd}'))); <DD>isxbb_StartTimer(3,BACKGROUND) <FONT color=green>//это таймер для слайд-шоу в секундах</FONT> <DD>end <DD>else if CurStep=ssPostInstall then <DD>isxbb_KillTimer(BACKGROUND); <DD>end;</DD><TR><TD>А возможно ли сделать без WindowVisible=yes, но cо значением WindowVisible=no?</TD><TD>Вот пример - фон из .BMP, а слайд-шоу из .JPG: <DD><FONT color=red>[Setup]</FONT> <DD>WindowVisible=no<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "x:\License.rtf"; DestDir: {tmp}; Flags: dontcopy noencryption<P></P><DD><FONT color=red>[Code]</FONT><P></P><DD>const <DD>BACKGROUND = 6; <FONT color=green>//"5"-по центру, "6"-растянуто на весь экран, "1,2,3,4"-в разных углах экрана</FONT> <DD>TIMER = 16;<P></P><DD>function isxbb_AddImage(Image: PChar; Flags: Cardinal): Integer; <DD>external 'isxbb_AddImage@files:isxbb.dll stdcall'; <DD>function isxbb_Init(hWnd: Integer): Integer; <DD>external 'isxbb_Init@files:isxbb.dll stdcall'; <DD>function isxbb_StartTimer(Seconds: Integer; Flags: Cardinal): Integer; <DD>external 'isxbb_StartTimer@files:isxbb.dll stdcall'; <DD>function isxbb_KillTimer(Flags: Cardinal): Integer; <DD>external 'isxbb_KillTimer@files:isxbb.dll stdcall'; <DD>function GetSystemMetrics(nIndex: Integer): Integer; <DD>external 'GetSystemMetrics@user32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>BackgroundBitmapImage: TBitmapImage; <DD>s: string; <DD>License: string; <DD>width, height: Integer; <DD>begin <DD><FONT color=green>{********************Для корректного отображения заголовков**********}</FONT> <DD>WizardForm.Position := poScreenCenter; <DD><FONT color=green>{********************Для корректного отображения заголовков**********}</FONT> <DD>MainForm.BORDERSTYLE := bsNone; <DD><FONT color=green>{********************Для корректного отображения rtf файлов**********}</FONT> <DD>ExtractTemporaryFile('License.rtf'); <DD>LoadStringFromFile(ExpandConstant('{tmp}') + '\License.rtf', License) <DD>WizardForm.LicenseMemo.RTFText := License; <DD><FONT color=green>{********************Для корректного отображения rtf файлов**********}</FONT><P></P><DD>width := GetSystemMetrics(0); <DD>height := GetSystemMetrics(1); <DD>MainForm.Width := width; <DD>MainForm.Height := height; <DD>width := MainForm.ClientWidth; <DD>height := MainForm.ClientHeight; <DD>ExtractTemporaryFile('Fon.bmp'); <DD>s := ExpandConstant('{tmp}') + '\Fon.bmp'; <DD>BackgroundBitmapImage := TBitmapImage.Create(MainForm); <DD>BackgroundBitmapImage.Bitmap.LoadFromFile(s); <DD>BackgroundBitmapImage.Left := 0; <DD>BackgroundBitmapImage.Top := 0; <DD>BackgroundBitmapImage.Width := width; <DD>BackgroundBitmapImage.Height := height; <DD>BackgroundBitmapImage.Parent := MainForm; <DD>BackgroundBitmapImage.Stretch := True; <DD>MainForm.Visible := True; <DD>end;<P></P><DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>begin <DD>if CurStep = ssInstall <DD>then <DD>begin <DD>ExtractTemporaryFile('1.jpg'); <FONT color=green>//это файлы для слайд-шоу, их может быть и больше</FONT> <DD>ExtractTemporaryFile('2.jpg'); <DD>ExtractTemporaryFile('3.jpg'); <DD>isxbb_AddImage(ExpandConstant('{tmp}') + '\1.jpg', BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}') + '\2.jpg', BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}') + '\3.jpg', BACKGROUND or TIMER); <DD>isxbb_Init(StrToInt(ExpandConstant('{hwnd}'))); <DD>isxbb_StartTimer(3, BACKGROUND) <FONT color=green>//это таймер для слайд-шоу в секундах</FONT> <DD>end <DD>else if CurStep = ssPostInstall then <DD>isxbb_KillTimer(BACKGROUND); <DD>end;</DD><TR><TD>Код, где на фоновом окне в зависимости от разрешения экрана отображается картинка соответствующего размера</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\AppName<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: 640.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: 800.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: 1024.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: 1152.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: 1280.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: 1600.bmp; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>function GetDC(HWND: DWord): DWord; <DD>external 'GetDC@user32.dll stdcall';<P></P><DD>function GetDeviceCaps(DC: DWord; Index: Integer): Integer; <DD>external 'GetDeviceCaps@gdi32.dll stdcall';<P></P><DD>function ReleaseDC(HWND: DWord;DC: DWord): Integer; <DD>external 'ReleaseDC@user32.dll stdcall';<P></P><DD>function ShowWindow(hWnd: DWord; nCmdShow: Integer): boolean; <DD>external 'ShowWindow@user32.dll stdcall';<P></P><DD>function SetWindowLong(hWnd: DWord; nIndex: Integer; dwNewLong: Longint): Longint; <DD>external 'SetWindowLongA@user32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>bgImage : TBitmapImage; <DD>bgImageName: String; <DD>width: integer; <DD>dc: DWord;<P></P><DD>begin <DD>bgImage:=TBitmapImage.Create(MainForm) <DD>bgImage.Align:=alClient <DD>bgImage.Stretch:=True <DD>bgImage.Parent:=MainForm<P></P><DD>dc:=GetDC(MainForm.Handle) <DD>width:=GetDeviceCaps(dc,8) <DD>ReleaseDC(MainForm.Handle,dc)<P></P><DD>if width &lt;=640 then <DD>bgImageName:='640.bmp'<P></P><DD>else if width&lt;=800 then <DD>bgImageName:='800.bmp'<P></P><DD>else if width&lt;=1024 then <DD>bgImageName:='1024.bmp'<P></P><DD>else if width&lt;=1152 then <DD>bgImageName:='1152.bmp'<P></P><DD>else if width&lt;=1280 then <DD>bgImageName:='1280.bmp'<P></P><DD>else <DD>bgImageName:='1600.bmp'<P></P><DD>ExtractTemporaryFile(bgImageName) <DD>bgImage.bitmap.LoadFromFile(expandConstant('{tmp}\'+bgImageName))<P></P><DD>SetWindowLong(MainForm.Handle,-16,$80000000) <DD>ShowWindow(Mainform.Handle,SW_SHOWMAXIMIZED) <DD>end;</DD><TR><TD>Пример растягивания одной и той же картинки на страницах Приветствия и Завершения:</TD><TD><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>var <DD>Page: TWizardPage; <DD>begin <DD>WizardForm.WizardBitmapImage.Left := 333; <FONT color=green>//Страница Приветствия</FONT> <DD>WizardForm.WelcomeLabel1.Left := 20; <DD>WizardForm.WelcomeLabel2.Left := 20; <DD>WizardForm.WizardBitmapImage2.Left := 333; <FONT color=green>//Страница Завершения</FONT> <DD>WizardForm.FinishedLabel.Left := 20; <DD>WizardForm.FinishedHeadingLabel.Left := 20; <DD>WizardForm.RunList.Left := 20; <DD>WizardForm.YesRadio.Left := 20; <DD>WizardForm.NoRadio.Left := 20; <DD>end;</DD><TR><TD>Пример использования двух разных картинок на страницах Приветствия и Завершения, тоже растянутых:</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: C:\BitmapImage2.bmp; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>var b:string; <DD>begin <DD>ExtractTemporaryFile('BitmapImage2.bmp') <DD>b:=ExpandConstant('{tmp}\BitmapImage2.bmp') <DD>with WizardForm do <DD>begin <DD>WizardBitmapImage.Width:=WizardForm.ClientWidth; <DD>WelcomeLabel1.Visible:=False; <DD>WelcomeLabel2.Visible:=False; <DD>WizardBitmapImage2.Bitmap.LoadFromFile(b); <DD>WizardBitmapImage2.Width:=WizardForm.ClientWidth; <DD>FinishedLabel.Visible:=False; <DD>FinishedHeadingLabel.Visible:=False; <DD>end; <DD>end;</DD><TR><TD>Возможно ли: <DT>1.Чтобы в одном инсталляторе можно было использовать 2 разных WizardImageFile для страниц Приветствия и Завершения. <DT>2.Растянуть 2 разных WizardImageFile на страницах Приветствия и Завершения на всю форму.</DT></TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>WizardImageFile=C:\Image1.bmp<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: C:\Image2.bmp; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Image2: TBitmapImage;<P></P><DD>procedure InitializeWizard(); <DD>var <DD>Page: TWizardPage; <DD>begin <DD>ExtractTemporaryFile('Image2.bmp') <DD>WizardForm.WizardBitmapImage.Width:=497 <DD>WizardForm.WelcomeLabel1.Visible:=False <DD>WizardForm.WelcomeLabel2.Visible:=False <DD>WizardForm.WizardBitmapImage2.Visible:=False <DD>WizardForm.FinishedLabel.Visible:=False <DD>WizardForm.FinishedHeadingLabel.Visible:=False <DD>end;<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>If CurPageID=wpFinished then <DD>begin <DD>Image2:=TBitmapImage.Create(WizardForm) <DD>with Image2 do begin <DD>Left:=0 <DD>Top:=0 <DD>Width:=497 <DD>Height:=313 <DD>Parent:=WizardForm.FinishedPage <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}')+'\Image2.bmp') <DD>end <DD>end <DD>end;</DD><TR><TD>Как сделать, чтобы картинка не растягивалась, а находилась по центру?</TD><TD>Во-первых, убрать растягивание, надо False, а не True: <DD>BackgroundBitmapImage.Stretch:=False; <DT>...А во-вторых, выставить по центру <DD>BackgroundBitmapImage.Center:= True;</DD><TR><TD>Как сделать, чтобы когда идет установка, то была не просто табличка, а во весь экран разворачивался инсталлятор, например, с картинкой той или иной проги?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>WindowVisible=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: C:\BackImage.bmp; DestDir: {tmp}; Flags: dontcopy;<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>var <DD>BackImage: TBitmapImage; <DD>s:string; <DD>begin <DD>ExtractTemporaryFile('BackImage.bmp') <DD>s:=ExpandConstant('{tmp}')+'\BackImage.bmp' <DD>BackImage:=TBitmapImage.Create(MainForm) <DD>BackImage.Bitmap.LoadFromFile(s) <DD>BackImage.Align:=alClient <DD>BackImage.Parent:=MainForm <DD>BackImage.Stretch:=True <DD>end;</DD><TR><TD>Как сделать, чтобы в слайд-шоу картинка не растягивалась, а была строго по центру?</TD><TD><DD>Image1.Align:= alClient; <DD>Image1.AutoSize:= True; <DD>Image1.Center:= True; <DD>Image1.Stretch:= False;</DD><TR><TD>Я вместо сплэш-заставки использую видеоролик, и мне нужно, чтобы он отключался примерно на секунду раньше от его полной длины, чтобы не было видно ненужного текста-титров в конце видеоролика.</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: Video.exe; DestDir: {tmp}; Flags: dontcopy <DD>Source: ISTask.dll; Destdir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>function KillTask(ExeFileName: string): Integer; <DD>external 'KillTask@files:ISTask.dll stdcall delayload';<P></P><DD>procedure initializeWizard(); <DD>var <DD>Res:Integer; <DD>begin <DD>WizardForm.Hide; <DD>ExtractTemporaryFile('Video.exe'); <DD>Exec(ExpandConstant('{tmp}\Video.exe'),'','',SW_SHOW,ewNoWait,Res); <DD>Sleep(5300); <DD>KillTask('Video.exe') <DD>WizardForm.Show; <DD>end;</DD><TR><TD>Изменение размера страницы с индикатором выполнения установки</TD><TD>Изменение размера страницы с индикатором выполнения установки с последующим перемещением ее в угол экрана (например, это имеет значение в игровом инсталляторе, когда вставлено фоновое изображение, и мы хотим видеть основное его содержимое полным и заодно наблюдать за ходом установки).<P><DD>procedure InitializeWizard(); <DD>begin <DT><FONT color=green>//Выносим кнопку "Отмена" на передний план</FONT> <DD>WizardForm.CancelButton.BringToFront; <DD>end;<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>if CurPageID=wpInstalling <DD>then <DD>begin <DD>WizardForm.MainPanel.Visible:=False; <DD>WizardForm.Bevel1.Visible:=False; <DD>WizardForm.Width:=ScaleX(395); <DD>WizardForm.Height:=ScaleY(142); <DT><FONT color=green>//Здесь смещение страницы установки (в верхний левый угол)</FONT> <DD>WizardForm.Left:=ScaleX(0); <DD>WizardForm.Top:=ScaleY(0); <DT><FONT color=green>{Внимание! Нижеописанные способы смещения работают, только когда вставлено фоновое изображение или WindowVisible=yes}</FONT> <DT><FONT color=green>{Выводит в правом верхнем углу экрана}</FONT> <DT><DD><FONT color=green>//WizardForm.Left:=ScaleX(MainForm.Width-420);</FONT> <DT><DD><FONT color=green>//WizardForm.Top:=ScaleY(MainForm.Left+20);</FONT> <DT><FONT color=green>{Выводит снизу по центру экрана}</FONT> <DT><DD><FONT color=green>//WizardForm.Position:=poScreenCenter;</FONT> <DT><DD><FONT color=green>//WizardForm.Top:=ScaleY(MainForm.Height-170);</FONT> <DT><FONT color=green>{Выводит в нижнем левом углу (как в Doom 3 Resurrection of Evil от 1C)}</FONT> <DT><DD><FONT color=green>//WizardForm.Left:=ScaleX(MainForm.Left+20);</FONT> <DT><DD><FONT color=green>//WizardForm.Top:=ScaleY(MainForm.Height-170);</FONT> <DT><FONT color=green>{Выводит в нижнем правом углу}</FONT> <DT><DD><FONT color=green>//WizardForm.Left:=ScaleX(MainForm.Width-420);</FONT> <DT><DD><FONT color=green>//WizardForm.Top:=ScaleY(MainForm.Height-170);</FONT><P></P><DD>WizardForm.InnerNotebook.Left:=ScaleX(10); <DD>WizardForm.InnerNotebook.Top:=ScaleY(10); <DD>WizardForm.InnerNotebook.Width:=ScaleX(370); <DD>WizardForm.StatusLabel.Left:=ScaleX(0); <DD>WizardForm.StatusLabel.Top:=ScaleY(0); <DD>WizardForm.StatusLabel.Width:=WizardForm.InnerNotebook.Width; <DD>WizardForm.FileNameLabel.Left:=ScaleX(0); <DD>WizardForm.FileNameLabel.Top:=ScaleY(20); <DD>WizardForm.FileNameLabel.Width:=WizardForm.InnerNotebook.Width; <DD>WizardForm.ProgressGauge.Top:=ScaleY(40); <DD>WizardForm.ProgressGauge.Width:=WizardForm.InnerNotebook.Width; <DD>WizardForm.CancelButton.Left:=ScaleX(154); <DD>WizardForm.CancelButton.Top:=ScaleY(80); <DD>end <DD>if CurPageID=wpFinished <DD>then <DD>begin <DD>WizardForm.Width:=502; <FONT color=green>{Размер окна по горизонтали}</FONT> <DD>WizardForm.Height:=392; <FONT color=green>{Размер окна по вертикали}</FONT> <DD>WizardForm.Position:=poScreenCenter; <FONT color=green>{Возврат в исходное состояние}</FONT> <DD>end <DD>end;</DD><TR><TD>Как изменить размер окна инсталлятора? Хотелось бы его побольше сделать...</TD><TD><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.Width:=640; <DD>WizardForm.Height:=480; <DD>end;<P></P><DT>Но это лучше переделывать в файле Setup.e32</DT><TR><TD>Вот интересная реализация рисунка в верхней панели окна мастера:</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>WizardSmallImageFile=C:\SmallImage.bmp<P></P><DT><FONT color=green>;Здесь использован рисунок с размерами 497х58</FONT> <DD><FONT color=red>[Сode]</FONT> <DD>procedure InitializeWizard(); <DD>begin <DD>with WizardForm do begin <DD>with MainPanel do <DD>Height := Height - 1; <DD>with WizardSmallBitmapImage do begin <DD>Left := 0; <DD>Top := 0; <DD>Height := 58; <FONT color=green>//Размер рисунка</FONT> <DD>Width := 497; <FONT color=green>//</FONT> <DD>end; <DD>with PageNameLabel do begin <DD>Width := Width - 497; <FONT color=green>//Поставьте здесь значения на 0, если хотите вернуть текст</FONT> <DD>Left := Left + 497; <FONT color=green>//</FONT> <DD>end; <DD>with PageDescriptionLabel do begin <DD>Width := Width - 497; <FONT color=green>//Поставьте здесь значения на 0, если хотите вернуть текст</FONT> <DD>Left := Left + 497; <FONT color=green>//</FONT> <DD>end; <DD>end; <DD>end;</DD><TR><TD>Как увеличить размер второго маленького изображения инсталлятора (WizardSmallImage 55*55)? Хочется пошире вставить картинку...</TD><TD><DD>procedure InitializeWizard(); <DD>begin <DD>with WizardForm do <DD>begin <DD>WizardSmallBitmapImage.Left:=WizardForm.WizardSmallBitmapImage.Left-120 <DD>WizardSmallBitmapImage.Width:=177 <DD>PageNameLabel.Width:=290 <DD>PageDescriptionLabel.Width:=280 <DD>end <DD>end;</DD><TR><TD>Помогите с кодом, чтобы сделать маленькую страницу с прогресс-баром в правом нижнем углу экрана, типа "Подготовка к установке", как в InstallShield, которая появляется перед страницей приветствия на 5-7 секунд</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes <DD>WindowVisible=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; Flags: ignoreversion<P></P><DD><FONT color=red>[Code]</FONT> <DD>function GetSystemMetrics(nIndex:Integer):Integer; <DD>external 'GetSystemMetrics@user32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>Form: TSetupForm; <DD>ProgressBar: TNewProgressBar; <DD>i: Integer; <DD>begin <DD>Form := CreateCustomForm(); <DD>try <DD>with Form do <DD>begin <DD>ClientWidth := ScaleX(256); <DD>ClientHeight := ScaleY(16); <DD>BorderStyle:= bsNone; <DD>Left:= GetSystemMetrics(16) - ClientWidth - ScaleX(12); <DD>Top:= GetSystemMetrics(17) - ClientHeight - ScaleY(12); <DD>end; <DD>ProgressBar := TNewProgressBar.Create(Form); <DD>with ProgressBar do <DD>begin <DD>Left := ScaleX(8); <DD>Top := ScaleX(12); <DD>Width := Form.Width - (2 * Left); <DD>Height := Form.ClientHeight - (2 * Top); <DD>Parent := Form; <DD>Min:= 0; <DD>Max:= 30; <DD>Position := 0; <DD>end; <DD>Form.Show(); <DD>for i:= 0 to 30 do <DD>begin <DD>ProgressBar.Position:= i; <DD>Sleep(500); <DD>i:= i + 1; <DD>end; <DD>finally <DD>Form.Free(); <DD>end; <DD>end;</DD><TR><TD>Нельзя ли сделать, чтобы во время копирования временных файлов появлялся граббер или "табличка", т.е. чтобы этот процесс было видно?</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: .\Files\*; DestDir: "{tmp}"; BeforeInstall: HideInstallPath; AfterInstall: ShowInstallPath<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure HideInstallPath(); <DD>begin <DD>WizardForm.FileNameLabel.Visible := False; <DD>end; <DD><FONT color=green>//*******//</FONT> <DD>procedure ShowInstallPath(); <DD>begin <DD>WizardForm.FileNameLabel.Visible := True; <DD>end;</DD><TR><TD>Как задать выполнение нового прогресс-бара? Как заставить его двигаться и изменять скорость его движения?</TD><TD>Один из скриптов в примерах описывает выполнение новой страницы прогресса, а не прогресс-бара в отдельности. <DT>Делаем новую полосу прогресса: <DD><FONT color=red>[Code]</FONT> <DD>var <DD>ProgressBar: TNewProgressBar; <DD>procedure CurPageChanged(CurPageID: Integer); <DD>var <DD>i:Integer; <DD>begin <DD>If CurPageID=wpInstalling <DD>then <DD>begin <DD>ProgressBar := TNewProgressBar.Create(WizardForm); <DD>ProgressBar.Left := ScaleY(40); <DD>ProgressBar.Top := ScaleX(180); <DD>ProgressBar.Width := ScaleY(415); <DD>ProgressBar.Height := ScaleX(18); <DD>ProgressBar.Parent := WizardForm; <DD>ProgressBar.Position := 0; <FONT color=green>//указывает количество заполняемых секторов</FONT> <DD>end; <DD>begin <DD>If CurPageID=wpFinished <DD>then <DD>ProgressBar.Hide <DD>end; <DD>end;</DD><TR><TD>А возможно ли сделать так, чтобы в новом ProgressBar'e одновременно запускался ProgressBar и Splash.bmp?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes <DD>WindowVisible=no<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; Flags: ignoreversion <DD>Source: WizModernSmallImage.bmp; Flags: dontcopy <DD>Source: splash.bmp; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>function GetSystemMetrics(nIndex:Integer):Integer; <DD>external 'GetSystemMetrics@user32.dll stdcall';<P></P><DD>function InitializeSetup(): Boolean; <DD>var <DD>Form, Splash: TSetupForm; <DD>ProgressBar: TNewProgressBar; <DD>CancelButton: TButton; <DD>StaticText: TNewStaticText; <DD>BitmapImage, BitmapImage1: TBitmapImage; <DD>BitmapFileName: String; <DD>i: Integer; <DD>begin <DD>Form := CreateCustomForm(); <DD>try <DD>with Form do <DD>begin <DD>ClientWidth := ScaleX(380); <DD>ClientHeight := ScaleY(120); <DD>BorderStyle:= bsDialog; <DD>Left:= GetSystemMetrics(16) - ClientWidth - ScaleX(12); <DD>Top:= GetSystemMetrics(17) - ClientHeight - ScaleY(12); <DD>end;<P></P><DD>BitmapFileName := ExpandConstant('{tmp}\WizModernSmallImage.bmp'); <DD>ExtractTemporaryFile(ExtractFileName(BitmapFileName)); <DD>BitmapImage := TBitmapImage.Create(Form); <DD>BitmapImage.Left := ScaleX(8); <DD>BitmapImage.Top := ScaleY(8); <DD>BitmapImage.AutoSize := True; <DD>BitmapImage.Bitmap.LoadFromFile(BitmapFileName); <DD>BitmapImage.Parent := Form;<P></P><DD>StaticText := TNewStaticText.Create(Form); <DD>StaticText.Top := BitmapImage.Top; <DD>StaticText.Left := BitmapImage.Left + BitmapImage.Width + ScaleX(8) <DD>StaticText.Caption := 'Inno Setup is a free installer for Windows programs.' + #10#13 + 'Support for all versions of Windows in use today'; <DD>StaticText.AutoSize := True; <DD>StaticText.Parent := Form;<P></P><DD>CancelButton := TButton.Create(Form); <DD>CancelButton.Parent := Form; <DD>CancelButton.Width := ScaleX(75); <DD>CancelButton.Height := ScaleY(23); <DD>CancelButton.Left := Form.ClientWidth - ScaleX(75 + 10); <DD>CancelButton.Top := Form.ClientHeight - ScaleY(23 + 10); <DD>CancelButton.Caption := 'Cancel'; <DD>CancelButton.ModalResult := mrCancel; <DD>CancelButton.Cancel := True;<P></P><DD>ProgressBar := TNewProgressBar.Create(Form); <DD>with ProgressBar do <DD>begin <DD>Height := CancelButton.Height - ScaleY(8); <DD>Width := Form.Width - ScaleX(128); <DD>Top := CancelButton.Top; <DD>Left := BitmapImage.Left; <DD>Parent := Form; <DD>Min:= 0; <DD>Max:= 30; <DD>Position := 0; <DD>end;<P></P><DD>Form.ActiveControl := CancelButton; <DD>Form.Show();<P></P><DD>Splash := CreateCustomForm; <DD>Splash.BorderStyle := bsNone; <DD>BitmapImage1 := TBitmapImage.Create(Splash); <DD>with BitmapImage1 do begin <DD>AutoSize := True; <DD>Align := alClient; <DD>Left := 0; <DD>Top := 0; <DD>Stretch := True; <DD>Parent := Splash; <DD>end; <DD>ExtractTemporaryFile('Splash.bmp'); <DD>BitmapImage1.Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\Splash.bmp'); <DD>Splash.Width := BitmapImage1.Width; <DD>Splash.Height := BitmapImage1.Height; <DD>Splash.Center; <DD>Splash.Show; <DD>BitmapImage1.Refresh;<P></P><DD>for i:= 0 to 30 do <DD>begin <DD>ProgressBar.Position:= i; <DD>Form.Repaint; <DD>Sleep(500); <DD>i:= i + 1; <DD>end; <DD>finally <DD>Form.Free(); <DD>Splash.Free(); <DD>end; <DD>Result:= True; <DD>end;</DD><TR><TD>Если необходимо отображать проценты установки, нет необходимости высчитывать соотношения размеров файлов, так как данные процесса установки уже присутствуют (в WizardForm.ProgressGauge). Их надо только перевести в проценты. В итоге это может выглядеть примерно так:</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: setup.log; DestDir: {app}; AfterInstall: ExtLog() <DD>Source: Files\*; DestDir: {app}; AfterInstall: ExtLog()<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>ProgressLabel: TLabel;<P></P><DD>procedure ExtLog(); <DD>begin <DD>SaveStringToFile(ExpandConstant('{app}\setup.log'), #13#10 + GetDateTimeString('dd/mm/yyyy hh:nn:ss', '-', ':') + ' - ' + ExpandConstant(CurrentFileName), True); <DD>with WizardForm.ProgressGauge do <DD>ProgressLabel.Caption:= IntToStr((Position-Min)/((Max - Min)/100)) + '%'; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ProgressLabel := TLabel.Create(WizardForm); <DD>with WizardForm.ProgressGauge do <DD>begin <DD>ProgressLabel.Top := Top + Height + ScaleY(8); <DD>ProgressLabel.Left:= Left + Width/2 - ScaleX(8); <DD>ProgressLabel.Caption := 'TLabel'; <DD>ProgressLabel.AutoSize := True; <DD>ProgressLabel.Parent := WizardForm.InstallingPage; <DD>end; <DD>end;<P></P><DT>Правда, это можно назвать приемлемым только в случае, если инсталлируется большое кол-во мелких файлов. К сожалению, в Инно нет события изменения состояния прогресс-бара.</DT><TR><TD>Проценты установки во время инсталяции показываются, а можно ли при этом ещё показывать размер копируемого в данный момент файла?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app}; AfterInstall: Progress()<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>ProgressLabel, SizeLabel: TLabel;<P></P><DD>procedure Progress(); <DD>var <DD>size: integer;<P></P><DD>begin <DD>with WizardForm.ProgressGauge do <DD>ProgressLabel.Caption:= IntToStr((Position-Min)/((Max - Min)/100)) + '%';<P></P><DD>FileSize(ExpandConstant(CurrentFileName), size); <DD>SizeLabel.Caption:= IntToStr(size) + ' bytes'; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ProgressLabel := TLabel.Create(WizardForm); <DD>with WizardForm.ProgressGauge do <DD>begin <DD>ProgressLabel.Top := Top + Height + ScaleY(8); <DD>ProgressLabel.Left:= Left + Width/2 - ScaleX(8); <DD>ProgressLabel.AutoSize := True; <DD>ProgressLabel.Parent := WizardForm.InstallingPage; <DD>end;<P></P><DD>SizeLabel := TLabel.Create(WizardForm); <DD>with WizardForm.ProgressGauge do <DD>begin <DD>SizeLabel.Top := Top + Height + ScaleY(8); <DD>SizeLabel.Left:= Left; <DD>SizeLabel.AutoSize := True; <DD>SizeLabel.Parent := WizardForm.InstallingPage; <DD>end; <DD>end;</DD><TR><TD>Пример использования двух процедур:<P><DT>procedure ProgressChanged(percent: Integer); -- вызывается каждый раз, когда апдейтится прогресс-бар. percent содержит текущее значение прогресс-бара в процентах<P></P><DT>MainForm.SetBackImage(str: String); -- позволяет задать в качестве фона *.jpg. Если str содержит пустое значение, картинка убирается.</DT></TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DefaultGroupName=My Program <DD>UninstallDisplayIcon={app}\MyProg.exe <DD>Compression=lzma <DD>SolidCompression=yes <DD>WindowVisible=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; Flags: ignoreversion recursesubdirs <DD>Source: Files_ext\1.jpg; Flags: dontcopy <DD>Source: Files_ext\2.jpg; Flags: dontcopy <DD>Source: Files_ext\main.jpg; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>CurPicture: integer;<P></P><DD>function InitializeSetup(): Boolean; <DD>begin <DD>ExtractTemporaryFile('1.jpg'); <DD>ExtractTemporaryFile('2.jpg'); <DD>ExtractTemporaryFile('main.jpg'); <DD>Result:= True; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>MainForm.SetBackImage(ExpandConstant('{tmp}\main.jpg')); <DD>end;<P></P><DD>procedure ProgressChanged(percent: Integer); <DD>var <DD>str: string; <DD>begin <DD>if ((percent &gt; 0) and (percent &lt; 30) and (CurPicture &lt;&gt; 1)) then <DD>begin <DD>str:= ExpandConstant('{tmp}\1.jpg'); <DD>MainForm.SetBackImage(str); <DD>CurPicture:= 1; <DD>end else <DD>if ((percent &gt; 30) and (percent &lt; 60) and (CurPicture &lt;&gt; 2)) then <DD>begin <DD>str:= ExpandConstant('{tmp}\2.jpg'); <DD>MainForm.SetBackImage(str); <DD>CurPicture:= 2; <DD>end else <DD>if ((percent &gt; 60) and (percent &lt; 100) and (CurPicture &lt;&gt; 3)) then <DD>begin <DD>MainForm.SetBackImage(''); <DD>CurPicture:= 3; <DD>end; <DD>end;</DD><TR><TD>Прогресс-бар, показывающий проценты установки</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app}; AfterInstall: ExtLog; Flags: recursesubdirs<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>ProgressLabel: TLabel;<P></P><DD>procedure ExtLog(); <DD>begin <DD>SaveStringToFile(ExpandConstant('{app}\setup.log'), #13#10 + GetDateTimeString('dd/mm/yyyy hh:nn:ss', '-', ':') + ' - ' + ExpandConstant(CurrentFileName), True); <DD>with WizardForm.ProgressGauge do begin <DD>ProgressLabel.Caption:= IntToStr((Position-Min)/((Max - Min)/100)) + '%'; <DD>if (Position-Min)/((Max - Min)/100) &gt; 50 then ProgressLabel.Font.Color:= $FFFFFF <DD>end; <DD>end;<P></P><DD>procedure InitializeWizard; <DD>begin <DD>ProgressLabel := TLabel.Create(WizardForm); <DD>with WizardForm.ProgressGauge do <DD>begin <DD>ProgressLabel.Top:= Top + Height + ScaleY(8) <DD>ProgressLabel.Left:= Left + Width/2 - ScaleX(8) <DD>ProgressLabel.Caption:= '0%' <DD>ProgressLabel.AutoSize:= True <DD>ProgressLabel.Transparent:= True; <DD>ProgressLabel.Parent:= WizardForm.InstallingPage <DD>end; <DD>end;</DD><TR><TD>Прогресс-бар, показывающий проценты установки и размер</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app}; AfterInstall: Progress()<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>ProgressLabel, SizeLabel: TLabel;<P></P><DD>procedure Progress(); <DD>var <DD>size: integer;<P></P><DD>begin <DD>with WizardForm.ProgressGauge do <DD>ProgressLabel.Caption:= IntToStr((Position-Min)/((Max - Min)/100)) + '%'; <DD>FileSize(ExpandConstant(CurrentFileName), size); <DD>SizeLabel.Caption:= IntToStr(size) + ' bytes'; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ProgressLabel := TLabel.Create(WizardForm); <DD>with WizardForm.ProgressGauge do <DD>begin <DD>ProgressLabel.Top := Top + Height + ScaleY(8); <DD>ProgressLabel.Left:= Left + Width/2 - ScaleX(8); <DD>ProgressLabel.AutoSize := True; <DD>ProgressLabel.Parent := WizardForm.InstallingPage; <DD>end;<P></P><DD>SizeLabel := TLabel.Create(WizardForm); <DD>with WizardForm.ProgressGauge do <DD>begin <DD>SizeLabel.Top := Top + Height + ScaleY(8); <DD>SizeLabel.Left:= Left; <DD>SizeLabel.AutoSize := True; <DD>SizeLabel.Parent := WizardForm.InstallingPage; <DD>end; <DD>end;</DD><TR><TD>Но неизвестно, как будут отображаться проценты выполнения, если у пользователя в системе будет установлено другое оформление, и цвет прогресс-бара будет неизвестно какой, поэтому следующий скрипт</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: files\*; DestDir: {app}; AfterInstall: ExtLog(); Flags: recursesubdirs<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>ProgressLabel: TLabel;<P></P><DD>procedure ExtLog(); <DD>begin <DD>with WizardForm.ProgressGauge do begin <DD>ProgressLabel.Caption:=IntToStr((Position-Min)/((Max - Min)/100)) + '%' <DD>end <DD>end;<P></P><DD>procedure InitializeWizard; <DD>begin <DD>ProgressLabel:=TLabel.Create(WizardForm) <DD>with WizardForm.ProgressGauge do <DD>begin <DD>ProgressLabel.Top:=4 <DD>ProgressLabel.Left:=200 <DD>ProgressLabel.Caption:='0%' <DD>ProgressLabel.AutoSize:=True <DD>ProgressLabel.Font.Color:=clWindowText <DD>ProgressLabel.Font.Style:=[fsBold] <DD>ProgressLabel.Transparent:=True <DD>ProgressLabel.Parent:=WizardForm.ProgressGauge <DD>end; <DD>end;</DD><TR><TD>Слайдшоу не по времени, а по процентам</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program <DD>CreateAppDir=No <DD>WindowVisible=Yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: innocallback.dll; DestDir: {tmp}; Flags: dontcopy <DD>Source: pic1.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: pic2.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: pic3.bmp; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>type <DD>TProc=procedure(HandleW, msg, idEvent, TimeSys: LongWord); <DD>var <DD>BackgroundBitmapImage: TBitmapImage; <DD>TimerID: LongWord;<P></P><DD>function WrapTimerProc(callback:TProc; paramcount:integer):longword; <DD>external 'wrapcallback@files:innocallback.dll stdcall'; <DD>function SetTimer(hWnd: LongWord; nIDEvent, uElapse: LongWord; lpTimerFunc: LongWord): LongWord; <DD>external 'SetTimer@user32.dll stdcall'; <DD>function KillTimer(hWnd: LongWord; nIDEvent: LongWord): LongWord; <DD>external 'KillTimer@user32.dll stdcall'; <DD>function GetSystemMetrics(nIndex:Integer):Integer; <DD>external 'GetSystemMetrics@user32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>ExtractTemporaryFile('pic1.bmp') <DD>ExtractTemporaryFile('pic2.bmp') <DD>ExtractTemporaryFile('pic3.bmp') <DD>end;<P></P><DD>function PercentProgress(): Integer; <DD>begin <DD>with WizardForm.ProgressGauge do begin <DD>Result:=(Position-Min)/((Max - Min)/100) <DD>end <DD>end;<P></P><DD>procedure OnTimer(HandleW, msg, idEvent, TimeSys: LongWord); <DD>var <DD>percent: integer; <DD>begin <DD>percent:=PercentProgress <DD>with BackgroundBitmapImage do begin <DD>if ((percent&gt;0) and (percent&lt;33) and (Tag&lt;&gt;1)) then begin <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\pic1.bmp') <DD>Tag:=1 <DD>end else <DD>if ((percent&gt;34) and (percent&lt;66) and (Tag&lt;&gt;2)) then begin <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\pic2.bmp') <DD>Tag:=2 <DD>end else <DD>if ((percent&gt;67) and (percent&lt;100) and (Tag&lt;&gt;3)) then begin <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\pic3.bmp') <DD>Tag:=3 <DD>end <DD>end <DD>end;<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>var <DD>pfunc: LongWord; <DD>Width, Height: Integer; <DD>begin <DD>If CurPageID=wpInstalling <DD>then <DD>begin <DD>pfunc:=WrapTimerProc(@OnTimer, 4) <DD>TimerID:=SetTimer(0, 0, 500, pfunc) <DD>BackgroundBitmapImage:=TBitmapImage.Create(MainForm) <DD>with BackgroundBitmapImage do begin <DD>BackColor:=clBlack <DD>Center:=True <DD>Align:=alClient <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\pic1.bmp') <DD>Parent:=MainForm <DD>Tag:=1 <DD>end <DD>end <DD>if CurPageID=wpFinished <DD>then <DD>begin <DD>BackgroundBitmapImage.Hide <DD>end <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>begin <DD>KillTimer(0, TimerID) <DD>end;</DD><TR><TD>А на весь экран в этом коде можно сделать или нет?</TD><TD>Замени в процедуре <B>procedure CurPageChanged(CurPageID: Integer);</B>: <DD>BackgroundBitmapImage:=TBitmapImage.Create(MainForm) <DD>with BackgroundBitmapImage do begin <DD>BackColor:=clBlack <DD>Center:=True <DD>Align:=alClient <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\pic1.bmp') <DD>Parent:=MainForm <DD>Tag:=1 <DD>end<P>на:</P><DD>BackgroundBitmapImage:=TBitmapImage.Create(MainForm) <DD>with BackgroundBitmapImage do begin <DD>Stretch:=True <DD>Align:=alClient <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\pic1.bmp') <DD>Parent:=MainForm <DD>Tag:=1 <DD>end<P><P>А если добавить нижеуказанное, то картинка будет как и положено, и не надо ничего менять:</P><DD>procedure InitializeWizard(); <DD>var <DD>BackgroundBitmapImage: TBitmapImage; <DD>s:string; <DD>width, height:Integer; <DD>Page: TWizardPage; <DD>Text: TNewStaticText; <DD>Memo: TMemo; <DD>Path: string; <DD>FreeMB, TotalMB: Cardinal; <DD>drives: DWORD; <DD>i: integer;<P></P><DD>begin <DD>WizardForm.Position:=poScreenCenter; <DD>MainForm.BORDERSTYLE:=bsNone; <DD>width:=GetSystemMetrics(0) <DD>height:=GetSystemMetrics(1) <DD>MainForm.Width:=width; <DD>MainForm.Height:=height; <DD>width:=MainForm.ClientWidth; <DD>height:=MainForm.ClientHeight; <DD>MainForm.Visible:=True; <DD>MainForm.Left := 0; <DD>MainForm.Top := 0;</DD><TR><TD>Полноэкранный рисунок на фоновом окне и полноэкранное слайд-шоу по процентам:</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program <DD>DefaultDirName=My Program <DD>BackColor=0<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: InnoCallback.dll; DestDir: {tmp}; Flags: dontcopy <DD>Source: BackImage.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: 1.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: 2.bmp; DestDir: {tmp}; Flags: dontcopy <DD>Source: 3.bmp; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>type <DD>TProc=procedure(HandleW, msg, idEvent, TimeSys: LongWord); <DD>var <DD>BackImage, SlideImage: TBitmapImage; <DD>TimerID: LongWord; <DD>s:string; <DD>Width, Height:Integer;<P></P><DD>function WrapTimerProc(callback:TProc; paramcount:integer):longword; <DD>external 'wrapcallback@files:innocallback.dll stdcall'; <DD>function SetTimer(hWnd: LongWord; nIDEvent, uElapse: LongWord; lpTimerFunc: LongWord): LongWord; <DD>external 'SetTimer@user32.dll stdcall'; <DD>function KillTimer(hWnd: LongWord; nIDEvent: LongWord): LongWord; <DD>external 'KillTimer@user32.dll stdcall'; <DD>function GetSystemMetrics(nIndex:Integer):Integer; <DD>external 'GetSystemMetrics@user32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.Position:=poScreenCenter <DD>Width:=GetSystemMetrics(0) <DD>Height:=GetSystemMetrics(1) <DD>MainForm.BORDERSTYLE:=bsNone <DD>MainForm.Left:=0 <DD>MainForm.Top:=0 <DD>MainForm.Width:=Width <DD>MainForm.Height:=Height <DD>ExtractTemporaryFile('BackImage.bmp') <DD>s:=ExpandConstant('{tmp}')+'\BackImage.bmp ' <DD>BackImage:=TBitmapImage.Create(MainForm) <DD>BackImage.Bitmap.LoadFromFile(s) <DD>BackImage.Align:=alClient <DD>BackImage.Parent:=MainForm <DD>BackImage.Stretch:=True <DD>MainForm.Visible:=True<P></P><DD>ExtractTemporaryFile('BackImage.bmp') <DD>ExtractTemporaryFile('1.bmp') <DD>ExtractTemporaryFile('2.bmp') <DD>ExtractTemporaryFile('3.bmp') <DD>end;<P></P><DD>function PercentProgress(): Integer; <DD>begin <DD>with WizardForm.ProgressGauge do begin <DD>Result:=(Position-Min)/((Max - Min)/100) <DD>end <DD>end;<P></P><DD>procedure OnTimer(HandleW, msg, idEvent, TimeSys: LongWord); <DD>var <DD>percent: integer; <DD>begin <DD>percent:=PercentProgress <DD>with SlideImage do begin <DD>if ((percent&gt;0) and (percent&lt;10) and (Tag&lt;&gt;1)) then begin <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\1.bmp') <DD>Tag:=1 <DD>end else <DD>if ((percent&gt;11) and (percent&lt;20) and (Tag&lt;&gt;2)) then begin <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\2.bmp') <DD>Tag:=2 <DD>end else <DD>if ((percent&gt;21) and (percent&lt;100) and (Tag&lt;&gt;3)) then begin <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\3.bmp') <DD>Tag:=3 <DD>end <DD>end <DD>end;<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>var <DD>pfunc: LongWord; <DD>Width, Height: Integer; <DD>begin <DD>If CurPageID=wpInstalling <DD>then <DD>begin <DD>pfunc:=WrapTimerProc(@OnTimer, 4) <DD>TimerID:=SetTimer(0, 0, 500, pfunc) <DD>SlideImage:=TBitmapImage.Create(MainForm) <DD>with SlideImage do begin <DD>Stretch:=True <DD>Align:=alClient <DD>Bitmap.LoadFromFile(ExpandConstant('{tmp}') + '\1.bmp') <DD>Parent:=MainForm <DD>Tag:=1 <DD>end <DD>end <DD>if CurPageID=wpFinished <DD>then <DD>begin <DD>SlideImage.Hide <DD>end <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>begin <DD>KillTimer(0, TimerID) <DD>end;</DD><TR><TD>Прогресс-бар как у InstallShield</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes <DD>WindowVisible=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; Flags: ignoreversion <DD>Source: ..\WizModernSmallImage.bmp; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>var <DD>Form1: TSetupForm; <DD>StaticText: TNewStaticText; <DD>BitmapImage: TBitmapImage; <DD>BitmapFileName: String; <DD>begin <DD>Form1 := CreateCustomForm(); <DD>try <DD>with Form1 do <DD>begin <DD>ClientWidth := ScaleX(380); <DD>ClientHeight := ScaleY(120); <DD>BorderStyle:= bsToolWindow; <FONT color=green>// или bsDialog, bsNone кому что нравится</FONT> <DD>BorderIcons:= BorderIcons - [biSystemMenu]; <DD>FormStyle:= fsStayOnTop; <DD>Center; <DD>end;<P></P><DD>BitmapFileName := ExpandConstant('{tmp}\WizModernSmallImage.bmp'); <DD>ExtractTemporaryFile(ExtractFileName(BitmapFileName)); <DD>BitmapImage := TBitmapImage.Create(Form1); <DD>BitmapImage.Left := ScaleX(8); <DD>BitmapImage.Top := ScaleY(8); <DD>BitmapImage.AutoSize := True; <DD>BitmapImage.Bitmap.LoadFromFile(BitmapFileName); <DD>BitmapImage.Parent := Form1;<P></P><DD>StaticText := TNewStaticText.Create(Form1); <DD>StaticText.Top := BitmapImage.Top; <DD>StaticText.Left := BitmapImage.Left + BitmapImage.Width + ScaleX(8) <DD>StaticText.Caption := 'Inno Setup is a free installer for Windows programs.' + #10#13 + 'Support for all versions of Windows in use today'; <DD>StaticText.AutoSize := True; <DD>StaticText.Parent := Form1;<P></P><DD>Form1.Show(); <DD>Form1.Repaint; <DD>Sleep(2000); <DD>finally <DD>Form1.Free(); <DD>end; <DD>end;</DD><TR><TD>Скрытное копирование файлов - только прогресс-бар, никакого мелькания имен файлов</TD><TD>1. Код: <DD><FONT color=red>[Files]</FONT> <DD>Source: .\Files\*; DestDir: "{app}"; BeforeInstall: HideInstallPath; AfterInstall: ShowInstallPath<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure HideInstallPath(); <DD>begin <DD>WizardForm.FileNameLabel.Visible := False; <DD>end; <DD><FONT color=green>//*******//</FONT> <DD>procedure ShowInstallPath(); <DD>begin <DD>WizardForm.FileNameLabel.Visible := True; <DD>end;<P>2. Можешь попробовать и так сделать:</P><DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.FileNameLabel.Visible:= False; <DD>end; <DT>Это отключит отображение файлов вообще.<P>В первом случае путь скрывается только для тех файлов, для которых заданы указанные процедуры; во втором - путь скрывается для всех файлов. Первый вариант более гибкий, но если надо скрыть путь абсолютно для всех файлов - предпочтительнее второй вариант.<P>В примере ниже путь будет скрыт только для файлов, копируемых в системную директорию:</P><DD><FONT color=red>[Files]</FONT> <DD>Source: .\AppFiles\*; DestDir: "{app}" <DD>Source: .\SysFiles\*; DestDir: "{sys}"; BeforeInstall: HideInstallPath; AfterInstall: ShowInstallPath <DD>Source: .\DocFiles\*; DestDir: "{app}"<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure HideInstallPath(); <DD>begin <DD>WizardForm.FileNameLabel.Visible := False; <DD>end; <DD><FONT color=green>//*******//</FONT> <DD>procedure ShowInstallPath(); <DD>begin <DD>WizardForm.FileNameLabel.Visible := True; <DD>end;</DD><TR><TD>Как можно реализовать, чтобы по ходу инсталляции не было видно прогресс-бара и устанавливаемых файлов?</TD><TD><DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.FilenameLabel.Hide <FONT color=green>//Прячем извлекаемые файлы</FONT> <DD>WizardForm.ProgressGauge.Hide <FONT color=green>//Прячем прогресс-бар</FONT> <DD>end;</DD><TR><TD>Интерфейс установки, максимально приближенный к InstallShield, реализованный стандартными средствами Inno Setup. Для создания слайд-шоу используется библиотека IsXbb. Используется Splash-заставка. <DT>При запуске инсталлятора отсутствует "мозолящий" глаза синий фон и имя программы. <DT>Здесь хорошо то, что Splash отображается на странице подготовки, как в InstallSield.</DT></TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>DisableProgramGroupPage=yes <DD>WindowShowCaption=no <DD>BackColor=$000000<P></P><DD><FONT color=red>[Files]</FONT> <DD><FONT color=green>;Рисунок, используемый для отображения на странице подготовки</FONT> <DD>Source: "C:\Program Files\Inno Setup 5\WizModernSmallImage.bmp"; DestDir: {tmp}; Flags: dontcopy; <DD><FONT color=green>;Также используется на странице подготовки как Splash-заставка</FONT> <DD>Source: "Temp\Splash.bmp"; DestDir: {tmp}; Flags: dontcopy; <DD><FONT color=green>;В качестве фона используется изобрaжение в формате .bmp. Уменьшить размер файла (почти без видимых потерь) можно в Adobe Photoshop (Image =&gt; Mode =&gt; Indexed Color =&gt; Palette: Local (_ANY_))</FONT> <DD>Source: "Temp\Image.bmp"; DestDir: {tmp}; Flags: dontcopy; <DD><FONT color=green>;Библиотека для создания слайд-шоу</FONT> <DD>Source: "Temp\IsXbb.dll"; DestDir: {tmp}; Flags: dontcopy; <DD><FONT color=green>;Файлы для слайд-сшоу (их может быть и больше)</FONT> <DD>Source: "Temp\1.jpg"; DestDir: {tmp}; Flags: dontcopy; <DD>Source: "Temp\2.jpg"; DestDir: {tmp}; Flags: dontcopy; <DD>Source: "Temp\3.jpg"; DestDir: {tmp}; Flags: dontcopy; <DD>Source: "Temp\4.jpg"; DestDir: {tmp}; Flags: dontcopy; <DD>Source: "Temp\5.jpg"; DestDir: {tmp}; Flags: dontcopy; <DD><FONT color=green>;Файлы проекта</FONT> <DD>Source: "Work\*.*"; DestDir: "{app}"; Flags: overwritereadonly ignoreversion recursesubdirs createallsubdirs;<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD><FONT color=green>{"1,2,3,4" - в разных углах, "5" - по центру, "6" - растянуть изображениe}</FONT> <DD>BACKGROUND=6; <DD>TIMER=16; <DD>function isxbb_AddImage(Image: PChar; Flags: Cardinal): Integer; <DD>external 'isxbb_AddImage@files:isxbb.dll stdcall'; <DD>function isxbb_Init(hWnd: Integer): Integer; <DD>external 'isxbb_Init@files:isxbb.dll stdcall'; <DD>function isxbb_StartTimer(Seconds: Integer; Flags: Cardinal): Integer; <DD>external 'isxbb_StartTimer@files:isxbb.dll stdcall'; <DD>function isxbb_KillTimer(Flags: Cardinal): Integer; <DD>external 'isxbb_KillTimer@files:isxbb.dll stdcall'; <DD>function GetSystemMetrics(nIndex:Integer):Integer; <DD>external 'GetSystemMetrics@user32.dll stdcall';<P></P><DD>var <DD>Splash: TSetupForm;<P></P><DD>procedure InitializeWizard(); <DD>var <DD>BackgroundBitmapImage: TBitmapImage; <DD>s: string; <DD>Form: TSetupForm; <DD>Width, Height: Integer; <DD>ProgressBar: TNewProgressBar; <DD>CancelButton: TButton; <DD>StaticText: TNewStaticText; <DD>BitmapImage: TBitmapImage; <DD>BitmapImage1: TBitmapImage; <DD>BitmapFileName: String; <DD>i: Integer; <DD>begin <DD>WizardForm.Position:= poScreenCenter; <DD>MainForm.BORDERSTYLE := bsNone; <DD>Splash:= CreateCustomForm; <DD>Splash.BorderStyle:= bsNone; <DD>BitmapImage1:= TBitmapImage.Create(Splash); <DD>With BitmapImage1 do <DD>begin <DD>AutoSize:= True; <DD>Align:= alClient; <DD>Left:= 0; <DD>Top:= 0; <DD>Stretch:= True; <DD>Parent:= Splash; <DD>end; <DD>ExtractTemporaryFile('Splash.bmp'); <DD>BitmapImage1.Bitmap.LoadFromFile(ExpandConstant('{tmp}')+'\Splash.bmp'); <DD>Splash.Width:= BitmapImage1.Width; <DD>Splash.Height:= BitmapImage1.Height; <DD>Splash.Center; <DD>Splash.Show; <DD>BitmapImage1.Refresh; <DD>Form:= CreateCustomForm(); <DD>try <DD>with Form do <DD>begin <DD>ClientWidth:= ScaleX(380); <DD>ClientHeight:= ScaleY(120); <DD>BorderStyle:= bsDialog; <DD>Left:= GetSystemMetrics(16) - ClientWidth - ScaleX(8); <DD>Top:= GetSystemMetrics(17) - ClientHeight - ScaleY(8); <DD>end; <DD>BitmapFileName:= ExpandConstant('{tmp}\WizModernSmallImage.bmp'); <DD>ExtractTemporaryFile(ExtractFileName(BitmapFileName)); <DD>BitmapImage:= TBitmapImage.Create(Form); <DD>BitmapImage.Left:= ScaleX(8); <DD>BitmapImage.Top:= ScaleY(8); <DD>BitmapImage.AutoSize:= True; <DD>BitmapImage.Bitmap.LoadFromFile(BitmapFileName); <DD>BitmapImage.Parent:= Form; <DD>StaticText:= TNewStaticText.Create(Form); <DD>StaticText.Top:= BitmapImage.Top; <DD>StaticText.Left:= BitmapImage.Left + BitmapImage.Width + ScaleX(8) <DD><FONT color=green>{Надпись, которая будет отображаться на странице подготовки}</FONT> <DD>StaticText.Caption := ''#10#13'"______" now preparing to install...'; <DD>StaticText.AutoSize:= True; <DD>StaticText.Parent:= Form; <DD>CancelButton:= TButton.Create(Form); <DD>CancelButton.Parent:= Form; <DD>CancelButton.Width:= ScaleX(75); <DD>CancelButton.Height:= ScaleY(23); <DD>CancelButton.Left:= Form.ClientWidth - ScaleX(75 + 10); <DD>CancelButton.Top:= Form.ClientHeight - ScaleY(23 + 10); <DD>CancelButton.Caption:= 'Cancel'; <DD>CancelButton.ModalResult:= mrCancel; <DD>CancelButton.Cancel:= True; <DD>Form.Caption:= 'Preparing...'; <DD>ProgressBar:= TNewProgressBar.Create(Form); <DD>with ProgressBar do <DD>begin <DD>Height:= CancelButton.Height - ScaleY(8); <DD>Width:= Form.Width - ScaleX(128); <DD>Top:= CancelButton.Top; <DD>Left:= BitmapImage.Left; <DD>Parent:= Form; <DD>Min:= 0; <DD>Max:= 30; <DD>Position:= 0; <DD>end; <DD>Form.ActiveControl:= CancelButton; <DD>Form.Show(); <DD>for i:= 0 to 30 do <DD>begin <DD>ProgressBar.Position:= i; <DD>Form.Repaint; <DD>Sleep(400); <DD>i:= i + 2; <DD>end; <DD>finally <DD>Form.Free(); <DD>Splash.Close; <DD>Width:= GetSystemMetrics(0); <DD>Height:= GetSystemMetrics(1); <DD>MainForm.Width:= width; <DD>MainForm.Height:= height; <DD>Width:= MainForm.ClientWidth; <DD>Height:= MainForm.ClientHeight; <DD>ExtractTemporaryFile('Image.bmp'); <DD>s:= ExpandConstant('{tmp}') + '\Image.bmp'; <DD>BackgroundBitmapImage:= TBitmapImage.Create(MainForm); <DD>BackgroundBitmapImage.Bitmap.LoadFromFile(s); <DD>BackgroundBitmapImage.Left:= 0; <DD>BackgroundBitmapImage.Top:= 0; <DD>BackgroundBitmapImage.Width:= width; <DD>BackgroundBitmapImage.Height:= height; <DD>BackgroundBitmapImage.Parent:= MainForm; <DD>BackgroundBitmapImage.Stretch:= True; <DD><FONT color=green>{Не забудьте прописать здесь и ниже правильные имена и количество файлов для слайд-шоу!}</FONT> <DD>ExtractTemporaryFile('1.jpg'); <DD>ExtractTemporaryFile('2.jpg'); <DD>ExtractTemporaryFile('3.jpg'); <DD>ExtractTemporaryFile('4.jpg'); <DD>ExtractTemporaryFile('5.jpg'); <DD>MainForm.Visible := True; <DD>end; <DD>end;<P></P><DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>begin <DD>If CurStep=ssInstall <DD>then <DD>begin <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\1.jpg',BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\2.jpg',BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\3.jpg',BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\4.jpg',BACKGROUND or TIMER); <DD>isxbb_AddImage(ExpandConstant('{tmp}')+'\5.jpg',BACKGROUND or TIMER); <DD>isxbb_Init(StrToInt(ExpandConstant('{hwnd}'))); <DD><FONT color=green>{Указывается время отображения на экране каждого изображения}</FONT> <DD>isxbb_StartTimer(8,BACKGROUND) <DD>end <DD>else <DD>If CurStep=ssPostInstall <DD>then <DD>isxbb_KillTimer(BACKGROUND); <DD>end;<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>var <DD>Width, Height: Integer; <DD>begin <DD>If CurPageID=wpInstalling <DD>then <DD>begin <DD><FONT color=green>{Здесь размер окна установки уменьшается, с него убирается всё лишнее и оно смещается в нижний правый угол экрана (не зависит от разрешения)}</FONT> <DD>WizardForm.CancelButton.BringToFront; <DD>WizardForm.MainPanel.Visible:= False; <DD>WizardForm.Bevel1.Visible:= False; <DD><FONT color=green>{Размер получaемого окна установки}</FONT> <DD>Width:= ScaleX(395); <DD>Height:= ScaleY(150); <DD>WizardForm.Left:= GetSystemMetrics(16) - Width - ScaleX(5); <DD>WizardForm.Top:= GetSystemMetrics(17) - Height - ScaleY(-50); <DD>WizardForm.Width:= ScaleX(395); <DD>WizardForm.Height:=ScaleY(150); <DD>WizardForm.InnerNotebook.Left:= ScaleX(10); <DD>WizardForm.InnerNotebook.Top:= ScaleY(10); <DD>WizardForm.InnerNotebook.Width:= ScaleX(370); <DD>WizardForm.StatusLabel.Left:= ScaleX(0); <DD>WizardForm.StatusLabel.Top:= ScaleY(0); <DD>WizardForm.StatusLabel.Width:= WizardForm.InnerNotebook.Width; <DD>WizardForm.FileNameLabel.Left:= ScaleX(0); <DD>WizardForm.FileNameLabel.Top:= ScaleY(20); <DD>WizardForm.FileNameLabel.Width:= WizardForm.InnerNotebook.Width; <DD>WizardForm.ProgressGauge.Top:= ScaleY(40); <DD>WizardForm.ProgressGauge.Width:= WizardForm.InnerNotebook.Width; <DD>WizardForm.CancelButton.Left:= ScaleX(154); <DD>WizardForm.CancelButton.Top:= ScaleY(80); <DD>end <DD>if CurPageID=wpFinished <DD>then <DD>begin <DD><FONT color=green>{Окно установки принимает стандартный вид}</FONT> <DD>WizardForm.Width:=502; <DD>WizardForm.Height:=392; <DD>WizardForm.Position:=poScreenCenter; <DD>end <DD>end;</DD><TR><TD>Как изменить текст на странице завершения вместе с названием кнопки?</TD><TD>Можно делать по-разному: <DT>1. Ищем текст, который там выводится в Default.isl (и всех остальных) файлах языков и меняем на свой текст. <DT>2. В файлах языков .isl записывам свое сообщение в <FONT color=red>[CustomMessages]</FONT> и потом его используем, подменяя стандартное.<P></P><DT>Пример. Открываем нужный языковой файл в формате .isl и находим там интересующий нас текст, перед текстом будет переменная, которая и отвечает за отображаемый текст. Заносим эту переменную в свой скрипт в секцию <FONT color=red>[Messages]</FONT>. В итоге будет: <DD><FONT color=red>[Messages]</FONT> <DD>WelcomeLabel2=Твой текст</DD><TR><TD>Как можно сделать, чтобы писались те папки, которые выбраны?</TD><TD>Каждую базу со всеми каталогами архивируем, например, в 7z. Будет в результате: <DT>archiv1.7z .... archiv10.7z ... archivN.7z. <DT>7zip тащим с собой в инсталляторе. В инсталляторе разархивируем в temp, а потом тупо через <DT><B>xcopy /Y /R "что копировать" "куда копировать"</B> <DT>копируем все содержимое.</DT><TR><TD>Как написать информацию в нижнем левом углу (как в инсталляторах ZoneOfGames), и внизу на линии, которая отделяет основное окно от кнопок Назад Далее Отмена</TD><TD><DD><FONT color=red>[Messages]</FONT> <DD>BeveledLabel=Твой текcт</DD><TR><TD>Как сделать подпись (желательно для всех страниц)?</TD><TD><DD><FONT color=red>[Messages]</FONT> <DD>BeveledLabel=Copyright 2007 © Microsoft</DD><TR><TD>Как сделать подпись, но не через BeveledLabel, а созданием нового текста?</TD><TD><DD><FONT color=red>[Code]</FONT> <DD>Var <DD>Text: TNewStaticText;<P></P><DD>Procedure InitializeWizard(); <DD>begin <DD>Text:=TNewStaticText.Create(WizardForm) <DD>Text.Left:=10 <DD>Text.Top:=468 <DD>Text.Color:=$dbcdcc <DD>Text.Font.Color:=$ab663d <DD>Text.Caption:='<FONT color=blue>Твой текcт</FONT>' <DD>Text.Parent:=WizardForm <DD>end;</DD><TR><TD>Как на BeveledLabel "повесить" ссылку, чтобы текст по умолчанию не был подчеркнут, а при наведении на текст, он подчеркивался и конечно, хотелось бы, менять цвет шрифта!</TD><TD><DD>procedure BevelLabelClick(Sender: TObject); <DD>var ErrorCode: Integer; <DD>begin <DD>ShellExec('open','http://www.innosetup.com','', '', SW_SHOW, ewNoWait, ErrorCode) <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>with WizardForm do begin <DD>with BeveledLabel do begin <DD>OnClick:=@BevelLabelClick; <DD>Font.Color:=clBlue; <DD>Enabled:=True; <DD>Cursor:=crHand; <DD>end; <DD>end; <DD>end;<P></P><DT>Доступные цвета: clBlack, clMaroon, clGreen, clOlive, clNavy, clPurple, clTeal, clGray, clSilver, clRed, clLime, clYellow, clBlue, clFuchsia, clAqua, clWhite. <DT>Также цвет можно задавать в RGB, например, Font.Color:=8388608; <DT>Но удобнее в 16-ричном виде, например, Font.Color:=$0000FF00; <DT>т.е. в общем случае $00BBGGRR <DT>где: <DT>BB - уровень синего (от 00 до FF) <DT>GG - уровень зеленого (от 00 до FF) <DT>RR - уровень красного (от 00 до FF)<P></P><DT>В ISTool можно определить нужный цвет (Options\Внешний вид\Цвет фона\Custom и выбирай нужный тебе цвет). <DT>Также можно использовать Paint (Colors - Edit Colors - Define Custom Colors) плюс виндовый калькулятор для перевода в hex (Calc.exe - View - Scientific).</DT><TR><TD>Как сделать, чтобы ссылка BeveledLabel меняла цвет при наведении курсора и при нажатии?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\AppName<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>MouseLabel,SiteLabel: TLabel;<P></P><DD>procedure SiteLabelOnClick(Sender: TObject); <DD>var <DD>ErrorCode: Integer; <DD>begin <DD>ShellExec('open', 'http://forum.ru-board.com', '', '', SW_SHOWNORMAL, ewNoWait, ErrorCode) <DD>end;<P></P><DD>procedure SiteLabelMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>SiteLabel.Font.Color:=clRed <DD>end;<P></P><DD>procedure SiteLabelMouseUp(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>SiteLabel.Font.Color:=clBlue <DD>end;<P></P><DD>procedure SiteLabelMouseMove(Sender: TObject; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>SiteLabel.Font.Color:=clGreen <DD>end;<P></P><DD>procedure SiteLabelMouseMove2(Sender: TObject; Shift: TShiftState; X, Y: Integer); <DD>begin <DD>SiteLabel.Font.Color:=clBlue <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>MouseLabel:=TLabel.Create(WizardForm) <DD>MouseLabel.Width:=WizardForm.Width <DD>MouseLabel.Height:=WizardForm.Height <DD>MouseLabel.Autosize:=False <DD>MouseLabel.Transparent:=True <DD>MouseLabel.OnMouseMove:=@SiteLabelMouseMove2 <DD>MouseLabel.Parent:=WizardForm<P></P><DD>SiteLabel:=TLabel.Create(WizardForm) <DD>SiteLabel.Left:=10 <DD>SiteLabel.Top:=330 <DD>SiteLabel.Cursor:=crHand <DD>SiteLabel.Font.Color:=clBlue <DD>SiteLabel.Caption:='Forum Ru-Board' <DD>SiteLabel.OnClick:=@SiteLabelOnClick <DD>SiteLabel.OnMouseDown:=@SiteLabelMouseDown <DD>SiteLabel.OnMouseUp:=@SiteLabelMouseUp <DD>SiteLabel.OnMouseMove:=@SiteLabelMouseMove <DD>SiteLabel.Parent:=WizardForm <DD>end;</DD><TR><TD>Как добавить на первой странице в нижнем левом углу надпись?</TD><TD>Чтобы внизу слева отображался URL и кнопка, при нажатии которой отображалось нужное сообщение: <DD><FONT color=red>[Code]</FONT> <DD>procedure AboutButtonOnClick(Sender: TObject); <DD>begin <DD>MsgBox('Это демо версия программы.', mbInformation, mb_Ok); <DD>end;<P></P><DD>procedure URLLabelOnClick(Sender: TObject); <DD>var <DD>ErrorCode: Integer; <DD>begin <DD>ShellExec('open', 'http://www.innosetup.com', '', '', SW_SHOWNORMAL, ewNoWait, ErrorCode); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>var <DD>AboutButton, CancelButton: TButton; <DD>URLLabel: TNewStaticText; <DD>BackgroundBitmapImage: TBitmapImage; <DD>BackgroundBitmapText: TNewStaticText;<P></P><DD>begin <DD>CancelButton := WizardForm.CancelButton; <DD>AboutButton := TButton.Create(WizardForm); <DD>AboutButton.Left := WizardForm.ClientWidth - CancelButton.Left - CancelButton.Width; <DD>AboutButton.Top := CancelButton.Top; <DD>AboutButton.Width := CancelButton.Width; <DD>AboutButton.Height := CancelButton.Height; <DD>AboutButton.Caption := '&amp;About...'; <DD>AboutButton.OnClick := @AboutButtonOnClick; <DD>AboutButton.Parent := WizardForm;<P></P><DD>URLLabel := TNewStaticText.Create(WizardForm); <DD>URLLabel.Caption := 'www.innosetup.com'; <DD>URLLabel.Cursor := crHand; <DD>URLLabel.OnClick := @URLLabelOnClick; <DD>URLLabel.Parent := WizardForm; <DD><FONT color=green>{ Alter Font *after* setting Parent so the correct defaults are inherited first }</FONT> <DD>URLLabel.Font.Style := URLLabel.Font.Style + [fsUnderline]; <DD>URLLabel.Font.Color := clBlue; <DD>URLLabel.Top := AboutButton.Top + AboutButton.Height - URLLabel.Height - 2; <DD>URLLabel.Left := AboutButton.Left + AboutButton.Width + ScaleX(20);<P></P><DD>BackgroundBitmapImage := TBitmapImage.Create(MainForm); <DD>BackgroundBitmapImage.Left := 50; <DD>BackgroundBitmapImage.Top := 100; <DD>BackgroundBitmapImage.AutoSize := True; <DD>BackgroundBitmapImage.Bitmap := WizardForm.WizardBitmapImage.Bitmap; <DD>BackgroundBitmapImage.Parent := MainForm;<P></P><DD>BackgroundBitmapText := TNewStaticText.Create(MainForm); <DD>BackgroundBitmapText.Left := BackgroundBitmapImage.Left; <DD>BackgroundBitmapText.Top := BackgroundBitmapImage.Top + BackgroundBitmapImage.Height + ScaleY(8); <DD>BackgroundBitmapText.Caption := 'TBitmapImage'; <DD>BackgroundBitmapText.Parent := MainForm; <DD>end;<P></P><DD><FONT color=red>[LangOptions]</FONT> <DD>TitleFontSize=100 <DD>TitleFontName=Monotype Corsiva</DD><TR><TD>Нужно поменять надпись "Распаковка файлов" при копировании файлов... <DT>Нашёл такую вещь, как "StatusExtractFiles" в секции <FONT color=red>[Messages]</FONT>, но она делает не совсем то, чего я хочу (например при копировании определённых файлов надпись одна, а при копировании других - другая, а там просто меняется вся надпись)...</DT></TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: "{src}\*.exe"; DestDir: {app}; BeforeInstall: ChangeCaption('Откиньтесь на спинку кресла и наслаждайтесь!') <DD>Source: "{src}\*.dll"; DestDir: {app}; BeforeInstall: ChangeCaption('Не забудьте зарегистрироваться')<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure ChangeCaption(str: string); <DD>begin <DD>WizardForm.StatusLabel.Caption:= str; <DD>end;</DD><TR><TD>Можно ли сменить иконку у папки, в которую инсталлируется прога?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Dirs]</FONT> <DD>Name: {app}; Attribs: system<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app}<P></P><DD><FONT color=red>[INI]</FONT> <DD>Filename: {app}\Desktop.ini; Section: ".ShellClassInfo"; Key: "IconFile"; String: "%SystemRoot%\system32\SHELL32.dll" <DD>Filename: {app}\Desktop.ini; Section: ".ShellClassInfo"; Key: "IconIndex"; String: "27"</DD><TR><TD>Можно ли сменить иконку у деинсталлятора?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>UninstallFilesDir={app}\uninst<P></P><DD><FONT color=red>[Icons]</FONT> <DD>Name: "{app}\Uninstall My Program"; Filename: "{uninstallexe}"; IconFilename: "aaa.exe"<P></P><DT>Т.е. деинсталлятор помещать в отдельную папку, а в папке с программой создавать ярлык на деинсталлятор, которому задавать любую нужную иконку.</DT><TR><TD>Как поменять иконку программе в Панель управления - &gt; Установка и удаление программ?</TD><TD>В папку с программой нужно положить icon.ico и включить этот файл в скрипт: <DD><FONT color=red>[Setup]</FONT> <DD>UninstallDisplayIcon={app}\icon.ico<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: C:\icon.ico; DestDir: {app}</DD><TR><TD>Как сделать, чтобы программа отображалась в установке\удалении программ?</TD><TD>Из хелпа: <DT><FONT color=red>[Setup]</FONT>: CreateUninstallRegKey <DT>но по умолчанию там yes, надо автоматом.</DT><TR><TD>Как сделать, чтобы после установки программы, она не добавлялась в список "Установка и удаление"?</TD><TD>В секции <FONT color=red>[Setup]</FONT> добавь строчку <B>CreateUninstallRegKey=no</B><TR><TD>Как пользоваться функцией <B>DeleteFile</B>?</TD><TD>Довольно просто: <DT>DeleteFile('&lt;путь до файла&gt;\гггг.txt'); <DT>Если файл есть, функция вернет TRUE, иначе FALSE. Например: <DT>DeleteFile('C:\Documents and Settings\User\Рабочий стол\гггг.txt');</DT><TR><TD>Как можно сделать, чтобы при нажатии на кнопку <B>Отмена</B> инсталлятор автоматически закрывался без потверждения?</TD><TD><DD>procedure CancelButtonClick(CurPageID: Integer; var Cancel, Confirm: Boolean); <DD>begin <DD>Confirm:=False; <DD>Cancel:=True; <DD>end;</DD><TR><TD>Можно ли перед удалением программы, чтобы выдавало сообщение, типа "Если вы не делали резервные копии файлов, то удаление приведёт к неработоспособности программы. Продолжить?" и кнопки "Да" "Нет". Если нажимаешь "Да", то прога удаляется, а если "Нет", то удаление закрывается?</TD><TD>Используй функцию <B>InitializeUninstall</B>. Смотри тот же пример - <B>UninstallCode</B>. Там перед началом удаления выдается сообщение, такое же можешь применить и ты.<TR><TD>Как сделать, чтобы при удалении проги не удалялись некоторые файлы?</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: "нужный.файл"; DestDir: "{app}"; Flags: <B>uninsneveruninstall</B></DD><TR><TD>Подскажите плиз, параметр\код, чтобы после деинсталяции не появлялось окошко об окончании удаления программы (кнопка "ОК"), но чтобы осталось окно, когда деинсталлер просит о перезагрузке после деинсталяции (кнопка "ДА" и "НЕТ").</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>UninstallRestartComputer=yes</DD><TR><TD>Как при деинсталляции сделать дополнительный чекбокс "Удалить сохраненные игры?" (удалить не спрашивая можно в секции <FONT color=red>[UninstallDelete]</FONT>, но нужен чекбокс)?</TD><TD><DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if CurUninstallStep=usDone then <DD>begin <DD>if DirExists(ExpandConstant('{app}\profiles')) then <DD>begin <DD>if MsgBox('Удалить сохраненные игры?',mbconfirmation, mb_yesno) = IDYES then <DD>begin <DD>DelTree(ExpandConstant('{app}'), True, True, True); <DD>end; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Можно ли сделать, чтобы когда папка будет удалена, выдавалось сообщение, что сохраненные игры были удалены?</TD><TD><DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if CurUninstallStep=usDone then <DD>begin <DD>if DirExists(ExpandConstant('{app}\profiles')) then <DD>begin <DD>if MsgBox('Удалить сохраненные игры?',mbconfirmation, mb_yesno) = IDYES then <DD>begin <DD>DelTree(ExpandConstant('{app}'), True, True, True); <DD>MsgBox('сообщение...', mbinformation, mb_ok); <DD>end; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Как сделать, чтобы при удалении проверялось наличие папки сохранений и, если она есть, то только тогда делать запрос на удаление?</TD><TD><DD><FONT color=red>[Registry]</FONT> <DD>Root: HKLM; SubKey: SOFTWARE\Chuvakstepan\Spider-man3; ValueType: string; ValueName: PathGame; ValueData: {app}; Flags: uninsdeletekey<P></P><DD><FONT color=red>[Code]</FONT> <DD><FONT color=green>/////////// Удаление игровых сохранений</FONT> <DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>var ResultStr:String; <DD>begin <DD>if CurUninstallStep=usPostUninstall then <DD>begin <DD>RegQueryStringValue(HKLM, 'SOFTWARE\Chuvakstepan\Spider-man3', 'UnInstConfirm', ResultStr) <DD>if DirExists(ExpandConstant('{userdocs}')+'\Activision\Spider-Man 3') then <DD>if MsgBox('Удалить сохраненные игры',mbconfirmation, mb_YesNo) = IDYES then <DD>begin <DD>if not DelTree(ExpandConstant('{userdocs}')+'\Activision\Spider-Man 3', True, True, True) <DD>then <DD>MsgBox('Папка не удалена!' #13#13 'Папка не существует или задействована.', mbError, MB_OK); <DD>end; <DD>end; <DD>end;</DD><TR><TD>Почему, если я пишу при установке: <DT>Source: "D:\foldername\*", <DT>не копируются вложенные в эту директорию папки, а только файлы?</DT><TD>Допиши: <DT>Flags: recursesubdirs createallsubdirs</DT><TR><TD>Можно ли сделать как в последних инсталляторах от 1с (такое ещё у InstallShield), когда после установки игры, если ещё раз хочешь запустить установку автоматом, то запускается деинсталлятор?</TD><TD>В секции <FONT color=red>[Setup]</FONT> генерируешь appid (например AppID={{0872DB47-24CB-4C7F-AC4B-E6EFC27BD244}), <DT>в секцию добавляешь следущее: <DD><FONT color=red>[Code]</FONT> <DD>var <DD>ResultStr:string; <DD>ResultCode: Integer;<P></P><DD>function InitializeSetup(): Boolean; <DD>begin <DD>RegQueryStringValue(HKLM, 'SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall\{0872DB47-24CB-4C7F-AC4B-E6EFC27BD244}_is1', 'UninstallString', ResultStr) <DD>if ResultStr='' then <DD>begin <DD>Result := True; <DD>end <DD>else <DD>ResultStr:=RemoveQuotes(ResultStr); <DD>Exec(ResultStr, '', '', SW_SHOWNORMAL, ewNoWait, ResultCode) <DD>end;</DD><TR><TD>Помогите написать код, который бы проверял, пустая ли папка, в которую устанавливается программа, и если там что-то есть, то все это удалял. Похоже, штатными средствами этого не сделать, а код на паскале написать не получается.<P>Да, можно упростить код, чтобы удалялась вся папка целиком, куда копируются файлы, а потом создавалась снова, и файлы копировались бы уже в чистую папку.</P></TD><TD><DT>Попробуй следующее: <DD>function InitializeSetup :Boolean; <DD>begin <DD>if DirExists(Name) then <DD>DelTree(Name, True, True, True); <DD>end;<P></P><DT>Либо именуй процедуру по-своему, а у первого устанавливаемого файла добавляй в хвосте BeforeInstall <DD><FONT color=red>[Files]</FONT> <DD>Source: "MYPROG.EXE"; DestDir: "{app}"; BeforeInstall: MyBeforeInstall <DD><FONT color=red>[Сode]</FONT> <DD>Procedure MyBeforeInstall; <DD>begin <DD>if DirExists(ExpandConstant('{app}')) then <DD>DelTree(ExpandConstant('{app}'), True, True, True); <DD>end;</DD><TR><TD>Какой функцией удалить все содержимое папки, в которую будет устанавливаться программа?</TD><TD>function DelTree(const Path: String; const IsDir, DeleteFiles, DeleteSubdirsAlso: Boolean): Boolean;<P><FONT color=green>// Delete all files and directories inside C:\Test</FONT> <DT><FONT color=green>// but leave the directory itself</FONT> <DT>DelTree('C:\Test\*', False, True, True);<P></P><DT><FONT color=green>---</FONT> <DT>Не работает, он ничего не удаляет в папке перед установкой. <DT>Мне нужно чтобы перед началом распаковки файлов инсталлятор удалил все её содержимое и только после этого начал установку (папка для установки может быть любая - выбирается пользователем). <DT>И как сделать, чтобы после удаления инсталлятора, удалилась папка {app} ? <DT><FONT color=green>---</FONT> <DD><FONT color=red>[UninstallDelete]</FONT> <DD>Type: filesandordirs; Name: "{app}"<P></P><DD><FONT color=red>[Code]</FONT> <DD><FONT color=green>// в NextButtonClick добавляешь</FONT> <DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>begin<P></P><DD><FONT color=green>//добавить эти строчки</FONT> <DD>if CurPageID = wpReady then <DD>begin <DD>if DirExists({app}) then DelTree('{app}\*', False, True, True); <DD>end; <DD><FONT color=green>//</FONT><P></P><DD>Result := True; <DD>end;</DD><TR><TD>Есть ли в Inno возможность сделать инсталлятор на русском языке?</TD><TD>В папке inno зайди в папку Languages и перенеси файл Russian.isl в корневую папку inno, переименовав его в Default.isl<TR><TD>Мне нужно, чтобы после установки у меня отображалась информация из ртф файла?</TD><TD>InfoAfterFile=C:\In_update_manual.rtf<TR><TD>Мне надо запустить текстовый документ после установки программы?</TD><TD><DD><FONT color=red>[Run]</FONT> <DD>Filename: speed.txt; Description: Запустить; Flags: shellexec</DD><TR><TD>Есть ли в Inno опция (в идеале ключ в командной строке), с помощью которой можно было бы выключать компьютер после завершения процесса компиляции. Или, хотя бы, как сделать так, чтобы после завершения компиляции завершался и сам процесс.</TD><TD>Создай батник примерно такого содержания:<P><DD><B>compil32 /cc "c:\isetup\samples\my script.iss" <DD>shutdown -s -f -c "Compilation Finished"</B><P></P><DT>... и запускай на компиляцию через этот батник. Это параметры запуска для автоматической компиляции указанного скрипта. Подробнее смотри в хелпе, раздел Other Information - Command Line Compiler Execution.</DT><TR><TD>Можно ли сделать что-то типа trial ограничения на дистрибутив? Т.е. до определённой даты можно запустить инсталляцию, а после уже нет.</TD><TD>Есть функция <B>GetDateTimeString()</B> - вот ее вызываем в initializesetup и проверяем, что там тебе надо.<TR><TD>Для моего дистрибутива надо, чтобы конечная папка именовалась EARTH 2160. Может, кто подскажет, как это форсировать.</TD><TD>DefaultDirName={pf} просто так оставь в секции <FONT color=red>[Setup]</FONT>, а на всех файлах и папках в секции <FONT color=red>[Files]</FONT> ставь {app}\Earth2160<P><DD><FONT color=red>[Files]</FONT> <DD>Source: files.exe; DestDir: {app}\earth2160</DD><TR><TD>Знаю, что ограничение стоит на 2Гб, но, может, есть какой-нибудь способ обойти это?</TD><TD><DD>DiskSpanning=yes <DD>SlicesPerDisk=1 <DD>DiskSliceSize=728760320</DD><TR><TD>Мне нужно на три установленные программы (все три запихнуть в один инсталл) разместить ярлыки по разным местам- на одну программу Ярлык повесить в автозагрузку, а на две другие- просто на рабочий стол.</TD><TD>Можно сделать по-разному, например, так: <DT>В отдельной папке создаем файл скрипта, рядом с ним создаем папку files, внутри папки files запишем папки со своими прогами, скомпиленный exe будет лежать в папке Output.<P></P><DT>А можно просто указать реальные пути Source в секции <FONT color=red>[Files]</FONT>. <DD><FONT color=red>[Setup]</FONT> <DD>AppName=SomePrograms <DD>AppVerName=SomePrograms 1.0 <DD>DefaultDirName={pf}\SomePrograms <DD>OutputBaseFilename=SomePrograms <DD>Compression=lzma/ultra <DD>InternalCompressLevel=ultra <DD>SolidCompression=yes <DD>DisableReadyPage=yes <DD>ShowLanguageDialog=no<P></P><DD><FONT color=red>[Languages]</FONT> <DD>Name: en; MessagesFile: compiler:Default.isl <DD>Name: ru; MessagesFile: compiler:Languages\Russian.isl<P></P><DD><FONT color=red>[CustomMessages]</FONT> <DD>en.CreateGroupIcons=Create &amp;Program icons <DD>ru.CreateGroupIcons=Создать значки в Главном меню<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: files\program1\*; DestDir: {app}\program1; Flags: ignoreversion recursesubdirs <DD>Source: files\program2\*; DestDir: {app}\program2; Flags: ignoreversion recursesubdirs <DD>Source: files\program3\*; DestDir: {app}\program3; Flags: ignoreversion recursesubdirs<P></P><DD><FONT color=red>[Icons]</FONT> <DD>Name: {userdesktop}\Program1; Filename: {app}\program1\program1.exe; Tasks: desktopicon <DD>Name: {userdesktop}\Program2; Filename: {app}\program2\program2.exe; Tasks: desktopicon <DD>Name: {userstartup}\Program3; Filename: {app}\program3\program3.exe; Tasks: startup<P></P><DD><FONT color=green>;И по желанию можно добавить ярлыки в Главное меню</FONT> <DD><FONT color=green>;Name: {userprograms}\Program1; Filename: {app}\program1\program1.exe; Tasks: programs</FONT> <DD><FONT color=green>;Name: {userprograms}\Program2; Filename: {app}\program2\program2.exe; Tasks: programs</FONT> <DD><FONT color=green>;Name: {userprograms}\Program2; Filename: {app}\program3\program3.exe; Tasks: programs</FONT><P></P><DD><FONT color=red>[Tasks]</FONT> <DD>Name: programs; Description: {cm:CreateGroupIcons}; GroupDescription: {cm:AdditionalIcons} <DD>Name: desktopicon; Description: {cm:CreateDesktopIcon}; GroupDescription: {cm:AdditionalIcons} <DD>Name: startup; Description: {cm:CreateQuickLaunchIcon}; GroupDescription: {cm:AdditionalIcons}</DD><TR><TD>Как сделать шифрование инсталлятора? А то скачал файл ISCrypt.dll, а как его использовать не знаю...</TD><TD>1. Файл ISCrypt.dll копируешь в каталог Inno Setup <DT>2. В секцию <FONT color=red>[Setup]</FONT> добавляешь: <DD><FONT color=red>[Setup]</FONT> <DD>Encryption=yes <DD>Password=12345 <DT>Всё, после компиляции инсталлятор будет зашифрован.</DT><TR><TD>Шифровка инсталлятора, используя модуль ISCrypt.dll</TD><TD>Представляю свое решение по шифровке инсталлятора, используя модуль ISCrypt.dll, который доступен для скачивания на оф.сайте. Нужно это для того, чтобы обычный пользователь не смог распаковать инсталлятор посредством распаковщика unnounpacker. Смысл такой: задаем пароль для инсталлятора, который автоматически вставляется в поле ввода и посредством специальной функции сама страница нажимается автоматически. Как это делается: <DD><FONT color=red>[Setup]</FONT> <DD><FONT color=green>;Модуль ISCrypt.dll должен быть в папке с компилятором</FONT> <DD>Encryption=yes <DD><FONT color=green>;Пароль сами устанавливаем такой, чтобы никто его не смог подобрать, желательно добавить русские символы и сделать пароль подлиннее</FONT> <DD>Password=xcvcxhv9-8--fhрлджэ\5(*&amp;Y&amp;&amp;^^()U###$%!^&amp;!^%#^(UJ&lt;:LKJJHGG<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>var <DD><FONT color=green>//Определяем поле ввода пароля</FONT> <DD>PasswordEdit: TPasswordEdit; <DD>begin <DD><FONT color=green>//Указываем наш пароль</FONT> <DD>WizardForm.PasswordEdit.Text := 'xcvcxhv9-8--fhрлджэ\5(*&amp;Y&amp;&amp;^^()U###$%!^&amp;!^%#^(UJ&lt;:LKJJHGG'; <DD>end;<P></P><DD><FONT color=green>//При установке юзер не поймает пароль по маске, который может быть расшифрован специальными утилитами.</FONT> <DD><FONT color=green>//Их у меня нет, но о них я слышал, хотя Inno Setup не позволяет копировать пароль по маске</FONT> <DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>If CurPageID=wpPassword then <DD>begin <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 513, 0, 0) <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 514, 0, 0) <DD>end; <DD>end;<P></P><DT>Имейте в виду, что шифруются только основные файлы. <DT>Кстати, открывал зашифрованный архив плагином для Total Commander и удалось извлечь файл CompiledCode.bin, в котором можно посмотреть пароль. Поэтому рекомендую использовать русские символы в пароле - их (пока) не понимает распаковщик, также, если дальнейшие версии распаковщика будут понимать русский язык - рекомендуется использовать в пароле спец-символы, "крякозябли", ASCII из nfo и т.п.</DT><TR><TD>Невзламываемый экзешник (скомпилировать из этого скрипта):</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DefaultGroupName=My Program <DD>Encryption=Yes <DD>Password=7T34Ue(rrT<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "MyProg.exe"; DestDir: "{app}"<P></P><DD><FONT color=red>[Code]</FONT> <DD>function ShouldSkipPage(PageID: Integer): Boolean; <DD>begin <DD>if PageID = wpPassword then Result:= True; <DD>end;</DD><TR><TD>Как добавить строчку, чтобы файлик из папки Windows прихватить и потом при инсталляции туда же его положить, это файл конфигурации программы...</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: {win}\files.dll; DestDir: {win}; Flags: ignoreversion</DD><TR><TD>Можно ли сделать, чтобы один файл запуска,(setup), а файлы для установки с CDROM были набором, не упакованные.</TD><TD>Юзай флаг <B>external</B> в секции <FONT color=red>[Files]</FONT> - смотри руководство.<TR><TD>Внешние файлы, не включаемые в упакованный дистрибутив</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: "{src}\data\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs external;<P></P><DD>В папке data у нас будет находиться, например, полностью распакованная игра на DVD. При создании инсталлятора распакованные файлы игры не будут включаться в дистрибутив, что позволит создать инсталлятор очень быстро. Флаг <B>external</B> указывает инсталлятору искать внешние файлы для копирования. В сам же инсталлятор по усмотрению и по желанию можем добавить и установку компонентов подобным образом, а также внесение требуемых и/или желаемых данных в реестр, фоновое изображение, проигрывание музыки и прочее. Если хотите копирование жестко привязать к диску, то используйте константу <B>{drive:{src}}</B>. При использовании данной константы путь будет взят исключительно из того диска, откуда запущен инсталлятор, а при использовании обычной <B>{src}</B> путь будет взят из директории, где находится инсталлятор (то, что надо во многих случаях). Такой способ интересен и иногда актуален, когда архивы игры не сжимаются или сжимаются незначительно. Также при должном желании можем установить проверки на присутствие определенных файлов для того, чтобы инсталлятор не позволил копирование при их отсутствии.</DD><TR><TD>Скрипт для распаковки 7z sfx-архива</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: "sfx.exe"; DestDir: "{app}"; AfterInstall: MyAfterInstall; Flags: ignoreversion deleteafterinstall<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure MyAfterInstall(); <DD>var <DD>ResultCode: Integer; <DD>begin <DD>begin <DD>Exec(ExpandConstant('{app}\sfx.exe'), '-e -aoa -y', '', SW_SHOWNORMAL, ewWaitUntilTerminated, ResultCode); <DD>end <DD>end;</DD><TR><TD>Примеры составления следующей конструкции: <DT>1)setup.exe (сделанный на inno setup) <DT>2)DATARUS.EXE (сделанный с помощью 7-zip) <DT>И расположен sfx архив не внутри, а снаружи.</DT></TD><TD><DD><FONT color=red>[Components]</FONT> <DD>Name: "eng"; Description: "Английская версия"; Flags: exclusive <DD>Name: "rus"; Description: "Русская версия"; Flags: exclusive<P></P><DD><FONT color=red>[Types]</FONT> <DD>Name: "custom"; Description: "Выборочная установка"; Flags: iscustom<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "D:\NFS - Most Wanted\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs <DD>Components: rus; Source: "{src}\Rus\NFSMWRUS.exe"; DestDir: "{app}"; Flags: ignoreversion external deleteafterinstall<P></P><DD><FONT color=red>[Run]</FONT> <DD>Filename: "{app}\NFSMWRUS.exe"; WorkingDir: "{app}"; Parameters: "-y"; StatusMsg: "Процесс руссификации..."; Flags: waituntilterminated skipifdoesntexist<P></P><DT>---- <DT><B>new.exe -x -y -o C:\TEMP</B> - распакует архив в C:\TEMP без лишних вопросов. <DT>Отдельные извращенцы могут использовать команду SUBST.<P></P><DT>---<P></P><DD><FONT color=red>[Run]</FONT> <DD>Filename: "{src}\GAME\NFSMW.exe"; WorkingDir: "{src}\GAME"; Parameters: "-y -o""{app}"""; Flags: waituntilterminated<P></P><DT>Следовательно, передаем архиву путь для распаковки, выбранный при установке, причем с параметром <B>-y</B>, который, как должно быть известно, отвечает за "тихую" установку, т.е. по умолчанию распаковывает и перезаписывает файлы без запроса. Как показано на примере, файл sfx-архива должен содержать, например, все файлы игры. Причем в секции <FONT color=red>[Files]</FONT> этот архив указывать не нужно, можно вообще эту секцию не указывать в скрипте, хотя если вы юзаете дополнительные файлы (руссификация, требуемые системные библиотеки и др.), то их как обычно нужно указать в секции <FONT color=red>[Files]</FONT>. С одной стороны, очень даже неплохая реализация установки, 7-zip, признаться, хоть на чуток, но лучше сжимает, чем Inno.<P>Есть приличные руссификаторы на ZoneOfGames. Так вот, не надо пытаться вскрывать технологию упаковки и процесса руссификации. Инсталляторы защищены от распаковки автораспаковщиком, и глюков при установке и удалении руссификатора не наблюдается. И зачем нам перепаковывать файлы оригинальной руссификации, если их и так можно установить, при этом все копирайты сохраняются:<P></P><DD><FONT color=red>[Run]</FONT> <DD>Filename: "{src}\Rus\NfSCarbon.exe"; WorkingDir: "{src}\Rus"; Parameters: "/silent /nocancel /DIR=""{app}"""; Flags: waituntilterminated skipifdoesntexist<P>В этом случае будет произведена тихая установка руссификации с сохранением резервных копий англоязычных файлов, причем с возможностью их обратного восстановления. Не забываем указать флаг <B>skipifdoesntexist</B>, если запускаемый файл является "выбираемым" при установке. Конечно, лучше реализовать это через секцию <FONT color=red>[Code]</FONT>, в которой можно указать запуск руссификатора в зависимости от выбранных компонентов, а также создать дополнительный ярлык для удаления руссификации отдельно. Но есть одна проблема...<P>Все вышеописанное с многочисленными параметрами реализовать в секции <FONT color=red>[Code]</FONT> у меня пока не получилось, если вообще возможно, загвоздку составляют параметры. Как известно, в секции <FONT color=red>[Code]</FONT> константа <B>{app}</B> имеет вид: <B>ExpandConstant('{app}')</B>. Сильно не экспериментировал, но не получается передать путь для распаковки таким образом, компилятор выдает ошибки, или распаковывает в неверную папку.</P></DD><TR><TD>В предыдущем случае было реализовано через секцию <FONT color=red>[Code]</FONT>, здесь - через секцию <FONT color=red>[Run]</FONT>:</TD><TD>В секции <FONT color=red>[Run]</FONT> это тоже можно реализовать, используя параметр <B>Components</B>. Например: <DD><FONT color=red>[Types]</FONT> <DD>Name: "full"; Description: "Full installation" <DD>Name: "compact"; Description: "Compact installation" <DD>Name: "custom"; Description: "Custom installation"; Flags: iscustom<P></P><DD><FONT color=red>[Components]</FONT> <DD>Name: "program"; Description: "Program Files"; Types: full compact custom; Flags: fixed <DD>Name: "help"; Description: "Help File"; Types: full <DD>Name: "readme"; Description: "Readme File"; Types: full <DD>Name: "readme\en"; Description: "English"; Flags: exclusive <DD>Name: "readme\ru"; Description: "Russian"; Flags: exclusive<P></P><DD><FONT color=red>[Run]</FONT> <DD>Filename: "{src}\Rus\NfSCarbon.exe"; WorkingDir: "{src}\Rus"; Parameters: "/silent /nocancel /DIR=""{app}"""; Components: readme\ru; Flags: waituntilterminated skipifdoesntexist</DD><TR><TD>Как в инсталляторе сделать самораспаковку 7z SFX, секция run не подходит. Нужно, чтобы инсталлятор скопировал самораспаковку, распаковал, удалил её, и только после этого дораспаковывал остальные файлы.</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Archive.exe; DestDir: {app}; AfterInstall: Unpack(); Flags: ignoreversion <DD>Source: Files\*; DestDir: {app}<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure Unpack(); <DD>var <DD>ResultCode: Integer; <DD>begin <DD>Exec(ExpandConstant('{app}\Archive.exe'), '', '', SW_HIDE, ewWaitUntilTerminated, ResultCode); <DD>DeleteFile(ExpandConstant('{app}\Archive.exe')); <DD>end;</DD><TR><TD>Как сделать, чтобы инсталлятор при запуске проверял наличие NET FrameWork и если его не находит, то выводит сообщение типа "NET FrameWork не найден! Продолжить установку?" и кнопки "Да" и "Нет"? <DT>#Include не предлагать...</DT></TD><TD><DD>function InitializeSetup(): Boolean; <DD>begin <DD>Result:=True; <DD>begin <DD>if not RegKeyExists(HKLM, 'SOFTWARE\Microsoft\NET Framework Setup\NDP\v1.1.4322') <DD>or not RegKeyExists(HKLM, 'SOFTWARE\Microsoft\NET Framework Setup\NDP\v2.0.50727') <DD>then <DD>begin <DD>if MsgBox('Attention! On your computer is not found required packages of Microsoft .NET Framework 1.1 or Microsoft .NET Framework 2.0 or both their.'#13#13'Do you want to continue?', mbError, MB_YESNO) = idNo <DD>then <DD>Result:=False; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Надо сделать на странице выбора директории кнопочку "Сброс". Смысл её таков: путь установки по умолчанию, скажем, такой C:\My Company\My Program, а пользователя, допустим, он не устраивает и он выбирает такой путь D:\My Company\My Program, но потом вдруг передумывает и решает всё-таки использовать первоначальный путь. Так вот, чтобы ему самому ничего не пришлось менять и пригодилась бы кнопочка "Сброс". Нажимаешь на неё, и она возвращает путь по умолчанию.</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app}<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>RestoreDir: TButton;<P></P><DD>procedure ButtonOnClick(Sender: TObject); <DD>begin <DD>WizardForm.DirEdit.Text:= ExpandConstant('{pf}\My Program'); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>RestoreDir:= TButton.Create(WizardForm); <DD>RestoreDir.Width := WizardForm.DirBrowseButton.Width; <DD>RestoreDir.Height := WizardForm.DirBrowseButton.Height; <DD>RestoreDir.Top := WizardForm.DirBrowseButton.Top + RestoreDir.Height + ScaleX(10); <DD>RestoreDir.Left := WizardForm.DirBrowseButton.Left; <DD>RestoreDir.OnClick := @ButtonOnClick; <DD>RestoreDir.Parent := WizardForm.SelectDirPage; <DD>RestoreDir.Visible:= True; <DD>RestoreDir.Caption := 'Restore Path'; <DD>end;</DD><TR><TD>Закрытие окна без предупреждения и проверка на присутствие файла</TD><TD><DD>function NextButtonClick(CurPage: Integer): Boolean; <DD>var <DD>sz:Integer; <DD>s:string; <DD>h:Longint; <DD>begin <DD>Result:=True; <DD>If CurPage=1 <DD>then <DD>begin <DD>h:=FindWindowByClassName('My-Program-WINDOW'); <DD>If h&lt;&gt;0 then <DD>SendMessage(h, 16, 0, 0); <FONT color=green>//Вот это и есть закрытие программы</FONT> <DD>end <DD>else <DD>If CurPage=6 then <DD><FONT color=green>//Проверка присутствия определенных файлов в папке с установленной программой на странице выбора папки назначения</FONT> <DD>begin <DD>If (FileSearch('Main.exe', ExpandConstant('{app}'))='') <FONT color=green>//ищем файл [Main.exe] в папке {app}.</FONT> <DD>then <DD>begin <DD>s:='Извините, в директории '+ExpandConstant('{app}')+'' #13 'не обнаружены файлы, подтверждающие подлинность программы.' #13#13 'Пожалуйста, выберите правильный путь для установки обновления.'; <DD>MsgBox(s, mbError, mb_Ok); <DD>Result:= False <DD>end; <DD>end; <DD>end;</DD><TR><TD>У меня есть программа: му.ехе. Я её хочу обновить при помощи инсталлятора, т.е. у меня в инсталляторе содержится новая версия му.ехе. Если я её распакую, когда старая запущена, то прога не обновится, типа, невозможно переписать файл. Вот я и хочу, чтобы инсталлятор при запуске проверял, открыта ли прога му.ехе, и если открыта, то выдавать предупреждение, типа, программа сейчас работает, необходимо закрыть её перед обновлением. Закрыть? Да\Нет.</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DefaultGroupName=My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: ISTask.dll; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>function KillTask(ExeFileName: string): Integer; <DD>external 'KillTask@files:ISTask.dll stdcall delayload'; <DD>function RunTask(FileName: string; bFullpath: Boolean): Boolean; <DD>external 'RunTask@files:ISTask.dll stdcall delayload';<P></P><DD><FONT color=green>//**************************************************//</FONT> <DD>function InitializeSetup(): Boolean; <DD>begin <DD>If RunTask('calc.exe', false) then <DD>begin <DD>if MsgBox('Close My Program?', mbInformation, mb_YesNo) = idYes then <DD>begin <DD>KillTask('calc.exe'); <DD>Result:= True; <DD>end else <DD>Exit; <DD>end; <DD>Result:=True; <DD>end;</DD><TR><TD>Как создать резервную копию во время установки, и кнопку перед установкой "Создать резервную копию оригинальных файлов" с галочкой?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>Compression=lzma <DD>SolidCompression=yes <DD>Uninstallable=no<P></P><DD><FONT color=red>[Tasks]</FONT> <DD>Name: arc; Description: "Create backup"<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; BeforeInstall: CreateBackup<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Page: TInputDirWizardPage; <DD>ArcDir: String;<P></P><DD>procedure CreateBackup(); <DD>var <DD>SrcFile, DestFile: string; <DD>begin <DD>if IsTaskSelected('arc') then <DD>begin <DD><FONT color=green>// if Not DirExists(ArcDir) then CreateDir(ArcDir);</FONT> <DD>ForceDirectories(ArcDir); <FONT color=green>// исправлено</FONT> <DD>SrcFile:= AddBackslash(ExpandConstant('{app}')) + ExtractFileName(CurrentFileName); <DD>DestFile:= AddBackslash(ArcDir) + ExtractFileName(CurrentFileName); <DD>FileCopy(SrcFile, DestFile, False); <DD>end; <DD>end;<P></P><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>begin <DD>If (CurPageID = Page.ID) then <DD>ArcDir := Page.Values[0]; <DD>Result:= True; <DD>end;<P></P><DD>function ShouldSkipPage(PageID: Integer): Boolean; <DD>begin <DD>If (PageID = Page.ID) and <DD>(Not IsTaskSelected('arc')) then <DD>Result:= True <DD>else Result:= False; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>Page:= CreateInputDirPage(wpSelectTasks, 'Select Backup Location', <DD>'Where should backup files be stored?', <DD>'To continue, click Next.' + #10#13#10#13 + <DD>'If you would like to select a different folder, click Browse.', <DD>False, 'Backup'); <DD>Page.Add(''); <DD><FONT color=green>//Page.Values[0] := ExpandConstant('{sd}\Backup');</FONT> <DD>Page.Values[0] := AddBackslash(ExpandConstant('{sd}\Backup')) + <DD>GetDateTimeString('yyyy/mm/dd hh:nn', '_', '.' ); <FONT color=green>// исправлено</FONT> <DD>end;</DD><TR><TD>Мне надо, чтобы инсталлятор заменил оригинальный файл (например, myprog1.exe) на такой же, но только обновленный, и во время установки в директории программы была сразу создана папка "Backup_Files" (т.е. у пользователя инсталлятор не должен спрашивать ни название папки, ни где размещать ее, а нужно, чтобы инсталлятор создавал все сам автоматически).</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>Compression=lzma <DD>SolidCompression=yes <DD>Uninstallable=no<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; BeforeInstall: CreateBackup<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>ArcDir: String;<P></P><DD>procedure CreateBackup(); <DD>var <DD>SrcFile, DestFile: string; <DD>begin <DD>ArcDir:= AddBackslash(ExpandConstant('{app}\Backup')) + <DD>GetDateTimeString('yyyy/mm/dd hh:nn', '_', '.' ); <DD>ForceDirectories(ArcDir); <DD>SrcFile:= AddBackslash(ExpandConstant('{app}')) + ExtractFileName(CurrentFileName); <DD>DestFile:= AddBackslash(ArcDir) + ExtractFileName(CurrentFileName); <DD>FileCopy(SrcFile, DestFile, False); <DD>end;<P></P><DT>--- <DT>Кусочек еще одного скрипта на эту тему:<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "{app}\Some.file"; DestDir: "{app}\Backup_Files"; Flags: uninsneveruninstall skipifsourcedoesntexist overwritereadonly ignoreversion external;</DD><TR><TD>Как сделать, чтобы при перезаписи оригинальных файлов создавались их резервные копии?</TD><TD><DD><FONT color=red>[Components]</FONT> <DD>Name: "Backup"; Description: "Backup"; Types: full<P></P><DD><FONT color=red>[Files]</FONT> <DD>Components: Backup; Source: "MyProg.exe"; DestDir: "{app}"; Flags: ignoreversion; Check: MyProgCheck<P></P><DD><FONT color=red>[Code]</FONT> <DD>function MyProgCheck():boolean; <DD>var <DD>s1, s2:string; <DD>begin <DD>Result:=True; <DD>s1:=ExpandConstant('{app}')+'\MyProg.exe'; <DD>s2:=ExpandConstant('{app}')+'\Backup'; <DD>If FileExists(s1) then <DD>begin <DD>CreateDir(s2); <DD>FileCopy(s1, s2+'\MyProg.exe', False); <DD>end; <DD>end;</DD><TR><TD>Создание резервной копии</TD><TD><DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>begin <DD>if IsTaskSelected('backup') then <DD>if CurStep = ssInstall then <DD>begin <DD>CopyFiles(ExpandConstant('{app}\Data\'),ExpandConstant('{app}\Backup'),('movies000.dat')); <DD>end; <DD>end;<P></P><DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if CurUninstallStep = usPostUninstall then <DD>begin <DD>MoveFiles(ExpandConstant('{app}\Backup\'),ExpandConstant('{app}\Data\'),('movies000.dat')); <DD>RemoveDir(ExpandConstant('{app}\Backup')); <DD>end; <DD>end;</DD><TR><TD>Пример скрипта, автоматически создающего бэкапы в папки с именем по дате/времени. Кол-во бэкапов задается в скрипте. При превышении кол-ва, самые старые будут удалены.</TD><TD><DD>#define MaxBackup 3<P></P><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>Compression=lzma <DD>SolidCompression=yes <DD>Uninstallable=no<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; BeforeInstall: CreateBackup<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>ArcDir: String; <DD>DirNames: TStringList;<P></P><DD>procedure CreateBackup(); <DD>var <DD>SrcFile, DestFile: string; <DD>begin <DD>ArcDir:= AddBackslash(ExpandConstant('{app}\Backup')) + <DD>GetDateTimeString('yyyy/mm/dd hh:nn', '_', '.' ); <DD>ForceDirectories(ArcDir); <DD>SrcFile:= AddBackslash(ExpandConstant('{app}')) + ExtractFileName(CurrentFileName); <DD>DestFile:= AddBackslash(ArcDir) + ExtractFileName(CurrentFileName); <DD>FileCopy(SrcFile, DestFile, False); <DD>end;<P></P><DD>procedure GetBackupCount(); <DD>var <DD>FindRec: TFindRec; <DD>begin <DD>if FindFirst(ExpandConstant('{app}\Backup\*'), FindRec) then begin <DD>try <DD>DirNames:= TStringList.Create(); <DD>DirNames.Sorted:= True; <DD>repeat <DD>if (FindRec.Attributes = FILE_ATTRIBUTE_DIRECTORY) and <DD>(FindRec.Name &lt;&gt; '.') and (FindRec.Name &lt;&gt; '..') then <DD>begin <DD>DirNames.Append(FindRec.Name); <DD>end; <DD>until not FindNext(FindRec); <DD>finally <DD>FindClose(FindRec); <DD>end; <DD>end; <DD>end;<P></P><DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>var <DD>i: integer; <DD>begin <DD>if CurStep = ssInstall then <DD>begin <DD>GetBackupCount(); <DD>if DirNames.Count &gt;= StrToInt(ExpandConstant('{#MaxBackup}')) then <DD>begin <DD>for i:= DirNames.Count - StrToInt(ExpandConstant('{#MaxBackup}')) downto 0 do <DD>begin <DD>DelTree(ExpandConstant('{app}\Backup\') + DirNames[i], True, True, True); <DD>end; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Как сделать копию файла, к имени которого необходимо добавить дату и время создания копии?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app}; BeforeInstall: CreateBackup()<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure CreateBackup(); <DD>begin <DD>if FileExists(ExpandConstant(CurrentFileName)) then <DD>FileCopy(ExpandConstant(CurrentFileName), <DD>ExpandConstant('{app}\') + <DD>GetDateTimeString('dd/mm/yyyy hh:nn:ss ', '-', '-') + <DD>ExtractFileName(ExpandConstant(CurrentFileName)), True) <DD>end;</DD><TR><TD>Проблема заключается в том, что после удаления, файлы из папки "Install_Rus\Backup" перемещаются обратно. Это ВСЕ правильно, НО также после удаления ОСТАЮТСЯ эти папки "Install_Rus\Backup", при том, что еще в папке "Backup" остается и оригинальный файл, а мне бы хотелось, чтобы этих папок НЕ было (Install_Rus\Backup\Some_name.exe) после удаления.</TD><TD><DD>DeleteFile(ExpandConstant('{app}')+'\Install_Rus\Backup\Some_name.exe') <DD>RemoveDir(ExpandConstant('{app}')+'\Install_Rus\Backup') <DD>RemoveDir(ExpandConstant('{app}')+'\Install_Rus)<P></P><DT>--- <DT>А в чем проблема? Помимо функции в SHFileOperation.iss, Inno имеет несколько встроенных функций для удаления папок. Например: <DD>#include "SHFileOperation.iss"<P></P><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; Flags: ignoreversion recursesubdirs<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>begin <DD>if CurStep = ssInstall then <DD>begin <DD>CopyDir(ExpandConstant('{app}\'),ExpandConstant('{app}\Backup')); <DD><FONT color=green>// или</FONT> <DD><FONT color=green>// MoveDir(ExpandConstant('{app}\'),ExpandConstant('{app}\Backup'));</FONT> <DD>end; <DD>end;<P></P><DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if CurUninstallStep = usPostUninstall then <DD>begin <DD>MoveDir(ExpandConstant('{app}\Backup\'),ExpandConstant('{app}')); <DD><FONT color=green>// RemoveDir удалит только, если папка пустая</FONT> <DD>RemoveDir(ExpandConstant('{app}\Backup')); <DD><FONT color=green>// DelTree использовать не рекомендуется,</FONT> <DD><FONT color=green>// так как будут удалены все вложенные папки!</FONT> <DD><FONT color=green>// DelTree(ExpandConstant('{app}\Backup'), True, True, True);</FONT> <DD>end; <DD>end;</DD><TR><TD>Возможность копирования\перемещения ФАЙЛОВ</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: "{app}\SomeFile_1.file"; DestDir: "{app}\Backup"; Flags: uninsneveruninstall skipifsourcedoesntexist overwritereadonly ignoreversion external; BeforeInstall: HideInstallPath; <DD>Source: "{app}\SomeFile_2.file"; DestDir: "{app}\Backup"; Flags: uninsneveruninstall skipifsourcedoesntexist overwritereadonly ignoreversion external; AfterInstall: ShowInstallPath;<P></P><DD><FONT color=red>[Messages]</FONT> <DD>StatusExtractFiles=Создание конфигурационных файлов...<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.FileNameLabel.Visible:= False; <DD>end;</DD><TR><TD>В этом скрипте при инсталляции в бэкап сохраняются (перемещением) только те файлы, которые инсталлятор заменяет. При удалении, эти же файлы восстанавливаются (тоже перемещением). <DT>Хотя лично мне, перемещение файлов при бэкапе не очень нравится. Да, так быстрее (особенно если файлы большие). Но если в процессе инсталляции что-то рухнет, то есть риск потерять один или несколько файлов.</DT></TD><TD><DD>#include "SHFileOperation.iss"<P></P><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; Flags: ignoreversion recursesubdirs; BeforeInstall: CreateBackup<P></P><DD><FONT color=red>[Code]</FONT> <DD>function MoveFile(const srcFile, destFile: PChar):Integer; <DD>external 'MoveFileA@kernel32.dll stdcall';<P></P><DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if CurUninstallStep = usPostUninstall then <DD>begin <DD>MoveDir(ExpandConstant('{app}\Backup\'),ExpandConstant('{app}')); <DD>RemoveDir(ExpandConstant('{app}\Backup\')); <DD>end; <DD>end;<P></P><DD>procedure CreateBackup; <DD>var <DD>srcFile, destFile: string; <DD>basePath, shortPath: string; <DD>begin <DD>basePath:= ExpandConstant('{app}'); <DD>srcFile:= ExpandConstant(CurrentFileName); <DD>shortPath:= srcFile; <DD>StringChangeEx(shortPath, basePath, '', True); <DD>destFile:= ExpandConstant('{app}\Backup') + shortPath; <DD>ForceDirectories(ExtractFilePath(destFile)); <DD>MoveFile(PChar(srcFile), PChar(destFile)); <DD>end;</DD><TR><TD>А можно ли сделать, чтобы файлы никуда не перемещались, а переименовались? Например, в MyProg.exe.bak</TD><TD>Сохранять просто. Достаточно изменить процедуру CreateBackup : <DD>procedure CreateBackup; <DD>var <DD>srcFile, destFile: string; <DD>begin <DD>srcFile:= ExpandConstant(CurrentFileName); <DD>destFile:= srcFile + '.bak'; <DD>MoveFile(PChar(srcFile), PChar(destFile)); <DD>end;<P></P><DT>А вот для восстановления при деинсталляции, придется прописывать отдельную процедуру.</DT><TR><TD>Полный скрипт, в котором бэкап выполняется переименованием файлов (только тех, которые меняются) в *.bak, а при деинсталляции, файлы восстанавливаются обратным переименованием. Никаких проверок на корректность операций нет. Добавляй сам.</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; Flags: ignoreversion recursesubdirs; BeforeInstall: CreateBackup<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure CreateBackup; <DD>var <DD>srcFile, destFile: string; <DD>begin <DD>srcFile:= ExpandConstant(CurrentFileName); <DD>destFile:= srcFile + '.bak'; <DD>DeleteFile(destFile); <DD>RenameFile(srcFile, destFile); <DD>end;<P></P><DD>procedure RestoreBackup(backupDir: string); <DD>var <DD>srcFile, destFile: string; <DD>FSR, DSR: TFindRec; <DD>FindResult: Boolean; <DD>APath: string; <DD>begin <DD>APath := AddBackslash(backupDir); <DD>FindResult := FindFirst(APath + '*.bak', FSR); <DD>try <DD>while FindResult do <DD>begin <DD>if FSR.Attributes and FILE_ATTRIBUTE_DIRECTORY = 0 then <DD>begin <DD>srcFile:= APath + FSR.Name; <DD>destFile:= Copy(srcFile, 0, Length(srcFile)-4); <DD>DeleteFile(destFile); <DD>RenameFile(srcFile, destFile); <DD>end; <DD>FindResult := FindNext(FSR); <DD>end; <DD>FindResult := FindFirst(APath + '*.*', DSR); <DD>while FindResult do <DD>begin <DD>if ((DSR.Attributes and FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY) and <DD>not ((DSR.Name = '.') or (DSR.Name = '..')) then <DD>{Recursion} RestoreBackup(APath + DSR.Name); <DD>FindResult := FindNext(DSR); <DD>end; <DD>finally <DD>FindClose(FSR); <DD>FindClose(DSR); <DD>end; <DD>end;<P></P><DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if CurUninstallStep = usPostUninstall then <DD>begin <DD>RestoreBackup(ExpandConstant('{app}')) <DD>end; <DD>end;</DD><TR><TD>Как сделать, чтобы переименование файлов в ‘bak’, происходило только в том случае, если на странице доп. задачи (Tasks) пользователь отметил "Создать резервную копию оригинальных файлов"?</TD><TD><B>IsTaskSelected</B> (см.в хелпе)<TR><TD>В секции <FONT color=red>[Files]</FONT> прописан файл. В случае, если у пользователя такой файл есть, он переименовывается и ставится новый.</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: "{app}\my_program.exe"; DestDir: "{app}"; DestName: "my_program.exe.bak"; Flags: external skipifsourcedoesntexist <DD><FONT color=green>;Старый файл который будет переименован</FONT> <DD>Source: "C:\my_program.exe"; DestDir: "{app}"; Flags: ignoreversion <DD><FONT color=green>;Новый файл</FONT></DD><TR><TD>Как сделать, чтобы резервировался ini-файл (при отработке секции <FONT color=red>[INI]</FONT>)? Так как BeforeInstall: CreateBackup в данном случае не работает (при установке вылетает ошибка).</TD><TD>В этом варианте можно передавать имя файла как параметр: <DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[INI]</FONT> <DD>Filename: "{app}\MyProg.ini"; Section: "InstallSettings"; Flags: uninsdeletesection; BeforeInstall: CreateBackup('{app}\MyProg.ini') <DD>Filename: "{app}\MyProg.ini"; Section: "InstallSettings"; Key: "InstallPath"; String: "{app}"<P></P><DD>... <DD>procedure CreateBackup(filename: string); <DD>var <DD>srcFile, destFile: string; <DD>basePath, shortPath: string; <DD>begin <DD>basePath:= ExpandConstant('{app}'); <DD>srcFile:= ExpandConstant(filename); <DD>shortPath:= srcFile; <DD>StringChangeEx(shortPath, basePath, '', True); <DD>destFile:= ExpandConstant('{app}\Backup') + shortPath; <DD>ForceDirectories(ExtractFilePath(destFile)); <DD>FileCopy(PChar(srcFile), PChar(destFile), False); <DD>end;</DD><TR><TD>Вопрос по поводу перемещения папок (не копирования) средствами Inno Setup.</TD><TD>Как перемещать средствами Inno не знаю, но средствами самой операционки можно. <DT>Чуть ниже вставлен скрипт(SHFileOperation.iss), можно сохранить его в файл и этот файл включить в свой проект (директивой #include "SHFileOperation.iss"). <DT>После этого появится возможность использовать 4 функции: <DT>function CopyDir(const fromDir, toDir: string): Boolean; <DT>function MoveDir(const fromDir, toDir: string): Boolean; <DT>function DelDir(dir: string; toRecycle: Boolean): Boolean; <DT>function RenameDir(const fromDir, toDir: string): Boolean;<P></P><DT>В скрипте есть краткое описание, но хочу обратить внимание, что в функциях CopyDir и MoveDir есть зависимость от того, указана ли fromDir со слешом или без. В первом случае в toDir будет скопировано/перемещено только содержимое fromDir со всеми файлами у подпапками; во втором, в toDir будет скопирована/перемещена сама fromDir со всеми файлами и подпапками.<P></P><DT>DelDir может удалять совсем или в корзину (в зависимости от флага toRecycle). <DT>В случае, если кто-то удалит папку Windows, претензии не принимаются.<P></P><DT>Небольшой пример использования SHFileOperation.iss для бекапа:<P></P><DD>#include "SHFileOperation.iss"<P></P><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.*; DestDir: {app}; Flags: ignoreversion recursesubdirs<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure CurStepChanged(CurStep: TSetupStep); <DD>begin <DD>if CurStep = ssInstall then <DD>begin <DD>CopyDir(ExpandConstant('{app}\'),ExpandConstant('{app}\Backup')); <DD>end; <DD>end;<P></P><DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if CurUninstallStep = usPostUninstall then <DD>begin <DD>CopyDir(ExpandConstant('{app}\Backup\'),ExpandConstant('{app}')); <DD>end; <DD>end;<P></P><DT>Код (полный): <DT><FONT color=green>;***************************************************************; <DT>;****************** SHFileOperation.iss ************************; <DT>;***************************************************************; <DT>;* Include this file in project. Example: <DT>;* #include "SHFileOperation.iss" <DT>;***************************************************************; <DT>;************************ 1 ************************************; <DT>;* function CopyDir(const fromDir, toDir: string): Boolean; <DT>;* Example 1 (without &lt;<FONT color=blue>fromDir</FONT>&gt; trailing backslash): <DT>;* CopyDir('C:\TMP\MyApp', 'C:\TMP\Backup'); <DT>;* Result: C:\TMP\Backup\MyApp\..all &lt;<FONT color=blue>MyApp</FONT>&gt; subdirs and files <DT>;* Example 2 (with &lt;<FONT color=blue>fromDir</FONT>&gt; trailing backslash): <DT>;* CopyDir('C:\TMP\MyApp\', 'C:\TMP\Backup'); <DT>;* Result: C:\TMP\Backup\..all &lt;<FONT color=blue>MyApp</FONT>&gt; subdirs and files <DT>;***************************************************************; <DT>;************************ 2 ************************************; <DT>;* function MoveDir(const fromDir, toDir: string): Boolean; <DT>;* Example 1 (without &lt;<FONT color=blue>fromDir</FONT>&gt; trailing backslash): <DT>;* MoveDir('C:\TMP\MyApp', 'C:\TMP\Backup'); <DT>;* Result: C:\TMP\Backup\MyApp\..all &lt;<FONT color=blue>MyApp</FONT>&gt; subdirs and files <DT>;* Example 2 (with &lt;<FONT color=blue>fromDir</FONT>&gt; trailing backslash): <DT>;* MoveDir('C:\TMP\MyApp\', 'C:\TMP\Backup'); <DT>;* Result: C:\TMP\Backup\..all &lt;<FONT color=blue>MyApp</FONT>&gt; subdirs and files <DT>;***************************************************************; <DT>;************************ 3 ************************************; <DT>;* function DelDir(dir: string; toRecycle: Boolean): Boolean; <DT>;* If &lt;<FONT color=blue>toRecycle</FONT>&gt; is True, &lt;<FONT color=blue>dir</FONT>&gt; deleted in Recycle Bin. <DT>;***************************************************************; <DT>;************************ 4 ************************************; <DT>;* function RenameDir(const fromDir, toDir: string): Boolean; <DT>;***************************************************************; <DT>;***************************************************************; <DT>;***************************************************************;</FONT><P></P><DD><FONT color=red>[Code]</FONT> <DD>type <DD>TSHFileOpStruct = record <DD>Wnd: HWND; <DD>wFunc: UINT; <DD>pFrom: PChar; <DD>pTo: PChar; <DD>fFlags: Word; <FONT color=green>// FILEOP_FLAGS;</FONT> <DD>fAnyOperationsAborted: BOOL; <DD>hNameMappings: HWND; <FONT color=green>// Pointer;</FONT> <DD>lpszProgressTitle: PChar; <FONT color=green>{ only used if FOF_SIMPLEPROGRESS }</FONT> <DD>end;<P></P><DD>const <DD><FONT color=green>// use in wFunc</FONT> <DD>{ $EXTERNALSYM FO_MOVE } <DD>FO_MOVE = $0001; <DD>{ $EXTERNALSYM FO_COPY } <DD>FO_COPY = $0002; <DD>{ $EXTERNALSYM FO_DELETE } <DD>FO_DELETE = $0003; <DD>{ $EXTERNALSYM FO_RENAME } <DD>FO_RENAME = $0004; <DD><FONT color=green>// use in fFlags</FONT> <DD>{ $EXTERNALSYM FOF_MULTIDESTFILES } <DD>FOF_MULTIDESTFILES = $0001; <DD>{ $EXTERNALSYM FOF_CONFIRMMOUSE } <DD>FOF_CONFIRMMOUSE = $0002; <DD>{ $EXTERNALSYM FOF_SILENT } <DD>FOF_SILENT = $0004; <FONT color=green>{ don't create progress/report }</FONT> <DD>{ $EXTERNALSYM FOF_RENAMEONCOLLISION } <DD>FOF_RENAMEONCOLLISION = $0008; <DD>{ $EXTERNALSYM FOF_NOCONFIRMATION } <DD>FOF_NOCONFIRMATION = $0010; <FONT color=green>{ Don't prompt the user. }</FONT> <DD>{ $EXTERNALSYM FOF_WANTMAPPINGHANDLE } <DD>FOF_WANTMAPPINGHANDLE = $0020; <FONT color=green>{ Fill in <DD>SHFILEOPSTRUCT.hNameMappings <DD>Must be freed using <DD>SHFreeNameMappings }</FONT> <DD>{ $EXTERNALSYM FOF_ALLOWUNDO } <DD>FOF_ALLOWUNDO = $0040; <DD>{ $EXTERNALSYM FOF_FILESONLY } <DD>FOF_FILESONLY = $0080; <FONT color=green>{ on *.*, do only files }</FONT> <DD>{ $EXTERNALSYM FOF_SIMPLEPROGRESS } <DD>FOF_SIMPLEPROGRESS = $0100; <FONT color=green>{ means don't show names of files }</FONT> <DD>{ $EXTERNALSYM FOF_NOCONFIRMMKDIR } <DD>FOF_NOCONFIRMMKDIR = $0200; <FONT color=green>{ don't confirm making any <DD>needed dirs }</FONT> <DD>{ $EXTERNALSYM FOF_NOERRORUI } <DD>FOF_NOERRORUI = $0400; <FONT color=green>{ don't put up error UI }</FONT><P></P><DD>function SHFileOperation(const lpFileOp: TSHFileOpStruct):Integer; <DD>external 'SHFileOperation@shell32.dll stdcall';<P></P><DD><FONT color=green>{****************************************************************}</FONT> <DD><FONT color=green>{****************************************************************}</FONT> <DD><FONT color=green>{****************************************************************}</FONT><P></P><DD>function BackupDir(const fromDir, toDir: string; IsMove: Boolean): Boolean; <DD>var <DD>fos: TSHFileOpStruct; <DD>_fromDir, _toDir: string; <DD>SR: TFindRec; <DD>res: Boolean; <DD>begin <DD>ForceDirectories(toDir); <DD>if IsMove then <DD>fos.wFunc := FO_MOVE else <DD>fos.wFunc := FO_COPY; <DD>fos.fFlags := FOF_FILESONLY or FOF_SILENT or <DD>FOF_NOCONFIRMATION or FOF_NOCONFIRMMKDIR; <DD>_fromDir:= AddBackslash(fromDir); <DD>_toDir := AddBackslash(toDir); <DD>if (Length(fromDir) = Length(_fromDir)) then <DD>begin <DD>res:= FindFirst(_fromDir + '*', SR); <DD>try <DD>while res do <DD>begin <DD>if (SR.Name &lt;&gt; '') and (SR.Name &lt;&gt; '.') and (SR.Name &lt;&gt; '..') then <DD>begin <DD>if SR.Attributes = FILE_ATTRIBUTE_DIRECTORY then <DD>begin <DD>_fromDir:= _fromDir + SR.Name + #0#0; <DD>_toDir := _toDir + #0#0; <DD>fos.pFrom := PChar(_fromDir); <DD>fos.pTo := PChar(_toDir); <DD>end else <DD>begin <DD>_fromDir:= _fromDir + SR.Name + #0#0; <DD>_toDir := _toDir + SR.Name + #0#0; <DD>fos.pFrom := PChar(_fromDir); <DD>fos.pTo := PChar(_toDir); <DD>end; <DD>Result := (0 = ShFileOperation(fos)); <DD>_fromDir:= ExtractFilePath(_fromDir); <DD>_toDir:= ExtractFilePath(_toDir); <DD>end; <DD>res := FindNext(SR); <DD>end; <DD>finally <DD>FindClose(SR); <DD>end; <DD>end else <DD>begin <DD>_fromDir:= RemoveBackslashUnlessRoot(_fromDir) + #0#0; <DD>_toDir := RemoveBackslashUnlessRoot(_toDir) + #0#0; <DD>fos.pFrom := PChar(_fromDir); <DD>fos.pTo := PChar(_toDir); <DD>Result := (0 = ShFileOperation(fos)); <DD>end; <DD>end;<P></P><DD><FONT color=green>{****************************************************************}</FONT> <DD>function MoveDir(const fromDir, toDir: string): Boolean; <DD>begin <DD>Result := BackupDir(fromDir, toDir, True); <DD>end;<P></P><DD><FONT color=green>{****************************************************************}</FONT> <DD>function CopyDir(const fromDir, toDir: string): Boolean; <DD>begin <DD>Result := BackupDir(fromDir, toDir, False); <DD>end;<P></P><DD><FONT color=green>{****************************************************************}</FONT> <DD>function DelDir(dir: string; toRecycle: Boolean): Boolean; <DD>var <DD>fos: TSHFileOpStruct; <DD>_dir: string; <DD>begin <DD>_dir:= RemoveBackslashUnlessRoot(dir) + #0#0; <DD>fos.wFunc := FO_DELETE; <DD>fos.fFlags := FOF_SILENT or FOF_NOCONFIRMATION; <DD>if toRecycle then <DD>fos.fFlags := fos.fFlags or FOF_ALLOWUNDO; <DD>fos.pFrom := PChar(_dir); <DD>Result := (0 = ShFileOperation(fos)); <DD>end;<P></P><DD><FONT color=green>{****************************************************************}</FONT> <DD>function RenameDir(const fromDir, toDir: string): Boolean; <DD>var <DD>fos: TSHFileOpStruct; <DD>_fromDir, _toDir: string; <DD>begin <DD>_fromDir:= RemoveBackslashUnlessRoot(fromDir) + #0#0; <DD>_toDir := RemoveBackslashUnlessRoot(toDir) + #0#0; <DD>fos.wFunc := FO_RENAME; <DD>fos.fFlags := FOF_FILESONLY or FOF_ALLOWUNDO or <DD>FOF_SILENT or FOF_NOCONFIRMATION; <DD>fos.pFrom := PChar(_fromDir); <DD>fos.pTo := PChar(_toDir); <DD>Result := (0 = ShFileOperation(fos)); <DD>end; <DD><FONT color=green>{****************************************************************}</FONT> <DD><FONT color=green>{****************************************************************}</FONT> <DD><FONT color=green>{****************************************************************}</FONT></DD><TR><TD>Пример написания выбора установки (например, русской версии игрушки) через RadioButton</TD><TD><DD><FONT color=red>[Files]</FONT> <DD><FONT color=green>;Основные файлы</FONT> <DD>Source: "Work\*.*"; DestDir: "{app}"; Flags: ignoreversion overwritereadonly <DD><FONT color=green>;Файлы руссификатора игры</FONT> <DD>Source: "Russian\*.*"; DestDir: "{app}"; Check: Russian; Flags: ignoreversion overwritereadonly<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>RussianBtn, EnglishBtn: TRadioButton; <DD>ResultCode: Boolean;<P></P><DD>procedure CreateTheWizardPages; <DD>var <DD>LangPage: TWizardPage; <DD>begin <DD>LangPage:=CreateCustomPage(wpSelectComponents, 'Language', 'Select Game Language'); <DD>RussianBtn:=TRadioButton.Create(LangPage); <DD>RussianBtn.Top:=ScaleY(30); <DD>RussianBtn.Width:=LangPage.SurfaceWidth; <DD>RussianBtn.Height:=ScaleY(17); <DD>RussianBtn.Caption:='Russian'; <DD>RussianBtn.Checked:=GetPreviousData('Russian', '1') = '1'; <DD>RussianBtn.Parent:=LangPage.Surface;<P></P><DD>EnglishBtn:=TRadioButton.Create(LangPage); <DD>EnglishBtn.Top:=RussianBtn.Top + ScaleY(30); <DD>EnglishBtn.Width:=LangPage.SurfaceWidth; <DD>EnglishBtn.Height:=ScaleY(17); <DD>EnglishBtn.Caption:='English'; <DD>EnglishBtn.Checked:=GetPreviousData('English', '0') = '1'; <DD>EnglishBtn.Parent:=LangPage.Surface; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>CreateTheWizardPages; <DD>end;<P></P><DD>procedure RegisterPreviousData(PreviousDataKey: Integer); <DD>begin <DD>SetPreviousData(PreviousDataKey, 'Russian', IntToStr(Ord(RussianBtn.Checked))); <DD>SetPreviousData(PreviousDataKey, 'English', IntToStr(Ord(EnglishBtn.Checked))); <DD>end;<P></P><DD>function Russian: Boolean; <DD>begin <DD>Result:=RussianBtn.Checked; <DD>end;<P></P><DD>function English: Boolean; <DD>begin <DD>Result:=EnglishBtn.Checked; <DD>end;<P></P><DT>Функция "English" здесь дана так просто, для виду... Типа, если выберешь "Russian", то устанавливаются файлы руссификатора, а если нет, то просто ставятся основные файлы. <DT>Да, вместо wpSelectComponents можно написать любую страницу и поверх её создастся страница с выбором языка.</DT><TR><TD>Как добавить кнопочку <B>Печать</B> на страницу, где отображается InfoBeforeFile?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes <DD>InfoBeforeFile=Readme.txt<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "MyProg.exe"; DestDir: "{app}"<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>PrintButton: TButton;<P></P><DD>procedure PrintButtonClick(Sender: TObject); <DD>var WordpadLoc: String; <DD>RetCode: Integer; <DD>begin <DD>if MsgBox( 'Do you want to print Info to default printer ?', mbConfirmation, MB_YESNO ) = IDYES then <DD>begin <DD>RegQueryStringValue( HKLM, 'SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\WORDPAD.EXE','', WordpadLoc); <DD>StringChange( WordpadLoc, '%ProgramFiles%', ExpandConstant('{pf}') ); <DD>StringChange( WordpadLoc, '"', ''); <DD>ExtractTemporaryFile('Readme.txt'); <DD>if not Exec( WordPadLoc, ' /p ' + ExpandConstant('{tmp}\Readme.txt') , <DD>ExpandConstant('{tmp}'), SW_HIDE, false, RetCode ) then <DD>MsgBox('Problems printing Info file !' + IntToStr(RetCode), mbError, mb_Ok) <DD>else <DD>MsgBox('Problems extracting Info file !', mbError, mb_Ok); <DD>end; <DD>end;<P></P><DD>procedure CurPageChanged(CurPage: Integer); <DD>begin <DD>if CurPage = wpInfoBefore then <DD>PrintButton.Visible := True <DD>else <DD>PrintButton.Visible := False; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>PrintButton := TButton.Create(WizardForm); <DD>PrintButton.Caption := '&amp;Print Info'; <DD>PrintButton.Top := WizardForm.BackButton.Top; <DD>PrintButton.Left := WizardForm.BackButton.Left - WizardForm.BackButton.Width - ScaleX(40); <DD>PrintButton.OnClick := @PrintButtonClick; <DD>PrintButton.Parent := WizardForm; <DD>PrintButton.Visible := False; <DD>end;</DD><TR><TD>Скрипт, в котором Репайр восстанавливает удаленные файлы; Модифай - показывает установленные компоненты.</TD><TD>Вот рабочий скрипт - все прописывалось строго по инструкции. Но скрипт писал только из любопытства. Реально не использую и подводных камней не знаю. <DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program <DD>DisableProgramGroupPage=yes <DD>AppId=MyProgram <DD>AppModifyPath="{app}\UninsHs.exe" /m=MyProgram<P></P><DD><FONT color=red>[Components]</FONT> <DD>Name: "main"; Description: "Main Files"; Types: full compact custom; Flags: fixed <DD>Name: "english"; Description: "English"; Types: full; Flags: DisableNoUninstallWarning <DD>Name: "dutch"; Description: "Dutch"; Types: full; Flags: DisableNoUninstallWarning<P></P><DD><FONT color=red>[Dirs]</FONT> <DD>Name: "{app}\SRC"<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "MyProg.exe"; DestDir: "{app}"; Components: main <DD>Source: "Readme.txt"; DestDir: "{app}"; Components: english <DD>Source: "Readme-Dutch.txt"; DestDir: "{app}"; Components: dutch <DD>Source: "UninsHs.exe"; DestDir: "{app}"; Flags: restartreplace<P></P><DD><FONT color=red>[InstallDelete]</FONT> <DD>Type: Files; Name: "{app}\Readme.txt" <DD>Type: Files; Name: "{app}\Readme-Dutch.txt"<P></P><DD><FONT color=red>[UninstallDelete]</FONT> <DD>Type: filesandordirs; Name: "{app}\SRC"<P></P><DD><FONT color=red>[Run]</FONT> <DD>Filename: {app}\UninsHs.exe; Parameters: /r=MyProgram,{language},{srcexe},{app}\SRC\setup.exe; Flags: runminimized runhidden nowait<P></P><DD><FONT color=red>[Code]</FONT> <DD>function ShouldSkipPage(CurPage: Integer): Boolean; <DD>begin <DD>if Pos('/SP-', UpperCase(GetCmdTail)) &gt; 0 then <DD>case CurPage of <DD>wpLicense, wpPassword, wpInfoBefore, wpUserInfo, <DD>wpSelectDir, wpSelectProgramGroup, wpInfoAfter: <DD>Result := True; <DD>end; <DD>end;</DD><TR><TD>Как разбить выбор дополнительных задач на две страницы? Чтобы определенные на одной находились, а остальные на другой?</TD><TD>Почитай в хелпе по поводу <B>CreateInputOptionPage</B>.<TR><TD>Можно ли сделать так, чтобы SFX архив не упаковывался Inno Setup, а лежал в одной папке с готовым Setup.exe, чтобы Setup.exe подхватывал его и начинал распаковывать в заданную инсталятором папку. А то SFX сначала распаковывается из Setup.exe и только потом начинается распаковка самого SFX.</TD><TD><DD><FONT color=red>[Run]</FONT> <DT><FONT color=green>;Запуск внешних SFX 7-ZIP архивов</FONT> <DT><FONT color=green>;При желании можно установить дополнительные флаги, например, <B><FONT color=blue>hidewizard</FONT></B> скрывает окно инсталлятора при выполнении распаковки архива.</FONT> <DT><FONT color=green>;При запуске устанавливаем параметр <B><FONT color=blue>-y</FONT></B>, который обозначает "Всегда Да" при любых действиях, <DT>параметр <B><FONT color=blue>-o "{app}"</FONT></B> который означает, что надо распаковать в указанную папку. Флаг <B><FONT color=blue>waituntilterminated</FONT></B> должен быть всегда в этом случае:</FONT> <DD>Filename: "{src}\SFX_ARCHIVE.exe"; WorkingDir: "{src}"; Parameters: "-y -o""{app}"""; StatusMsg: "Распаковка файлов игры..."; Flags: waituntilterminated</DD><TR><TD>Как сделать следующее: <DT>Директория установки программы по выбору пользователя. <DT>К компонентам распаковка не привязана, всё идёт одним куском (т.е. без разделения на компоненты). <DT>Архив может распаковываться в любое время после нажатия на кнопку "установить", т.е. когда устанавливаются все прочие файлы программы, без разницы, когда конкретно. <DT>Содержимое архива должно валиться в директорию устанавливаемой программы. Копировать его туда НЕОБЯЗАТЕЛЬНО. Можно и в tmp, я думал об этом. <DT>Запускаю c флагами nowait skipifsilent, без postinstall архив запускается, когда можно, но появляется окно типа "самораспаковывающийся архив..." чего хотелось бы избежать (использовать RAR?) <DT>Формат архива SFX.</DT></TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "MyProg.exe"; DestDir: "{app}"; Flags: ignoreversion <DD>Source: "archive.exe"; DestDir: "{tmp}"; Flags: ignoreversion<P></P><DD><FONT color=red>[Run]</FONT> <DD>Filename: "{tmp}\archive.exe"; Parameters: "-y -o""{app}"""; Flags: waituntilterminated<P></P><DT><FONT color=green>Для rar будет так:</FONT> <DD><FONT color=red>[Run]</FONT> <DD>Filename: "{tmp}\archive.exe"; Parameters: " -s -d""{app}"""; Flags: waituntilterminated</DD><TR><TD>Возможно ли на странице приветствия делать ссылки кликабельными?</TD><TD><DD>procedure AboutButtonOnClick(Sender: TObject); <DD>begin <DD>MsgBox('Это демо версия программы.', mbInformation, mb_Ok); <DD>end;<P></P><DD>procedure URLLabelOnClick(Sender: TObject); <DD>var <DD>ErrorCode: Integer; <DD>begin <DD>ShellExec('open', 'http://www.innosetup.com', '', '', SW_SHOWNORMAL, ewNoWait, ErrorCode); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>var <DD>AboutButton, CancelButton: TButton; <DD>URLLabel: TNewStaticText; <DD>BackgroundBitmapImage: TBitmapImage; <DD>BackgroundBitmapText: TNewStaticText;<P></P><DD>begin <DD>CancelButton := WizardForm.CancelButton; <DD>AboutButton := TButton.Create(WizardForm); <DD>AboutButton.Left := WizardForm.ClientWidth - CancelButton.Left - CancelButton.Width; <DD>AboutButton.Top := CancelButton.Top; <DD>AboutButton.Width := CancelButton.Width; <DD>AboutButton.Height := CancelButton.Height; <DD>AboutButton.Caption := '&amp;About...'; <DD>AboutButton.OnClick := @AboutButtonOnClick; <DD>AboutButton.Parent := WizardForm;<P></P><DD>URLLabel := TNewStaticText.Create(WizardForm); <DD>URLLabel.Caption := 'www.innosetup.com'; <DD>URLLabel.Cursor := crHand; <DD>URLLabel.OnClick := @URLLabelOnClick; <DD>URLLabel.Parent := WizardForm; <DD><FONT color=green>{ Alter Font *after* setting Parent so the correct defaults are inherited first }</FONT> <DD>URLLabel.Font.Style := URLLabel.Font.Style + [fsUnderline]; <DD>URLLabel.Font.Color := clBlue; <DD>URLLabel.Top := AboutButton.Top + AboutButton.Height - URLLabel.Height - 2; <DD>URLLabel.Left := AboutButton.Left + AboutButton.Width + ScaleX(20);<P></P><DD>BackgroundBitmapImage := TBitmapImage.Create(MainForm); <DD>BackgroundBitmapImage.Left := 50; <DD>BackgroundBitmapImage.Top := 100; <DD>BackgroundBitmapImage.AutoSize := True; <DD>BackgroundBitmapImage.Bitmap := WizardForm.WizardBitmapImage.Bitmap; <DD>BackgroundBitmapImage.Parent := MainForm;<P></P><DD>BackgroundBitmapText := TNewStaticText.Create(MainForm); <DD>BackgroundBitmapText.Left := BackgroundBitmapImage.Left; <DD>BackgroundBitmapText.Top := BackgroundBitmapImage.Top + BackgroundBitmapImage.Height + ScaleY(8); <DD>BackgroundBitmapText.Caption := 'TBitmapImage'; <DD>BackgroundBitmapText.Parent := MainForm; <DD>end;</DD><TR><TD>Код проверки пути установки файлов на наличие в пути русских символов</TD><TD><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>var <DD>i,j: integer; <DD>s,c: string; <DD>begin <DD>Result := True; <DD>if CurPageID = wpSelectDir then <DD>begin <DD>c := 'АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдеёжзийклмнопрстуфхцчшщъыьэюя'; <DD>for i:=1 to length(WizardForm.DirEdit.text) do <DD>for j:=1 to length(c) do <DD>begin <DD>if WizardForm.DirEdit.text[i] = c[j] then <FONT color=green>//{app} содержит русские символы</FONT> <DD>begin <DD>s := 'В пути установки присутствуют русские буквы, что недопустимо'#13#13'Пожалуйста, повторите ввод.'; <DD>MsgBox(s, mbError, mb_Ok); <DD>Result := False ; <FONT color=green>//запрет перехода на следующую страницу</FONT> <DD>exit; <DD>end <DD>else Result := True; <FONT color=green>//разрешаем переход на следующую страницу</FONT> <DD>end; <DD>end; <DD>end;</DD><TR><TD>Как проверить свободное место на диске?</TD><TD>В хелпе смотри описание функции <B>GetSpaceOnDisk</B><TR><TD>Как проверить свободное место на диске?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app}<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>NeedSize = 20; <FONT color=green>//Прописать, сколько мегабайт необходимо</FONT><P></P><DD>DRIVE_UNKNOWN = 0; <DD>DRIVE_NO_ROOT_DIR = 1; <DD>DRIVE_REMOVEABLE = 2; <DD>DRIVE_FIXED = 3; <DD>DRIVE_REMOTE = 4; <DD>DRIVE_CDROM = 5; <DD>DRIVE_RAMDISK = 6;<P></P><DD>function GetLogicalDrives: DWORD; <DD>external 'GetLogicalDrives@kernel32.dll stdcall';<P></P><DD>function GetDriveType(nDrive: String): Longint; <DD>external 'GetDriveTypeA@kernel32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>Path: String; <DD>FreeMB, TotalMB: Cardinal; <DD>ListBox: TListBox; <DD>drives: DWORD; <DD>i: integer; <DD>begin <DD>ListBox:= TListBox.Create(WizardForm); <DD>ListBox.Top:= 120; <DD>ListBox.Width:= 300; <DD>ListBox.Height:= ScaleY(90); <DD>ListBox.Parent:= WizardForm.SelectDirPage;<P></P><DD>drives:= GetLogicalDrives(); <DD>for i:= 0 to 31 do <DD>begin <DD>if (drives and (1 shl i)) &gt; 0 then <DD>begin <DD>Path:= chr(ord('A')+i)+':'; <DD>if GetDriveType(Path) = DRIVE_FIXED then <DD>begin <DD>GetSpaceOnDisk(Path, True, FreeMB, TotalMB); <DD>ListBox.Items.Add(Path + ' - Всего: ' + IntToStr(TotalMB) + <DD>'Мб - Свободно: ' + IntToStr(FreeMB) + 'Мб'); <DD>end; <DD>end; <DD>end; <DD>end;<P></P><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>var <DD>Path: String; <DD>FreeMB, TotalMB: Cardinal; <DD>begin <DD>Result:= True; <DD>if CurPageID = wpSelectDir then <DD>begin <DD>Path:= ExtractFileDrive(WizardForm.DirEdit.Text); <DD>GetSpaceOnDisk(Path, True, FreeMB, TotalMB); <DD>if FreeMB &lt; NeedSize then <DD>begin <DD>MsgBox('Недостаточно места на диске!', mbInformation, MB_OK) <DD>Result:= False; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Как можно сделать, чтобы в сообщении "Недостаточно места на диске!" выводилось также и кол-во необходимого для установки места?</TD><TD><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>var <DD>Path: String; <DD>FreeMB, TotalMB: Cardinal; <DD>begin <DD>Result:= True; <DD>if CurPageID = wpSelectDir then <DD>begin <DD>Path:= ExtractFileDrive(WizardForm.DirEdit.Text); <DD>GetSpaceOnDisk(Path, True, FreeMB, TotalMB); <DD>if FreeMB &lt; NeedSize then <DD>begin <DD>MsgBox('Для установки приложения необходимо '+ IntTostr(NeedSize)+ ' MB,'#13+ 'а на выбранном Вами диске доступно только '+ IntToStr(FreeMB)+' MB', mbCriticalError, MB_OK) <DD>Result := False; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Как сделать несколько ярлыков в меню Пуск, например, на запуск программы, на файл справки и т.д.?</TD><TD>Вот как у меня: <DD><FONT color=red>[Icons]</FONT> <DD>Name: {userdesktop}\S.T.A.L.K.E.R.; Filename: {app}\bin\XR_3DA.exe; Tasks: desktopicon; Flags: createonlyiffileexists; WorkingDir: {app}\bin <DD>Name: {group}\Начать игру; Filename: {app}\bin\XR_3DA.exe; Flags: createonlyiffileexists; WorkingDir: {app}\bin <DD>Name: {group}\Руководство; Filename: {app}\manual.pdf; Flags: createonlyiffileexists <DD>Name: {group}\Трейнер; Filename: {app}\trn.exe; Flags: createonlyiffileexists; WorkingDir: {app} <DD>Name: {group}\Файл Readme; Filename: {app}\ReadMe.txt; Flags: createonlyiffileexists <DD>Name: {group}\Интернет-сайты\Chuvakstepan Inc.; Filename: {app}\website.url; Flags: createonlyiffileexists; Tasks: url <DD>Name: {group}\Интернет-сайты\Сайт игры; Filename: {app}\websitegameSTALKER.url; Flags: createonlyiffileexists; Tasks: url <DD>Name: {group}\{cm:UninstallProgram,игры}; Filename: {uninstallexe}</DD><TR><TD>Как изменить шрифт всех лейблов на другой (verdana, sans serif)?</TD><TD><DD><FONT color=red>[Code]</FONT> <DD>Procedure InitializeWizard(); <DD>begin <DD>WizardForm.Font.Name:='MS Sans Serif' <FONT color=green>// Шрифт</FONT> <DD>WizardForm.Font.Style:=[fsBold] <FONT color=green>// Стиль шрифта</FONT> <DD>WizardForm.Font.Color:=clBlack <FONT color=green>// Цвет шрифта</FONT> <DD>end;</DD><TR><TD>Это понятно, но у меня есть свой шрифт TTF. Как его поставить на WizardForm?</TD><TD>Дело в том, что Inno устанавливает шрифты после установки. <DT>Но если ты хочешь, чтобы отображался твой шрифт, то как вариант можно сделать так: <DT>Сначала создай сайлент-инсталл шрифта: <DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>CreateAppDir=False <DD>DisableProgramGroupPage=True <DD>UsePreviousGroup=False <DD>AppendDefaultGroupName=False <DD>DisableFinishedPage=True <DD>DisableReadyPage=True <DD>Uninstallable=False <DD>OutputBaseFilename=font<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: ZOMBI.TTF; DestDir: {fonts}; FontInstall: Ds Zombie Cyr; Flags: onlyifdoesntexist uninsneveruninstall<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.Hide <DD>end;<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>If CurPageID=wpWelcome then <DD>begin <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 513, 0, 0) <DD>SendMessage(WizardForm.NEXTBUTTON.Handle, 514, 0, 0) <DD>end <DD>end;<P></P><DT>Потом создавай свой инсталл и включай в него инсталл шрифта: <DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\AppName<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: font.exe; DestDir: {tmp}; Flags: dontcopy<P></P><DD><FONT color=red>[Code]</FONT> <DD>Function InitializeSetup(): Boolean; <DD>var <DD>Res: Integer; <DD>begin <DD>ExtractTemporaryFile('font.exe') <DD>Exec(ExpandConstant('{tmp}\font.exe'),'','',SW_SHOWNORMAL,ewWaitUntilTerminated,Res) <DD>Result:=True <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.Font.Name:='Ds Zombie Cyr' <DD>end;</DD><TR><TD>Мне нужно использовать в коде <B>procedure InitializeWizard();</B> не один раз, а при компиляции мне пишет, что это можно использовать только один раз, как быть?</TD><TD>Просто вписывай значения из исходного <B>procedure InitializeWizard</B> уже без этой строчки: <DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard <DD>begin <DD>типа код вставки музыки <DD>end; <DD>begin <DD>типа код вставки фонового рисунка <DD>end;</DD><TR><TD>Вот интересный код (анимация):</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>appname=AnimateWindow <DD>appvername=AnimateWindow <DD>createappdir=no <DD>uninstallable=no<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>AW_FADE_IN = $00080000; <DD>AW_FADE_OUT = $00090000; <DD>AW_SLIDE_IN_LEFT = $00040001; <DD>AW_SLIDE_OUT_LEFT = $00050002; <DD>AW_SLIDE_IN_RIGHT = $00040002; <DD>AW_SLIDE_OUT_RIGHT = $00050001; <DD>AW_SLIDE_IN_TOP = $00040004; <DD>AW_SLIDE_OUT_TOP = $00050008; <DD>AW_SLIDE_IN_BOTTOM = $00040008; <DD>AW_SLIDE_OUT_BOTTOM = $00050004; <DD>AW_DIAG_SLIDE_IN_TOPLEFT = $00040005; <DD>AW_DIAG_SLIDE_OUT_TOPLEFT = $0005000a; <DD>AW_DIAG_SLIDE_IN_TOPRIGHT = $00040006; <DD>AW_DIAG_SLIDE_OUT_TOPRIGHT = $00050009; <DD>AW_DIAG_SLIDE_IN_BOTTOMLEFT = $00040009; <DD>AW_DIAG_SLIDE_OUT_BOTTOMLEFT = $00050006; <DD>AW_DIAG_SLIDE_IN_BOTTOMRIGHT = $0004000a; <DD>AW_DIAG_SLIDE_OUT_BOTTOMRIGHT = $00050005; <DD>AW_EXPLODE = $00040010; <DD>AW_IMPLODE = $00050010;<P></P><DD>function AnimateWindow(hWnd: HWND; dwTime: DWORD; dwFlags: DWORD): Boolean; <DD>external 'AnimateWindow@user32 stdcall';<P></P><DD>procedure OnShow(Sender: TObject); <DD>begin <DD>AnimateWindow(WizardForm.Handle,1000,AW_EXPLODE); <DD>WizardForm.NextButton.OnClick(WizardForm.NextButton); <DD>WizardForm.BackButton.OnClick(WizardForm.BackButton); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.OnShow:=@OnShow; <DD>end;<P></P><DD>procedure CancelButtonClick(CurPageID: Integer; var Cancel, Confirm: Boolean); <DD>begin <DD>Confirm:=False; <DD>AnimateWindow(WizardForm.Handle,1000,AW_IMPLODE); <DD>Cancel:=True; <DD>end;</DD><TR><TD>А можно, чтобы анимация (AW_IMPLODE или тому подобное) отображалась, если нажимаешь и на кнопку "Завершить" (окончания установки)?</TD><TD>Добавь это: <DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>begin <DD>Result:=True; <DD>if CurPageID=wpFinished then <DD>AnimateWindow(WizardForm.Handle,1000,AW_IMPLODE); <DD>end;</DD><TR><TD>Спецэффекты:</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program v.1.2 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>TransparentPercent = 80; <FONT color=green>// процент прозрачности</FONT><P></P><DD>WS_EX_LAYERED = $80000; <DD>WS_EX_TRANSPARENT = $20; <DD>LWA_COLORKEY = 1; <DD>LWA_ALPHA = 2; <DD>GWL_EXSTYLE = (-20);<P></P><DD>function SetLayeredWindowAttributes(hwnd: HWND; crKey: TColor; bAlpha: BYTE; dwFlags: DWORD): Boolean; <DD>external 'SetLayeredWindowAttributes@user32.dll stdcall';<P></P><DD>function GetWindowLong(Wnd: HWnd; Index: Integer): Longint; <DD>external 'GetWindowLongA@user32.dll stdcall';<P></P><DD>function SetWindowLong(Wnd: HWnd; Index: Integer; NewLong: Longint): Longint; <DD>external 'SetWindowLongA@user32.dll stdcall';<P></P><DD>Procedure InitializeWizard(); <DD>begin <DD>SetWindowLong(WizardForm.Handle, GWL_EXSTYLE, GetWindowLong(WizardForm.Handle, GWL_EXSTYLE) or WS_EX_LAYERED); <DD>SetLayeredWindowAttributes(WizardForm.Handle, 0, (255 * TransparentPercent) / 100, LWA_ALPHA); <DD>end;<P>Интересный эффект дает и такое использование:</P><DD>Procedure InitializeWizard(); <DD>begin <DD>WizardForm.ReadyMemo.Color:= clRed; <DD>SetWindowLong(WizardForm.Handle, GWL_EXSTYLE, GetWindowLong(WizardForm.Handle, GWL_EXSTYLE) or WS_EX_LAYERED); <DD>SetLayeredWindowAttributes(WizardForm.Handle, clRed, (255 * TransparentPercent) / 100, LWA_COLORKEY); <DD>end;</DD><TR><TD>Как сделать, чтобы при выборе пункта "Установить" и нажатии "Далее", запускалась дополнительная программа, находящаяся в дистрибутиве?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Tasks]</FONT> <DD>Name: fbrinst; Description: "Install Firebird"<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*.bmp; DestDir: {app} <DD>Source: FBirdSetup.exe; DestDir: {tmp}; Tasks: fbrinst; Flags: deleteafterinstall<P></P><DD><FONT color=red>[Run]</FONT> <DD>Filename: {tmp}\FBirdSetup.exe; Description: "Launch Firebird Setup"; Tasks: fbrinst</DD><TR><TD>А как сделать, чтобы сначала была установка Firebird, а уже потом продолжался ход установки основной программы?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Tasks]</FONT> <DD>Name: fbrinst; Description: "Install Firebird"<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: FBirdSetup.exe; DestDir: {tmp}; Tasks: fbrinst; AfterInstall: SetupFBird; Flags: deleteafterinstall <DD>Source: Files\*.bmp; DestDir: {app}<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure SetupFBird(); <DD>var <DD>ResultCode: Integer; <DD>begin <DD>Exec(ExpandConstant('{tmp}\FBirdSetup.exe'), '', '', SW_SHOWNORMAL, ewWaitUntilTerminated, ResultCode); <DD>end;</DD><TR><TD>Вот решение той же задачи (сначала установка Firebird):</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: FBirdSetup.exe; Flags: dontcopy <DD>Source: Files\*.bmp; DestDir: {app}<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>FirebirdInst: TInputOptionWizardPage; <DD>IsFbrInstalled: Boolean;<P></P><DD>procedure InitializeWizard; <DD>begin <DD>IsFbrInstalled:= False;<P></P><DD>FirebirdInst := CreateInputOptionPage(wpWelcome, 'Firebird 2.0', '', '', True, False); <DD>FirebirdInst.Add('Установить'); <DD>FirebirdInst.Add('Уже установлен'); <DD>case GetPreviousData('FirebirdInst', '') of 'Установить': FirebirdInst.SelectedValueIndex := 0; <DD>'Уже установлен': FirebirdInst.SelectedValueIndex := 1; <DD>else <DD>FirebirdInst.SelectedValueIndex := 0; <DD>end; <DD>end;<P></P><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>var <DD>ResultCode: Integer; <DD>begin <DD>Result:= True; <DD>if (CurPageID = FirebirdInst.ID) and (FirebirdInst.Values[0]) then <DD>begin <DD>ExtractTemporaryFile('FBirdSetup.exe'); <DD>Exec(ExpandConstant('{tmp}\FBirdSetup.exe'), '', '', SW_SHOWNORMAL, ewWaitUntilTerminated, ResultCode); <DD>IsFbrInstalled:= True; <DD>end; <DD>end;<P></P><DD>function ShouldSkipPage(PageID: Integer): Boolean; <DD>begin <DD>if PageID = FirebirdInst.ID then <DD>Result:= IsFbrInstalled <DD>else <DD>Result:= False; <DD>end;</DD><TR><TD>Поддерживает ли Inno изменение внешнего курсора?</TD><TD><DD>Const <DD>GCL_HCURSOR = (-12); <DD>OCR_NORMAL = 32512;<P></P><DD>var <DD>OldCursor, NewCursor: Longint;<P></P><DD>function LoadCursorFromFile(FileName: String): Longint; <DD>external 'LoadCursorFromFileA@user32 stdcall';<P></P><DD>function SetClassLong(hWnd: HWND; Index, NewLong: Longint): Longint; <DD>external 'SetClassLongA@user32 stdcall';<P></P><DD>function SetCursor(Cursor: Longint): Longint; <DD>external 'SetCursor@user32 stdcall';<P></P><DD>function SetSystemCursor(Cursor, CurType: Longint): Longint; <DD>external 'SetSystemCursor@user32 stdcall';<P></P><DD>function GetCursor(): Longint; <DD>external 'GetCursor@user32 stdcall';<P></P><DD>procedure InitializeWizard; <DD>begin <DD>OldCursor:= GetCursor; <DD>NewCursor:= LoadCursorFromFile('C:\TEMP\BeOS2.cur'); <DD>SetSystemCursor(NewCursor, OCR_NORMAL); <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>begin <DD>SetSystemCursor(OldCursor, OCR_NORMAL); <DD>end;<P></P><DT>Либо изменить курсор только для отдельных типов компонент:<P></P><DD>procedure InitializeWizard; <DD>begin <DD>NewCursor:= LoadCursorFromFile('C:\TEMP\BeOS2.cur'); <DD>OldCursor:= SetClassLong(WizardForm.NextButton.Handle, GCL_HCURSOR, NewCursor); <DD>end;</DD><TR><TD>Возможность проверки файловой системы [FAT32, NTFS] выбранного локального диска</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Code]</FONT> <DD>Const <DD>BufferLen = 50;<P></P><DD>function GetVolumeInformation(PathName, VolumeName: PChar; VolumeNameSize, VolumeSerialNumber, MaxComponentLength, FileSystemFlags: Longint; <DD>FileSystemName: PChar; FileSystemNameSize: Longint): Longint; <DD>external 'GetVolumeInformationA@kernel32.dll stdcall';<P></P><DD>procedure InitializeWizard; <DD>var <DD>VolumeName, <DD>FileSystemName : string; <DD>VolumeSerialNo : Longint; <DD>MaxComponentLength, <DD>FileSystemFlags : Longint; <DD>begin <DD>VolumeName:= StringOfChar( ' ', BufferLen ); <DD>FileSystemName:= StringOfChar( ' ', BufferLen );<P></P><DD>GetVolumeInformation('C:\', VolumeName, BufferLen-1, VolumeSerialNo, <DD>MaxComponentLength, <DD>FileSystemFlags, <DD>FileSystemName, <DD>BufferLen-1); <DD>MsgBox(FileSystemName, mbInformation, MB_OK); <DD>end;</DD><TR><TD>А как сделать, чтобы при выборе одного из дисков происходила проверка выбранного [FAT32, NTFS], а не при запуске.</TD><TD>Получение имени файловой системы оформляешь в виде функции. Например:<P><DD>function GetFileSystemName(Path: string): string; <DD>var <DD>VolumeName, <DD>FileSystemName : string; <DD>VolumeSerialNo : Longint; <DD>MaxComponentLength, <DD>FileSystemFlags : Longint; <DD>begin <DD>VolumeName:= StringOfChar( ' ', BufferLen ); <DD>FileSystemName:= StringOfChar( ' ', BufferLen );<P></P><DD>GetVolumeInformation(Path, VolumeName, BufferLen-1, VolumeSerialNo, <DD>MaxComponentLength, <DD>FileSystemFlags, <DD>FileSystemName, <DD>BufferLen-1); <DD>Result:= Trim(FileSystemName); <DD>end;<P></P><DT>... и в нужное тебе место вставляешь проверку: <DD>if GetFileSystemName(NewLetter + ':\') = 'NTFS' then <DD>..........................<P></P><DT>Также может быть, например, так:<P></P><DD>procedure ListBoxOnClick(Sender: TObject); <DD>var <DD>NewLetter, OldString: string; <DD>i: Integer; <DD>begin <DD>for i := 0 to ListBox.Items.Count - 1 do <DD>begin <DD>if ListBox.Selected[i] then <DD>begin <DD>NewLetter := Copy(ListBox.Items[i], 0, 1); <DD>if GetFileSystemName(NewLetter + ':\') = 'NTFS' then <DD>begin <DD>OldString := Copy(WizardForm.DirEdit.Text, 2, Length(WizardForm.DirEdit.Text)); <DD>WizardForm.DirEdit.Text := NewLetter + OldString; <DD>end else <DD>begin <DD>MsgBox('For NTFS Only!' + #10#13 + 'Selected drive has ' + GetFileSystemName(NewLetter + ':\') + ' file system.', mbInformation, MB_OK); <DD>end; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Есть пакет из трех программ с раздельными exe-файлами. Как сделать, чтобы после установки можно было только одну из трех выбрать на запуск?</TD><TD><DD><FONT color=red>[Files]</FONT> <DD>Source: My Program 1.exe; destdir: {app}; flags: ignoreversion <DD>Source: My Program 2.exe; destdir: {app}; flags: ignoreversion <DD>Source: My Program 3.exe; destdir: {app}; flags: ignoreversion<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>RadioButton1: TRadioButton; <DD>RadioButton2: TRadioButton; <DD>RadioButton3: TRadioButton;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>RadioButton1 := TRadioButton.Create(WizardForm.FinishedPage); <DD>with RadioButton1 do <DD>begin <DD>Parent := WizardForm.FinishedHeadingLabel.Parent; <DD>Caption := 'Launch My Program 1'; <DD>Left := ScaleX(180); <DD>Top := ScaleY(120); <DD>Width := ScaleX(177); <DD>Height := ScaleY(17); <DD>TabOrder := 0; <DD>end;<P></P><DD>RadioButton2 := TRadioButton.Create(WizardForm.FinishedPage); <DD>with RadioButton2 do <DD>begin <DD>Parent := WizardForm.FinishedHeadingLabel.Parent; <DD>Caption := 'Launch My Program 2'; <DD>Left := ScaleX(180); <DD>Top := ScaleY(145); <DD>Width := ScaleX(177); <DD>Height := ScaleY(17); <DD>TabOrder := 1; <DD>end;<P></P><DD>RadioButton3 := TRadioButton.Create(WizardForm.FinishedPage); <DD>with RadioButton3 do <DD>begin <DD>Parent := WizardForm.FinishedHeadingLabel.Parent; <DD>Caption := 'Launch My Program 3'; <DD>Left := ScaleX(180); <DD>Top := ScaleY(170); <DD>Width := ScaleX(177); <DD>Height := ScaleY(17); <DD>TabOrder := 2; <DD>end; <DD>end;<P></P><DD>function NextButtonClick(CurPageID: Integer): Boolean; <DD>var ResultCode: Integer; <DD>begin <DD>Result:=True; <DD>if CurPageID=wpFinished then <DD>begin <DD>if RadioButton1.Checked then <DD>Exec(ExpandConstant('{app}\My Program 1.exe'), '', '', SW_SHOW,ewNoWait, ResultCode) <DD>else <DD>if RadioButton2.Checked then <DD>Exec(ExpandConstant('{app}\My Program 2.exe'), '', '', SW_SHOW,ewNoWait, ResultCode) <DD>else <DD>if RadioButton3.Checked then <DD>Exec(ExpandConstant('{app}\My Program 3.exe'), '', '', SW_SHOW,ewNoWait, ResultCode) <DD>end <DD>end;</DD><TR><TD>Как сделать, чтобы деинсталлятор удалял всю папку, даже с новыми файлами и папками, которые не прописаны первым инсталлятором?</TD><TD><DD><FONT color=red>[UninstallDelete]</FONT> <DD>Type: filesandordirs; Name: "{app}"<P></P><DT>Или так: <DD><FONT color=red>[Code]</FONT> <DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if CurUninstallStep=usPostUninstall then <DD>begin <DD>DelTree(ExpandConstant('{app}'), True, True, True); <DD>RemoveDir(ExpandConstant('{app}')); <DD>end; <DD>end;</DD><TR><TD>Как сделать, чтобы путь установки вместо {app} был своим собственным?</TD><TD>В разделе <FONT color=red>[Files]</FONT> в строке Source: .........; DestDir: {app}\.......<P><DT>вместо: <DT>DestDir: {app}\.....<P></P><DT>пишешь: <DT>DestDir: {code:MyPath}\.....<P></P><DT>а в коде прописываешь функцию, которая будет возвращать требуемый путь. Например:<P></P><DD>function MyPath(Param: String): String; <DD>begin <DD>Result := ExpandConstant('{pf}'); <DD>end;<P></P><DT>путь составляешь как тебе надо - исходя из выбранного диска и т.д.</DT><TR><TD>Как сделать, чтобы в зависимости от того, какой компонент выбран, показывать или скрывать следующую форму?</TD><TD><DD>function WizardSelectedComponents(const Descriptions: Boolean): String; <DD>function IsComponentSelected(const Components: String): Boolean;</DD><TR><TD>Код, который будет закрывать процессы перед началом удаления руссификатора.</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "ISTask.dll"; DestDir: "{app}"<P></P><DD><FONT color=red>[Code]</FONT> <DD>function KillTask(ExeFileName: string): Integer; <DD>external 'KillTask@files:ISTask.dll stdcall delayload setuponly';<P></P><DD>function RunTask(FileName: string; bFullpath: Boolean): Boolean; <DD>external 'RunTask@files:ISTask.dll stdcall delayload setuponly';<P></P><DD>function KillTaskA(ExeFileName: string): Integer; <DD>external 'KillTask@{app}\ISTask.dll stdcall delayload uninstallonly';<P></P><DD>function RunTaskA(FileName: string; bFullpath: Boolean): Boolean; <DD>external 'RunTask@{app}\ISTask.dll stdcall delayload uninstallonly';<P></P><DD>function InitializeSetup(): Boolean; <DD>begin <DD>If RunTask('calc.exe', false) then <DD>begin <DD>if MsgBox('Программа установки руссификатора обнаружила, что программа'#13'для которой установится руссификатор запущена в данный момент. '#13#13' Закрыть программу?'#13#13 + <DD>'"Да" - закроет и не сохранит измененные настройки в программе.' #13#13 + <DD>'"Нет" - продолжит установку без закрытия. (Настоятельно рекомендуется нажать Да)', mbError, mb_YesNo) = idYes then <DD>begin <DD>KillTask('calc.exe'); <DD>Result := True; <DD>end else <DD>Exit; <DD>end; <DD>Result := True; <DD>begin <DD>If RunTask('notepad.exe', false) then <DD>begin <DD>KillTask('notepad.exe'); <DD>Result := True; <DD>end else <DD>Exit; <DD>end; <DD>end;<P></P><DD>function InitializeUninstall(): Boolean; <DD>begin <DD>If RunTaskA('calc.exe', false) then <DD>begin <DD>if MsgBox('Программа установки русификатора обнаружила, что программа'#13'для которой установится русификатор запушена в данный момент. '#13#13' Закрыть программу?'#13#13 + <DD>'"Да" - закроет и не сохранит измененные настройки в программе.' #13#13 + <DD>'"Нет" - продолжит установку без закрытия. (Настоятельно рекомендуется нажать Да)', mbError, mb_YesNo) = idYes then <DD>begin <DD>KillTaskA('calc.exe'); <DD>Result := True; <DD>end else <DD>Exit; <DD>end; <DD>Result := True; <DD>begin <DD>If RunTaskA('notepad.exe', false) then <DD>begin <DD>KillTaskA('notepad.exe'); <DD>Result := True; <DD>end else <DD>Exit; <DD>end; <DD>end;</DD><TR><TD>Как можно остановить виндовый сервис, а затем запустить его?</TD><TD>net stop имя_сервиса <DT>net start имя_сервиса</DT><TR><TD>Как сделать WizardForm - "Always on top"?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Code]</FONT> <DD>Const <DD>HWND_TOP = 0; <DD>HWND_TOPMOST = -1; <DD>HWND_NOTOPMOST = -2; <DD>SWP_NOSIZE = $1; <DD>SWP_NOMOVE = $2; <DD>SWP_NOZORDER = $4; <DD>SWP_NOREDRAW = $8; <DD>SWP_NOACTIVATE = $10; <DD>SWP_FRAMECHANGED = $20; <DD>SWP_SHOWWINDOW = $40; <DD>SWP_HIDEWINDOW = $80; <DD>SWP_NOCOPYBITS = $100; <DD>SWP_NOOWNERZORDER = $200; <DD>SWP_DRAWFRAME = SWP_FRAMECHANGED; <DD>SWP_NOREPOSITION = SWP_NOOWNERZORDER;<P></P><DD>function SetWindowPos(hWnd, hWndInsertAfter, <DD>X, Y, cx, cy, wFlags: Longint):Boolean; <DD>external 'SetWindowPos@user32.dll stdcall';<P></P><DD>procedure InitializeWizard; <DD>begin <DD>SetWindowPos(WizardForm.Handle, HWND_TOPMOST, 0, 0, 0, 0, <DD>SWP_NOSIZE or SWP_NOMOVE or SWP_SHOWWINDOW); <DD>end;</DD><TR><TD>Как избавиться от запроса подтверждения выхода из инсталлятора?</TD><TD>Добавь в скрипт следующее: <DD>procedure CancelButtonClick(CurPageID: Integer; var Cancel, Confirm: Boolean); <DD>begin <DD>Confirm:=False; <DD>end;</DD><TR><TD>Как перенести неумещающийся текст на следующую строку?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\AppName<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Panel: TPanel; <DD>Text: TNewStaticText;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>Panel:=TPanel.Create(WizardForm) <DD>Panel.Left:=3 <DD>Panel.Top:=315 <DD>Panel.Width:=245 <DD>Panel.Height:=44 <DD>Panel.BevelInner:=bvLowered <DD>Panel.Color:=12639424 <DD>Panel.Parent:=WizardForm<P></P><DD>Text:=TNewStaticText.Create(WizardForm) <DD>Text.Left:=2 <DD>Text.Top:=2 <DD>Text.Width:=242 <DD>Text.Height:=38 <DD>Text.AutoSize:=False <DD>Text.WordWrap:=True <DD>Text.Caption:='действительно на панели не переносится но как вариант можно сделать так' <DD>Text.Parent:=Panel <DD>end;</DD><TR><TD>Как сделать вторую страницу дополнительных задач (следом за первой) и перенести часть кнопок (чекбоксов) на новую?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program ver.1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Tasks]</FONT> <DD>Name: desktopicon; Description: "Create a &amp;desktop icon"; GroupDescription: "Additional icons:" <DD>Name: desktopicon\common; Description: "For all users"; GroupDescription: "Additional icons:"; Flags: exclusive <DD>Name: desktopicon\user; Description: "For the current user only"; GroupDescription: "Additional icons:"; Flags: exclusive unchecked <DD>Name: quicklaunchicon; Description: "Create a &amp;Quick Launch icon"; GroupDescription: "Additional icons:"; Flags: unchecked <DD>Name: associate; Description: "&amp;Associate files"; GroupDescription: "Other tasks:"; Flags: unchecked<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Page: TInputOptionWizardPage; <DD>IsRegisteredUser: Boolean;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>Page := CreateInputOptionPage(wpSelectTasks, <DD>'License Information', 'Are you a registered user?', <DD>'If you are a registered user, please check the box below, then click Next.', <DD>False, False);<P></P><DD>Page.Add('I am a registered user'); <DD>Page.Values[0] := False; <DD>end;</DD><TR><TD>Как объединить секцию <FONT color=red>[Code]</FONT> из предыдущего примера и команды раздела <FONT color=red>[Tasks]</FONT>?</TD><TD><DD>var <DD>Page: TInputOptionWizardPage; <DD>IsRegisteredUser: Boolean; <DD>procedure InitializeWizard(); <DD>begin <DD>Page := CreateInputOptionPage(wpSelectTasks, <DD>'License Information', 'Are you a registered user?', <DD>'If you are a registered user, please check the box below, then click Next.', <DD>False, False);<P></P><DD>{0} Page.Add('Исправить ошибку page2chm v.2.7 RC1 с Opera v.9.10 и выше'); <DD>{1} Page.Add('Исправить кодировку русских символов в оболочке Windows'); <DD>{2} Page.Add('Использовать доступное поле множественного поиска'); <DD>{3} Page.Add('Сокращать длинные названия кнопок и панелей в середине имени'); <DD>{4} Page.Add('Включить сохранение страниц'); <DD>{5} Page.Add('Включить рекомендуемую кодировку текста');<P></P><DD>Page.Values[0] := True; <DD>end;</DD><TR><TD>Как сделать, чтобы дополнительно создать новую страницу и туда перенести задачи раздела <FONT color=red>[Tasks]</FONT>, чтобы при их выборе происходило копирование в ini-файл, в зависимости от того, что выбрано (из чекбоксов)?</TD><TD>В секции <FONT color=red>[INI]</FONT> вместо параметра <B>Tasks:</B> используй параметр <B>Check:</B>. <DT>Т.е. выглядеть это будет примерно так: <DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program v.1.2 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "MyProg.ini"; DestDir: "{app}"<P></P><DD><FONT color=red>[INI]</FONT> <DD>Filename: {app}\opera6.ini; Section: User Prefs; Key: Save With Images Use Subfolder; String: 1; Check: CheckOption(4); Flags: uninsdeleteentry <DD>Filename: {app}\opera6.ini; Section: User Prefs; Key: Force Encoding; String: AUTODETECT-RU; Check: CheckOption(5); Flags: uninsdeleteentry <DD>Filename: {app}\opera6.ini; Section: User Prefs; Key: Title; Check: CheckOption(0); String: ; Flags: uninsdeleteentry <DD>Filename: {app}\opera6.ini; Section: User Prefs; Key: Use Integrated Search; String: 1; Check: CheckOption(2); Flags: uninsdeleteentry <DD>Filename: {app}\opera6.ini; Section: User Prefs; Key: Ellipsis In Center; String: 1; Check: CheckOption(3); Flags: uninsdeleteentry<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Page: TInputOptionWizardPage; <DD>IsRegisteredUser: Boolean; <DD>procedure InitializeWizard(); <DD>begin <DD>Page := CreateInputOptionPage(wpSelectTasks, <DD>'License Information', 'Are you a registered user?', <DD>'If you are a registered user, please check the box below, then click Next.', <DD>False, False);<P></P><DD>{0} Page.Add('Исправить ошибку page2chm v.2.7 RC1 с Opera v.9.10 и выше'); <DD>{1} Page.Add('Исправить кодировку русских символов в оболочке Windows'); <DD>{2} Page.Add('Использовать доступное поле множественного поиска'); <DD>{3} Page.Add('Сокращать длинные названия кнопок и панелей в середине имени'); <DD>{4} Page.Add('Включить сохранение страниц'); <DD>{5} Page.Add('Включить рекомендуемую кодировку текста');<P></P><DD>Page.Values[0] := True; <DD>end;<P></P><DD>function CheckOption(OptionNum: integer): Boolean; <DD>begin <DD>Result:= Page.Values[OptionNum]; <DD>end;</DD><TR><TD>Как сделать, чтобы отмеченные данные на этой странице вносились на страницу wpReady?</TD><TD><DD>var <DD>Page: TInputOptionWizardPage;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>Page := CreateInputOptionPage(wpSelectTasks, <DD>'License Information', 'Are you a registered user?', <DD>'If you are a registered user, please check the box below, then click Next.', <DD>False, False);<P></P><DD>Page.Add('I am a registered user'); <DD>Page.Add('Install Acrobat Reader'); <DD>Page.Values[0] := False; <DD>end;<P></P><DD>procedure CurPageChanged(CurPageID: Integer); <DD>begin <DD>if CurPageID = wpReady then <DD>begin <DD>if Page.Values[0] then <DD>WizardForm.ReadyMemo.Lines.Add('Confirm registration'); <DD>if Page.Values[1] then <DD>WizardForm.ReadyMemo.Lines.Add('Install Acrobat Reader'); <DD>end; <DD>end;</DD><TR><TD>Как сделать, чтобы дополнительные задачи разбивались на группы?</TD><TD><DD>var <DD>Page: TInputOptionWizardPage;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>Page := CreateInputOptionPage(wpSelectTasks, <DD>'License Information', 'Are you a registered user?', <DD>'If you are a registered user, please check the box below, then click Next.', <DD>False, False);<P></P><DD>Page.AddEx('I am a registered user', 0, False); <DD>Page.AddEx('Install Acrobat Reader', 1, False); <DD>Page.AddEx('Install Documentation', 1, False); <DD>end;</DD><TR><TD>Запуск/остановку службы в самом простом виде можно реализовать примерно так (здесь стоп/старт службы Windows Time). Использовать надо не имя службы, а выводимое имя.</TD><TD><DD>var <DD>res: integer;<P></P><DD>function InitializeSetup(): Boolean; <DD>begin <DD>Exec('net', 'stop "Windows Time"', '', SW_HIDE, ewWaitUntilTerminated, res); <DD>Result:= True; <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>begin <DD>Exec('net', 'start "Windows Time"', '', SW_HIDE, ewWaitUntilTerminated, res); <DD>end;<P></P><DT>Если не получается, то можно попробовать из командной строки: <DT>net stop "Windows Time"</DT><TR><TD>Запуск/остановка службы, работает нормально как во время установки, так и при удалении.</TD><TD><DD>function InitializeSetup(): Boolean; <DD>var <DD>res: integer; <DD>begin <DD>Exec('net', 'stop "O&amp;O Defrag"', '', SW_HIDE, ewWaitUntilTerminated, res); <DD>Result:= True; <DD>end;<P></P><DD>procedure DeinitializeSetup(); <DD>var <DD>res: integer; <DD>begin <DD>Exec('net', 'start "O&amp;O Defrag"', '', SW_HIDE, ewWaitUntilTerminated, res); <DD>end;<P></P><DD>function InitializeUninstall(): Boolean; <DD>var <DD>res: integer; <DD>begin <DD>Exec('net', 'stop "O&amp;O Defrag"', '', SW_HIDE, ewWaitUntilTerminated, res); <DD>Result:= True; <DD>end;<P></P><DD>procedure DeinitializeUninstall(); <DD>var <DD>res: integer; <DD>begin <DD>Exec('net', 'start "O&amp;O Defrag"', '', SW_HIDE, ewWaitUntilTerminated, res); <DD>end;</DD><TR><TD>Как сделать, чтобы папка, в которую устанавливается программа, меняла иконку?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Dirs]</FONT> <DD>Name: "{app}"; Attribs: system; AfterInstall: CreateIni();<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\icon.ico; DestDir: {app}<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure CreateIni(); <DD>begin <DD>SaveStringsToFile(ExpandConstant('{app}\Desktop.ini'), ['[.ShellClassInfo]', <DD>'IconFile=%SystemRoot%\system32\SHELL32.dll', <DD>'IconIndex=27'], False) <DD>end;</DD><TR><TD>Как сделать, чтобы при установке копировался файл, потом проходит время, заданное в скрипте, и копируется другой, и так далее?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName=C:\AppName<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app}; BeforeInstall: MySleep<P></P><DD><FONT color=red>[Code]</FONT> <DD>const <DD>SleepTime = 2000;<P></P><DD>procedure MySleep(); <DD>begin <DD>Sleep(SleepTime); <DD>end;</DD><TR><TD>Как проверить наличие определённого файла в папке назначения после нажатия кнопки "Установить"?</TD><TD><DD><FONT color=red>[Code]</FONT> <DD>function NextButtonClick(CurPage: Integer): Boolean; <DD>var <DD>s:string; <DD>begin <DD>Result:=True; <DD>If CurPage=5 then <DD>begin <DD>If FileSearch('www.sss', ExpandConstant('{app}'))='' then <DD>begin <DD>s:='В каталоге '+ExpandConstant('{app}')+' файл www.sss отсутствует!'; <DD>MsgBox(s, mbError, mb_Ok); <DD>Result:=False; <DD>end; <DD>end; <DD>end;<P></P><DT>Здесь CurPage=5. Определить CurPage можно в отладке. Запускаешь процесс инсталляции в InnoSetup клавишей F7, когда шаг доходит до строки CurPage, наводишь на нее курсор, всплывающая подсказка покажет значение CurPage.</DT><TR><TD>Как отключить кнопку минимизации инсталятора?</TD><TD><DD><FONT color=red>[Code]</FONT> <DD>procedure InitializeWizard(); <DD>begin <DD>WizardForm.BorderIcons:=[biSystemMenu] <DD>end;</DD><TR><TD>Как сделать, чтобы при установке в папке директории создавался лог копируемых файлов?</TD><TD>Запусти инсталлятор с параметром <B>/LOG="filename"</B><P><DT>Если надо, чтобы лог создавался в дирректории устанавливаемой программы, то тогда лог не будет удален при деинсталляции. В этом случае можно пустой файл лога включить в сам инсталлятор. Примерно так: <DD><FONT color=red>[Setup]</FONT> <DD>AppName=AppName <DD>AppVerName=AppVerName <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: setup.log; DestDir: {app}; AfterInstall: ExtLog() <DD>Source: Files\*; DestDir: {app}; AfterInstall: ExtLog()<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure ExtLog(); <DD>begin <DD>SaveStringToFile(ExpandConstant('{app}\setup.log'), #13#10 + GetDateTimeString('dd/mm/yyyy hh:nn:ss', '-', ':') + ' - ' + ExpandConstant(CurrentFileName), True); <DD>end;</DD><TR><TD>Есть четыре разных инсталлятора программного обеспечения (установка сервера, его настройка, автоматический апгрейд, разворачивание базы). Каждая из этих составляющих требует перезагрузки компьютера. Как сделать, чтобы после перезагрузки инсталлятор продолжал инсталляцию с того момента, на котором ушел на перезагруз?</TD><TD>Создаешь 4 отдельных инсталлятора (от общего инсталлятора придется отказаться). Первый прописывает в HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\RunOnce запуск второго, второй - третьего, третий - четвертого. <DT>А в реестр лучше писать только тогда, когда действительно надо. Например, когда закончен первый этап и осталось только перегрузить, вывести сообщение типа "Для завершения установки требуется перегрузка. Перегрузить сейчас?" и две кнопки ОК, Отмена. Вне зависимости от ответа пользователя, прописать ключ в реестр, но при ОК еще и дать команду на рестарт. Тогда не надо будет и удалять.</DT><TR><TD>Как сделать, чтобы полностью были видны имена всех файлов?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=MaxTextLength <DD>AppVerName=MaxTextLength <DD>CreateAppDir=false<P></P><DD><FONT color=red>[Code]</FONT> <DD>var string: string; <DD>const MaxLength = 48;<P></P><DD>Procedure InitializeWizard; <DD>Begin <DD>string:= ' Test max string Length 1234567890абвгдежзийклмнопрстуфхцчшщъыьэюяёАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯЁ'; <DD>string:= ' ...' + Copy(string, Length(string)-MaxLength, MaxLength); <DD>MsgBox(string + #10#13 ' MaxLength = ' + IntToStr(MaxLength), mbInformation, mb_Ok); <DD>End;</DD><TR><TD>Как проверить, стоит ли атрибут 'Только для чтения' у текстового файла и, если стоит, то убрать его?</TD><TD>Вот два решения: <DT>Решение через FindFirst : <DD>function SetFileAttributes(lpFileName: string; dwFileAttributes: integer): integer; <DD>external 'SetFileAttributesA@kernel32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>FileName: string; <DD>SR: TFindRec; <DD>begin <DD>FileName:= 'C:\TEMP\aaa.txt'; <DD>FindFirst(FileName, SR);<P></P><DD>if (SR.Attributes and FILE_ATTRIBUTE_READONLY) = FILE_ATTRIBUTE_READONLY then <DD>SetFileAttributes(FileName, FILE_ATTRIBUTE_NORMAL); <DD>FindClose(SR); <DD>end;<P></P><DT>Решение через GetFileAttributes : <DD>function GetFileAttributes(lpFileName: string): integer; <DD>external 'GetFileAttributesA@kernel32.dll stdcall';<P></P><DD>function SetFileAttributes(lpFileName: string; dwFileAttributes: integer): integer; <DD>external 'SetFileAttributesA@kernel32.dll stdcall';<P></P><DD>procedure InitializeWizard(); <DD>var <DD>FileName: string; <DD>begin <DD>FileName:= 'C:\TEMP\aaa.txt'; <DD>if (GetFileAttributes(FileName) and FILE_ATTRIBUTE_READONLY) = FILE_ATTRIBUTE_READONLY then <DD>SetFileAttributes(FileName, FILE_ATTRIBUTE_NORMAL); <DD>end;</DD><TR><TD>Листбокс с картинкой</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program [Version] <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Files\*; DestDir: {app} <DD>Source: Image.bmp; DestDir: {app}<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>Form: TSetupForm; <DD>ExtraFilesList: TMemo; <DD>CancelButton, DelButton: TButton; <DD>UpImage, DownImage, Image: TBitmapImage; <DD>UpPanel, DownPanel: TPanel; <DD>NameLabel, DescriptionLabel, BeforeListBoxLabel: TLabel; <DD>DownTextLabel: TLabel;<P></P><DD>function InitializeUninstall(): Boolean; <DD>begin <DD>FileCopy(ExpandConstant('{app}\Image.bmp'), <DD>ExpandConstant('{tmp}\Image.bmp'), True); <DD>Result := True; <DD>end;<P></P><DD>procedure FillListBox(const fromDir, fileMask: string; Level: Byte); <DD>var <DD>FSR, DSR: TFindRec; <DD>FindResult: Boolean; <DD>APath: String; <DD>MainLen: Integer; <DD>i: Integer; <DD>begin <DD>MainLen:= Length(ExpandConstant('{app}')); <DD>APath := AddBackslash(fromDir); <DD>FindResult := FindFirst(APath + fileMask, FSR); <DD>try <DD>while FindResult do <DD>begin <DD>if FSR.Attributes and FILE_ATTRIBUTE_DIRECTORY = 0 then <DD>begin <DD>{files} i:= ExtraFilesList.Lines.Add(Copy(APath + FSR.Name, MainLen+2, Length(APath + FSR.Name))); <DD>end; <DD>FindResult := FindNext(FSR); <DD>end; <DD>FindResult := FindFirst(APath + '*.*', DSR); <DD>while FindResult do <DD>begin <DD>if ((DSR.Attributes and FILE_ATTRIBUTE_DIRECTORY) = FILE_ATTRIBUTE_DIRECTORY) and <DD>not ((DSR.Name = '.') or (DSR.Name = '..')) then <DD>begin <DD>{Recursion} FillListBox(APath + DSR.Name, fileMask, Level+1); <DD>end; <DD>FindResult := FindNext(DSR); <DD>end; <DD>finally <DD>FindClose(FSR); <DD>FindClose(DSR); <DD>end; <DD>end;<P></P><DD>procedure DeleteFiles(); <DD>begin <DD>DelTree(ExpandConstant('{app}'), True, True, True); <DD>end;<P></P><DD>procedure BrowseRemainedFiles(); <DD>begin <DD>Form := CreateCustomForm; <DD>Form.ClientWidth := ScaleX(504); <DD>Form.ClientHeight := ScaleY(358); <DD>Form.Caption := 'Paradise - InstallShield Wizard'; <DD>Form.Center;<P></P><DD>UpImage := TBitmapImage.Create(Form); <DD>UpImage.Top := ScaleY(0); <DD>UpImage.Left := ScaleX(0); <DD>UpImage.Width := Form.ClientWidth; <DD>UpImage.Height := ScaleY(59); <DD>UpImage.BackColor := clWhite; <DD>UpImage.Parent := Form;<P></P><DD>Image := TBitmapImage.Create(Form); <DD>Image.Top := ScaleY(0); <DD>Image.Width := ScaleX(142); <DD>Image.Left := Form.ClientWidth - Image.Width; <DD>Image.Height := ScaleY(59); <DD>Image.Bitmap.LoadFromFile(ExpandConstant('{tmp}\Image.bmp')); <DD>Image.Parent := Form;<P></P><DD>DownImage := TBitmapImage.Create(Form); <DD>DownImage.Top := ScaleY(61); <DD>DownImage.Left := ScaleX(0); <DD>DownImage.Width := Form.ClientWidth; <DD>DownImage.Height := Form.ClientHeight - DownImage.Top; <DD>DownImage.BackColor := $EEE9EB; <DD>DownImage.Parent := Form;<P></P><DD>UpPanel := TPanel.Create(Form); <DD>UpPanel.Top := ScaleY(59); <DD>UpPanel.Width := Form.ClientWidth; <DD>UpPanel.Height := ScaleY(2); <DD>UpPanel.BevelOuter := bvLowered; <DD>UpPanel.Parent := Form;<P></P><DD>NameLabel := TLabel.Create(Form); <DD>NameLabel.Top := ScaleY(5); <DD>NameLabel.Left := ScaleX(16); <DD>NameLabel.Font.Style := [fsBold]; <DD>NameLabel.Caption := 'Внимание!'; <DD>NameLabel.Color := clWhite; <DD>NameLabel.Parent := Form;<P></P><DD>DescriptionLabel := TLabel.Create(Form); <DD>DescriptionLabel.Top := ScaleY(24); <DD>DescriptionLabel.Left := ScaleX(25); <DD>DescriptionLabel.Caption := 'Папка установки содержит посторонние файлы. Удалить их?'; <DD>DescriptionLabel.Color := clWhite; <DD>DescriptionLabel.Parent := Form;<P></P><DD>BeforeListBoxLabel := TLabel.Create(Form); <DD>BeforeListBoxLabel.Top := ScaleY(68); <DD>BeforeListBoxLabel.Left := ScaleX(25); <DD>BeforeListBoxLabel.Caption := 'Если Вы уверены, что хотите удалить папку установки со всеми указанными файлами,'#13 'нажмите Да.' <DD>BeforeListBoxLabel.Color := $EEE9EB; <DD>BeforeListBoxLabel.Parent := Form;<P></P><DD>DownPanel := TPanel.Create(Form); <DD>DownPanel.Left := ScaleX(65); <DD>DownPanel.Top := ScaleY(308); <DD>DownPanel.Width := ScaleX(435); <DD>DownPanel.Height := ScaleY(2); <DD>DownPanel.BevelOuter := bvLowered; <DD>DownPanel.Parent := Form;<P></P><DD>DownTextLabel := TLabel.Create(Form); <DD>DownTextLabel.Top := ScaleY(302); <DD>DownTextLabel.Caption := ' InstallShield'; <DD>DownTextLabel.Font.Color := $99A8AC; <DD>DownTextLabel.Color := $EEE9EB; <DD>DownTextLabel.Parent := Form;<P></P><DD>ExtraFilesList := TMemo.Create(Form); <DD>ExtraFilesList.Left := ScaleX(25); <DD>ExtraFilesList.Top := ScaleY(108); <DD>ExtraFilesList.Width := Form.ClientWidth - ScaleX(50); <DD>ExtraFilesList.Height := ScaleY(180); <DD>ExtraFilesList.Color := $EEE9EB; <DD>ExtraFilesList.Parent := Form;<P></P><DD>CancelButton := TButton.Create(Form); <DD>CancelButton.Parent := Form; <DD>CancelButton.Width := ScaleX(75); <DD>CancelButton.Height := ScaleY(23); <DD>CancelButton.Left := Form.ClientWidth - CancelButton.Width - ScaleX(20); <DD>CancelButton.Top := Form.ClientHeight - ScaleY(23 + 10); <DD>CancelButton.Caption := 'Нет'; <DD>CancelButton.ModalResult := mrCancel; <DD>CancelButton.Cancel := True;<P></P><DD>DelButton := TButton.Create(Form); <DD>DelButton.Parent := Form; <DD>DelButton.Width := ScaleX(75); <DD>DelButton.Height := ScaleY(23); <DD>DelButton.Left := CancelButton.Left - DelButton.Width - ScaleX(10); <DD>DelButton.Top := Form.ClientHeight - ScaleY(23 + 10); <DD>DelButton.Caption := 'Да'; <DD>DelButton.ModalResult := mrOk;<P></P><DD>Form.ActiveControl := CancelButton;<P></P><DD>FillListBox(ExpandConstant('{app}'), '*', 1);<P></P><DD>if ExtraFilesList.Lines.Count = 0 then <DD>DeleteFiles() <DD>else <DD>if Form.ShowModal() = mrOk then DeleteFiles(); <DD>end;<P></P><DD>procedure CurUninstallStepChanged(CurUninstallStep: TUninstallStep); <DD>begin <DD>if DirExists(ExpandConstant('{app}')) and (CurUninstallStep = usPostUninstall) then <DD>BrowseRemainedFiles(); <DD>end;</DD><TR><TD>Подсчёт длительности установки (по времени старта и завершения)</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Code]</FONT> <DD>type TSystemTime = record wYear, wMonth, wDayOfWeek, wDay, wHour, wMinute, wSecond, wMilliseconds: Word; end; <DD>var StartTime, Time: TSystemTime; StartFileTime, FileTime: TFileTime; TLabel: TNewStaticText;<P></P><DD>function GetLocalTime(var lpSystemTime: TSystemTime): Boolean; external 'GetLocalTime@kernel32.dll stdcall'; <DD>function SystemTimeToFileTime(const lpSystemTime: TSystemTime; var lpFileTime: TFileTime): Boolean; external 'SystemTimeToFileTime@kernel32.dll stdcall'; <DD>function FileTimeToSystemTime(const lpFileTime: TFileTime; var lpSystemTime: TSystemTime): Boolean; external 'FileTimeToSystemTime@kernel32.dll stdcall';<P></P><DD>Function GetWorkTime: String; <DD>Begin <DD>GetLocalTime(Time) <FONT color=green>{время завершения установки}</FONT> <DD>SystemTimeToFileTime(Time, FileTime) <DD>SystemTimeToFileTime(StartTime, StartFileTime)<P></P><DD><FONT color=green>// здесь необходимо использовать 64-битовую арифметику ULARGE_INTEGER</FONT> <DD>FileTime.dwLowDateTime:= FileTime.dwLowDateTime - StartFileTime.dwLowDateTime <DD>FileTime.dwHighDateTime:= FileTime.dwHighDateTime - StartFileTime.dwHighDateTime<P></P><DD>FileTimeToSystemTime(FileTime, Time) <DD>Result:= 'Длительность: ' + IntToStr(Time.wHour) + ' час, ' + IntToStr(Time.wMinute) + ' мин, ' + FloatToStr((Time.wSecond*1000 + Time.wMilliseconds)/1000) + ' сек.' <DD>End;<P></P><DD>Procedure CurPageChanged(CurPageID: Integer); <DD>Begin <DD>if CurPageID = wpFinished then TLabel.Caption:= TLabel.Caption + #13#10 + GetWorkTime; <DD>End;<P></P><DD>Procedure InitializeWizard; <DD>Begin <DD>GetLocalTime(StartTime) <FONT color=green>{время начала установки}</FONT> <DD>TLabel:= TNewStaticText.Create(WizardForm); <DD>TLabel.Top:= WizardForm.CancelButton.Top; <DD>TLabel.Left:= WizardForm.ClientWidth - WizardForm.CancelButton.Left - WizardForm.CancelButton.Width; <DD>TLabel.Parent:= WizardForm; <DD>TLabel.Caption:= 'Время старта: ' + IntToStr(StartTime.wHour) + ' час, ' + IntToStr(StartTime.wMinute) + ' мин, ' + FloatToStr((StartTime.wSecond*1000 + StartTime.wMilliseconds)/1000) + ' сек.' ; <DD>End;</DD><TR><TD>Подсчёт длительности установки (второй вариант):</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program version 1.5 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Code]</FONT> <DD>type TSystemTime = record wYear, wMonth, wDayOfWeek, wDay, wHour, wMinute, wSecond, wMilliseconds: Word; end; <DD>var StartTime, Time: TSystemTime; TLabel: TNewStaticText;<P></P><DD>function GetLocalTime(var lpTime: TSystemTime): Boolean; external 'GetLocalTime@kernel32.dll stdcall';<P></P><DD>Function GetWorkTime: String; <DD>Begin <DD>GetLocalTime(Time) <FONT color=green>{время завершения установки}</FONT> <DD>if Time.wHour &lt; StartTime.wHour then begin <DD>Time.wHour:= 24 - StartTime.wHour + Time.wHour <DD>end else begin <DD>Time.wHour:= Time.wHour - StartTime.wHour <DD>end <DD>if Time.wMinute &lt; StartTime.wMinute then begin <DD>Time.wMinute:= 60 - StartTime.wMinute + Time.wMinute <DD>Time.wHour:= Time.wHour - 1 <DD>end else begin <DD>Time.wMinute:= Time.wMinute - StartTime.wMinute <DD>end <DD>if Time.wSecond &lt; StartTime.wSecond then begin <DD>Time.wSecond:= 60 - StartTime.wSecond + Time.wSecond <DD>Time.wMinute:= Time.wMinute - 1 <DD>end else begin <DD>Time.wSecond:= Time.wSecond - StartTime.wSecond <DD>end <DD>if Time.wMilliseconds &lt; StartTime.wMilliseconds then begin <DD>Time.wMilliseconds:= 1000 - StartTime.wMilliseconds + Time.wMilliseconds <DD>Time.wSecond:= Time.wSecond - 1 <DD>end else begin <DD>Time.wMilliseconds:= Time.wMilliseconds - StartTime.wMilliseconds <DD>end <DD>Result:= 'Длительность: ' + IntToStr(Time.wHour) + ' час, ' + IntToStr(Time.wMinute) + ' мин, ' + FloatToStr((Time.wSecond*1000 + Time.wMilliseconds)/1000) + ' сек.' <DD>End;<P></P><DD>Procedure CurPageChanged(CurPageID: Integer); <DD>Begin <DD>if CurPageID = wpFinished then TLabel.Caption:= TLabel.Caption + #13#10 + GetWorkTime; <DD>End;<P></P><DD>Procedure InitializeWizard; <DD>Begin <DD>GetLocalTime(StartTime) <FONT color=green>{время начала установки}</FONT> <DD>TLabel:= TNewStaticText.Create(WizardForm); <DD>TLabel.Top:= WizardForm.CancelButton.Top; <DD>TLabel.Left:= WizardForm.ClientWidth - WizardForm.CancelButton.Left - WizardForm.CancelButton.Width; <DD>TLabel.Parent:= WizardForm; <DD>TLabel.Caption:= 'Время старта: ' + IntToStr(StartTime.wHour) + ' час, ' + IntToStr(StartTime.wMinute) + ' мин, ' + FloatToStr((StartTime.wSecond*1000 + StartTime.wMilliseconds)/1000) + ' сек.' ; <DD>End;</DD><TR><TD>Пример записи в бинарник определенной последовательности байт?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program v.1.2 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Code]</FONT> <DD>procedure WriteToFile; <DD>var <DD>FS: TFileStream; <DD>str: string; <DD>begin <DD>str:= Chr(0)+Chr(10)+Chr(23)+Chr(255)+Chr(30)+Chr(250);<P></P><DD>FS := TFileStream.Create('c:\temp\Test.bin', <DD>fmCreate or fmOpenWrite or fmShareDenyWrite); <DD>try <DD>FS.WriteBuffer(str, Length(str)); <DD>finally <DD>FS.Free; <DD>end; <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>WriteToFile; <DD>end;</DD><TR><TD>Как после установки ассоциировать расширение .abc с программой {app}\1.exe ???</TD><TD><DD><FONT color=red>[Registry]</FONT> <DD>Root: HKLM; Subkey: "Software\Classes\.w3m"; ValueType: string; ValueName: ""; ValueData: "WorldEdit.Scenario"; Flags: uninsdeletevalue <DD>Root: HKLM; Subkey: "Software\Classes\WorldEdit.Scenario\DefaultIcon"; ValueType: string; ValueName: ""; ValueData: "{app}\WorldEdit.exe,2"; Flags: uninsdeletevalue <DD>Root: HKLM; Subkey: "Software\Classes\WorldEdit.Scenario\shell\open\command"; ValueType: string; ValueName: ""; ValueData: "{app}\World Editor.exe ""%1"""; Flags: uninsdeletevalue<P></P><DT>Здесь создается ассоциация файлов формата *.w3m с программой World Editor.exe.</DT><TR><TD>Как на wpSelectProgramGroup сделать две TRadioButton, первая - создает ярлыки для всех пользователей, вторая - создать ярлыки только для пользователя, который запустил setup?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program v.1.2 <DD>DefaultDirName={pf}\My Program <DD>DefaultGroupName=My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: "MyProg.exe"; DestDir: "{app}"<P></P><DD><FONT color=red>[Icons]</FONT> <DD>Name: "{code:MyConst}\My Program"; Filename: "{app}\MyProg.exe"<P></P><DD><FONT color=red>[Code]</FONT> <DD>var <DD>CheckListBox: TNewCheckListBox;<P></P><DD>function MyConst(Param: String): String; <DD>begin <DD>if CheckListBox.Checked[1] then <DD>Result := ExpandConstant('{commonprograms}') <DD>else <DD>Result := ExpandConstant('{userprograms}'); <DD>end;<P></P><DD>procedure InitializeWizard(); <DD>begin <DD>CheckListBox := TNewCheckListBox.Create(WizardForm); <DD>CheckListBox.Top := WizardForm.GroupEdit.Top + WizardForm.GroupEdit.Height + ScaleY(28); <DD>CheckListBox.Width := WizardForm.GroupEdit.Width; <DD>CheckListBox.Height := ScaleY(97); <DD>CheckListBox.BorderStyle := bsNone; <DD>CheckListBox.ParentColor := True; <DD>CheckListBox.MinItemHeight := WizardForm.TasksList.MinItemHeight; <DD>CheckListBox.ShowLines := False; <DD>CheckListBox.WantTabs := True; <DD>CheckListBox.Parent := WizardForm.SelectProgramGroupPage; <DD>CheckListBox.AddGroup('Create shortcuts', '', 0, nil); <DD>CheckListBox.AddRadioButton('For All Users', '', 0, True, True, nil); <DD>CheckListBox.AddRadioButton('For Current User Only', '', 0, False, True, nil); <DD>end;</DD><TR><TD>Скрипт для установки архивов, записанных на двух DVD. На примере показано извлечение из 7z SFX-архивов.</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program 1.5 <DD>DefaultDirName={pf}\My Program <DD>OutputBaseFilename=setup <DD>Compression=none <DD>OutputDir=C:\Output <DD>SolidCompression=no<P></P><DD><FONT color=red>[Files]</FONT> <DD><FONT color=green>;На диске рядом с инсталлятором размещаем папку EmptyFiles, в которую помещаем "файлы-пустышки" игры. <DD>;Сначала выполняется первый архив (последовательность AfterInstall должна быть такой)</FONT> <DD>Source: "{src}\EmptyFiles\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs external; AfterInstall: InstallFirstArchive <DD><FONT color=green>;А затем второй</FONT> <DD>Source: "{src}\EmptyFiles\*"; DestDir: "{app}"; Flags: ignoreversion recursesubdirs createallsubdirs external; AfterInstall: CheckSelectedDisk<P></P><DD><FONT color=red>[Code]</FONT> <DD><FONT color=green>//На странице установки отключаем подтверждающее сообщение (чтобы не было проблем с откатом)</FONT> <DD>procedure CancelButtonClick(CurPage: Integer; var Cancel, Confirm: Boolean); <DD>begin <DD>Cancel:=True; <DD>If CurPage=12 then <DD>begin <DD>Confirm:=False; <DD>end; <DD>end;<P></P><DD><FONT color=green>//Устанавливаем первый 7z SFX (Pack1.exe) архив, находящийся на первом диске (рядом с инсталлятором)</FONT> <DD><FONT color=green>//Никаких сообщений об ошибках и т.д. не применяем, т.к. вся ответственность должна лежать на распространителе</FONT> <DD>procedure InstallFirstArchive; <DD>var <DD>res:Integer; <DD>s,s1:string; <DD>begin <DD>s:=ExpandConstant('{app}'); <DD>s1:=ExpandConstant('{src}')+'\Pack1.exe'; <DD>Exec(s1, '-y -o"'+ s + '"', '', SW_SHOWNORMAL, ewWaitUntilTerminated, Res); <DD>end;<P></P><DD><FONT color=green>//Затем выводим соответствующее сообщение для вставки второго диска со вторым архивом</FONT> <DD>procedure CheckSelectedDisk; <DD>var <DD>res:Integer; <DD>s,s2:string; <DD>Confirm: Boolean; <DD>begin <DD>s:=ExpandConstant('{app}'); <DD>s2:=ExpandConstant('{src}')+'\Pack2.exe'; <DD><FONT color=green>//Если второго архива рядом нету (мало ли, в будущем игра будет записана на двуслойном диске)</FONT> <DD>if not Exec(s2, '-y -o"'+ s + '"', '', SW_SHOWNORMAL, ewWaitUntilTerminated, Res) then <DD><FONT color=green>//то тогда выводим сообщение</FONT> <DD>case MsgBox('Для дальнейшей установки требуется файл '''+ s2 +'''!'#13#13 + <DD>'Вставьте второй DVD, содержащий архив, и нажмите "OK".' #13#13 + <DD>'Нажмите "Отмена", чтобы прекратить дальнейшую установку.', mbInformation, MB_OKCANCEL) <DD>of IDCANCEL: <DD>begin <DD><FONT color=green>//Выполняем откат действий при отмене</FONT> <DD>Confirm:=False; <DD>WizardForm.CancelButton.OnClick(WizardForm.CancelButton); <DD>end <DD>IDOK: <DD>begin <DD>CheckSelectedDisk; <DD>end; <DD>end; <DD>end;</DD><TR><TD>Нужно, чтобы файл File1.cfg копировался только на определенной машине (проверка имени компьютера и пользователя), а если компьютер не прошел проверку, то копируется только File2.cfg. Как сделать, чтобы конкретная процедура выполнялась на конкретной машине (имя компьютера у меня Comp, а имя пользователя boss911)?</TD><TD><DD><FONT color=red>[Setup]</FONT> <DD>AppName=My Program <DD>AppVerName=My Program v.1.2 <DD>DefaultDirName={pf}\My Program<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: C:\Prog\File1.cfg; DestDir: {userappdata}; Check: CheckComputerName <DD>Source: C:\Prog\File2.cfg; DestDir: {userappdata}; Check: Not CheckComputerName<P></P><DD><FONT color=red>[Code]</FONT> <DD>function CheckComputerName(): Boolean; <DD>begin <DD>Result:= (Uppercase(GetComputerNameString) = <DD>Uppercase('Comp')) and <DD>(Uppercase(GetUserNameString) = <DD>Uppercase('boss911')); <DD>end;</DD><TR><TD>Извлечение файлов происходит с задержками, т.к. файлов много и они маленькие, проходит приличное время, чтобы найти то, что выбрали. Инсталлятор пролистывает всю первую папку, только потом переходит к нужной! Как это обойти?</TD><TD>Для старых версий Inno Setup: <DT>В секции <FONT color=red>Setup</FONT> нужно добавить параметр: <DD><FONT color=red>[Setup]</FONT> <DD>SolidCompression=no<P></P><DT>Непрерывное сжатие можно не отключать в новых версиях Inno Setup. Если файлы перечислены по порядку (т.е. сначала файлы первой папки, потом файлы второй папки), то к первому файлу второй папки нужно применить флаг <B>solidbreak</B>: <DD><FONT color=red>[Setup]</FONT> <DD>AppName=MyProgram <DD>AppVerName=MyProgram <DD>DefaultDirName={pf}\MyProgram<P></P><DD><FONT color=red>[Files]</FONT> <DD>Source: Folder1\*; DestDir: {app}\Folder1; Components: Folder1; Flags: recursesubdirs <DD>Source: Folder2\*; DestDir: {app}\Folder2; Components: Folder2; Flags: recursesubdirs solidbreak<P></P><DD><FONT color=red>[Components]</FONT> <DD>Name: Folder1; Description: Folder1 <DD>Name: Folder2; Description: Folder2</DD><TR><TD>Подскажите почему в этом примере папка Reality не удаляется, хотя она пустая? <DT><FONT color=red>[Registry]</FONT> <DT>Root: HKLM; Subkey: "SOFTWARE\Reality\Earth"; Flags: uninsdeletekey <DT>Root: HKLM; Subkey: "SOFTWARE\Reality"; Flags: uninsdeletekeyifempty</DT></TD><TD>В процессе деинсталляции ключи реестра удаляются строго в обратной последовательности их добавления при установке программы (при наличии соответствующих флагов). Поэтому в твоём случае должно быть: <DD><FONT color=red>[Registry]</FONT> <DD>Root: HKLM; Subkey: "SOFTWARE\Reality"; Flags: uninsdeletekeyifempty <DD>Root: HKLM; Subkey: "SOFTWARE\Reality\Earth"; Flags: uninsdeletekey</DD><TR><TD>Как заставить Inno Setup засовывать в инсталлятор скрытые файлы, он их почему-то игнорирует?</TD><TD>В секции <FONT color=red>[Files]</FONT> добавь <B>Attribs: hidden</B>. <DT>Еще способ - запусти ISTool, открой секцию "Файлы и каталоги" и перетащи туда свою папку "sourceDir".</DT><TR><TD>Некоторые игры, у которых запускаемый exe не в корне игры, а где-нибудь в папке, при запуске с создаваемых InnoSetup ярлыков (и на столе, и в программах) вылетают и\или показывают сообщения об ошибке.</TD><TD>Надо кое-что дописать после {app}... Вот пример для Bioshock`а: <DD>Name: {group}\BioShock; Filename: {app}\Builds\Release\Bioshock.exe; WorkingDir: {app}\Builds\Release <DT>Здесь ехе расположен не в корне, а в ..\{app}\Builds\Release\</DT></TD></TR></TBODY></TABLE></P></BODY></HTML>