<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><title>Прозрачный инсталятор</title><link rel="stylesheet" type="text/css" href="css.css"><script type="text/javascript" src="includer.js"></script><script language='jscript' type='text/javascript' src='copycode.js'></script></head><body><div id="heading"><h1>» Inno Setup Faq. Прозрачный инсталятор</h1></div><br><script language="javascript" type="text/javascript">includeSyntax('delphi');</script><code id="delphi_Tc4NTM">
<input type="button" value="Копировать в буфер обмена" onClick="copyToClipboard( taCode1, theCode1 );">
<blockquote id="theCode1"><font>#include &quot;botva2.iss&quot;<br><br>#define FormPic &quot;form.png&quot;<br>#define CloseBtnPic &quot;closebtn.png&quot;<br>#define MinimizeBtnPic &quot;minimizebtn.png&quot;<br><br>[Setup]<br>AppName=Temp<br>AppVerName=Temp<br>DefaultDirName={pf}\Temp<br>VersionInfoCopyright=VoLT<br><br>[Languages]<br>Name: &quot;rus&quot;; MessagesFile: &quot;compiler:Languages\Russian.isl&quot;<br><br>[Files]<br>Source: InstallFiles\*; DestDir: {tmp}; Flags: dontcopy sortfilesbyextension<br><br>[Code]<br>var<br>WizardImg: Longint;<br>hCloseBtn, hMinimizeBtn, MusicButton,<br>hCancelBtn, hNextBtn, hBackBtn, hDirBrowseBtn, hGroupBrowseBtn, hCancelUninstBtn: HWND;<br><br>function SetWindowLong(hWnd: Longint; nIndex: Integer; dwNewLong: Longint): Longint; external 'SetWindowLongA@user32.dll stdcall';<br>function GetWindowLong(hWnd, nIndex: Integer): Longint; external 'GetWindowLongA@user32 stdcall delayload';<br>function SetLayeredWindowAttributes(hWnd : Longint; crKey : TColor; bAlpha : byte; dwFlags : DWORD): BOOL; external 'SetLayeredWindowAttributes@user32.dll stdcall';<br>function ReleaseCapture(): Longint; external 'ReleaseCapture@user32.dll stdcall';<br><br>procedure CloseBtnClick(hBtn:HWND);<br>begin<br>WizardForm.Close;<br>end;<br><br>procedure MinimizeBtnClick(hBtn:HWND);<br>begin<br>SendMessage(WizardForm.Handle,$0112,61472,0);<br>end;<br><br>procedure LabelOnMouseDown(Sender: TObject; Button: TMouseButton; Shift: TShiftState; X, Y: Integer);<br>begin<br>ReleaseCapture;<br>SendMessage(WizardForm.Handle,$0112,$F012,0)<br>end;<br><br>///************************************************ [Начало - Вставка изображений] ***************************************************///<br><br>function InitializeSetup:boolean;<br>begin<br>if not FileExists(ExpandConstant('{tmp}\botva2.dll')) then ExtractTemporaryFile('botva2.dll');<br>if not FileExists(ExpandConstant('{tmp}\innocallback.dll')) then ExtractTemporaryFile('innocallback.dll');<br>Result:=True;<br>end;<br><br>procedure CreateWizardImage;<br>begin<br>with WizardForm do begin<br>BorderStyle:=bsNone;<br>Bevel.Hide;<br>InnerNotebook.Hide;<br>OuterNotebook.Hide;<br>SetBounds(ScaleX(0), ScaleY(0), ScaleX(600), ScaleY(490));<br>Position:=poScreenCenter;<br>end;<br><br>with TLabel.Create(WizardForm) do begin<br>Parent:=WizardForm;<br>AutoSize:=False;<br>SetBounds(ScaleX(70), ScaleY(7), ScaleX(370), ScaleY(16));<br>Font.Name:= 'Georgia';<br>Font.Size:= 9;<br>Transparent:=True;<br>Font.Color:=$FFFFFF;<br>Font.Style:=[fsBold, fsItalic];<br>OnMouseDown:=@LabelOnMouseDown;<br>Caption:=WizardForm.Caption;<br>end;<br><br>ExtractTemporaryFile('{#FormPic}');<br>ExtractTemporaryFile('{#CloseBtnPic}');<br>ExtractTemporaryFile('{#MinimizeBtnPic}');<br>ExtractTemporaryFile('button.png');<br><br>WizardImg:=ImgLoad(WizardForm.Handle,ExpandConstant('{tmp}')+'\{#FormPic}',0,0,0,0,False,True);<br><br>ImgApplyChanges(WizardForm.Handle);<br><br>SetWindowLong(WizardForm.Handle,-20,GetWindowLong(WizardForm.Handle,-20) or $80000);<br>SetLayeredWindowAttributes(WizardForm.Handle,$00FF00,0,1);<br>end;<br><br>///************************************************ [Конец - Вставка изображений] ***************************************************///<br><br>///************************************************ [Начало - Текстуры кнопок] ***************************************************///<br><br>procedure SetStateNewButtons;<br>begin<br>with WizardForm.BackButton do begin<br>BtnSetText(hBackBtn,PAnsiChar(Caption));<br>BtnSetVisibility(hBackBtn,Visible);<br>BtnSetEnabled(hBackBtn,Enabled);<br>end;<br>with WizardForm.NextButton do begin<br>BtnSetText(hNextBtn,PAnsiChar(Caption));<br>BtnSetVisibility(hNextBtn,Visible);<br>BtnSetEnabled(hNextBtn,Enabled);<br>end;<br>with WizardForm.CancelButton do begin<br>BtnSetText(hCancelBtn,PAnsiChar(Caption));<br>BtnSetVisibility(hCancelBtn,Visible);<br>BtnSetEnabled(hCancelBtn,Enabled);<br>end;<br>BtnSetText(hDirBrowseBtn,PAnsiChar(WizardForm.DirBrowseButton.Caption));<br>BtnSetText(hGroupBrowseBtn,PAnsiChar(WizardForm.GroupBrowseButton.Caption));<br>end;<br><br>procedure WizardFormBtnClick(hBtn:HWND);<br>var<br>Btn:TButton;<br>begin<br>///sndPlaySound(ExpandConstant('{tmp}\Click.wav'),$0001);<br>case hBtn of<br>hCancelBtn: Btn:=WizardForm.CancelButton;<br>hNextBtn: Btn:=WizardForm.NextButton;<br>hBackBtn: Btn:=WizardForm.BackButton;<br>hDirBrowseBtn: Btn:=WizardForm.DirBrowseButton;<br>hGroupBrowseBtn: Btn:=WizardForm.GroupBrowseButton;<br>end;<br>Btn.OnClick(Btn);<br>SetStateNewButtons;<br>BtnRefresh(hBtn);<br>end;<br><br>procedure WFBtnEnter(hBtn:HWND);<br>begin<br>///sndPlaySound(ExpandConstant('{tmp}\WFEnter.wav'),$0001);<br>end;<br><br>procedure ButtonsTextures;<br>begin<br>///WFButtonFont:=TFont.Create;<br>///WFButtonFont.Style:=[fsBold];<br><br>with WizardForm.BackButton do begin<br>hBackBtn:=BtnCreate(WizardForm.Handle,225,400,90,90,ExpandConstant('{tmp}\button.png'),10,False);<br>BtnSetEvent(hBackBtn,BtnMouseEnterEventID,WrapBtnCallback(@WFBtnEnter,1));<br>BtnSetEvent(hBackBtn,BtnClickEventID,WrapBtnCallback(@WizardFormBtnClick,1));<br>///BtnSetFont(hBackBtn,WFButtonFont.Handle);<br>BtnSetFontColor(hBackBtn,$b6c4c5,$ffffff,$5d4e27,$B6B6B6);<br>BtnSetCursor(hBackBtn,GetSysCursorHandle(32649));<br>Width:=0;<br>Height:=0;<br>end;<br><br>with WizardForm.NextButton do begin<br>hNextBtn:=BtnCreate(WizardForm.Handle,320,400,90,90,ExpandConstant('{tmp}\button.png'),3,False);<br>BtnSetEvent(hNextBtn,BtnMouseEnterEventID,WrapBtnCallback(@WFBtnEnter,1));<br>BtnSetEvent(hNextBtn,BtnClickEventID,WrapBtnCallback(@WizardFormBtnClick,1));<br>///BtnSetFont(hNextBtn,WFButtonFont.Handle);<br>BtnSetFontColor(hNextBtn,$b6c4c5,$ffffff,$5d4e27,$B6B6B6);<br>BtnSetCursor(hNextBtn,GetSysCursorHandle(32649));<br>Width:=0;<br>Height:=0;<br>end;<br><br>with WizardForm.CancelButton do begin<br>hCancelBtn:=BtnCreate(WizardForm.Handle,430,400,90,90,ExpandConstant('{tmp}\button.png'),10,False);<br>BtnSetEvent(hCancelBtn,BtnMouseEnterEventID,WrapBtnCallback(@WFBtnEnter,1));<br>BtnSetEvent(hCancelBtn,BtnClickEventID,WrapBtnCallback(@WizardFormBtnClick,1));<br>///BtnSetFont(hCancelBtn,WFButtonFont.Handle);<br>BtnSetFontColor(hCancelBtn,$b6c4c5,$ffffff,$5d4e27,$B6B6B6);<br>BtnSetCursor(hCancelBtn,GetSysCursorHandle(32649));<br>Width:=0;<br>Height:=0;<br>end;<br><br>with WizardForm.DirBrowseButton do begin<br>hDirBrowseBtn:=BtnCreate(WizardForm.Handle,401,202,85,85,ExpandConstant('{tmp}\button.png'),10,False);<br>BtnSetEvent(hDirBrowseBtn,BtnMouseEnterEventID,WrapBtnCallback(@WFBtnEnter,1));<br>BtnSetEvent(hDirBrowseBtn,BtnClickEventID,WrapBtnCallback(@WizardFormBtnClick,1));<br>///BtnSetFont(hDirBrowseBtn,WFButtonFont.Handle);<br>BtnSetFontColor(hDirBrowseBtn,$b6c4c5,$ffffff,$5d4e27,$B6B6B6);<br>BtnSetCursor(hDirBrowseBtn,GetSysCursorHandle(32649));<br>Width:=0;<br>Height:=0;<br>end;<br><br>with WizardForm.GroupBrowseButton do begin<br>hGroupBrowseBtn:=BtnCreate(WizardForm.Handle,401,202,85,85,ExpandConstant('{tmp}\button.png'),10,False);<br>BtnSetEvent(hGroupBrowseBtn,BtnMouseEnterEventID,WrapBtnCallback(@WFBtnEnter,1));<br>BtnSetEvent(hGroupBrowseBtn,BtnClickEventID,WrapBtnCallback(@WizardFormBtnClick,1));<br>///BtnSetFont(hGroupBrowseBtn,WFButtonFont.Handle);<br>BtnSetFontColor(hGroupBrowseBtn,$b6c4c5,$ffffff,$5d4e27,$B6B6B6);<br>BtnSetCursor(hGroupBrowseBtn,GetSysCursorHandle(32649));<br>Width:=0;<br>Height:=0;<br>end;<br><br>hCloseBtn:=BtnCreate(WizardForm.Handle,516,35,16,16,ExpandConstant('{tmp}')+'\{#CloseBtnPic}',3,False);<br>BtnSetEvent(hCloseBtn,BtnMouseEnterEventID,WrapBtnCallback(@WFBtnEnter,1));<br>BtnSetEvent(hCloseBtn,BtnClickEventID,WrapBtnCallback(@WizardFormBtnClick,1));<br>BtnSetEvent(hCloseBtn,BtnClickEventID,WrapBtnCallback(@CloseBtnClick,1));<br>BtnSetCursor(hCloseBtn,GetSysCursorHandle(32649));<br><br>hMinimizeBtn:=BtnCreate(WizardForm.Handle,498,35,16,16,ExpandConstant('{tmp}')+'\{#MinimizeBtnPic}',3,False);<br>BtnSetEvent(hMinimizeBtn,BtnMouseEnterEventID,WrapBtnCallback(@WFBtnEnter,1));<br>BtnSetEvent(hMinimizeBtn,BtnClickEventID,WrapBtnCallback(@WizardFormBtnClick,1));<br>BtnSetEvent(hMinimizeBtn,BtnClickEventID,WrapBtnCallback(@MinimizeBtnClick,1));<br>BtnSetCursor(hMinimizeBtn,GetSysCursorHandle(32649));<br>end;<br><br>///************************************************ [Конец - Текстуры кнопок] ***************************************************///<br><br>procedure InitializeWizard;<br>begin<br>CreateWizardImage;<br>ButtonsTextures;<br>end;<br><br><p>procedure CurPageChanged(CurPageID: Integer);<br>begin<br>SetStateNewButtons;<br>BtnSetVisibility(hDirBrowseBtn,False);<br>BtnSetVisibility(hGroupBrowseBtn,False);<br>ImgApplyChanges(WizardForm.Handle);<br>end;</p>procedure DeinitializeSetup;<br>begin<br>gdipShutdown;<br>end;<br></font></blockquote><textarea id="taCode1" style="display:none;" rows="1" cols="5"></textarea><textarea id='taCode' style='display:none;' rows='1' cols='20'></textarea></code><script language="javascript" type="text/javascript">highlightSyntax('delphi_Tc4NTM','delphi');</script><p></p>Botva2.iss:<br><input type="button" value="Копировать в буфер обмена" onClick="copyToClipboard( taCode2, theCode2 );">
<blockquote id="theCode2"><script language="javascript" type="text/javascript">includeSyntax('delphi');</script><code id="delphi_Tc4NTN">[Code] <br>
const BTN_MAX_PATH = 1024; ///не изменять !!! ///идентификаторы событий для кнопок<br>BtnClickEventID = 1;<br>BtnMouseEnterEventID = 2;<br>BtnMouseLeaveEventID = 3;<br>BtnMouseMoveEventID = 4;<br>///выравнивание текста на кнопках<br>balLeft = 0; ///выравнивание текста по левому краю<br>balCenter = 1; ///горизонтальное выравнивание текста по центру<br>balRight = 2; ///выравнивание текста по правому краю<br>balVCenter = 4; ///вертикальное выравнивание текста по центру<br>type<br>#ifndef UNICODE<br>AnsiChar = Char;<br>#endif<br>TBtnEventProc = procedure(h:HWND);<br>TTextBuf = array [0..BTN_MAX_PATH-1] of AnsiChar; ///не менять размерность массива !!!<br>TImgPB = record<br>Left,<br>Top,<br>Width,<br>Height,<br>MaxWidth : integer;<br>img1,img2 : Longint;<br>///hParent : HWND;<br>end;<br>///для выполнения нажатий на кнопки нужен innocallback<br>function WrapBtnCallback(Callback: TBtnEventProc; ParamCount: Integer): Longword; external 'wrapcallback@{tmp}\innocallback.dll stdcall delayload';<br>function ImgLoad(Wnd :HWND; FileName :PAnsiChar; Left, Top, Width, Height :integer; Stretch, IsBkg :boolean) :Longint; external 'ImgLoad@{tmp}\botva2.dll stdcall delayload';<br>///загружает изображение в память, сохраняет переданные параметры<br>///Wnd - хэндл окна, в котором будет выведено изображение<br>///FileName - файл изображения<br>///Left,Top - координаты верхнего левого угла вывода изображения (в координатах клиентской области Wnd)<br>///Width,Height - ширина, высота изображения<br>///если Stretch=True, то изображение будет растянуто/сжато в прямоугольной области<br>///Rect.Left:=Left;<br>///Rect.Top:=Top;<br>///Rect.Right:=Left+Width;<br>///Rect.Bottom:=Top+Height;<br>///если Stretch=False, то параметры Width,Height игнорируются и вычисляются самой ImgLoad, т.е. можно передать 0<br>///Stretch - масштабировать изображение или нет<br>///IsBkg - если IsBkg=True, изображение будет выведено на фоне формы,<br>///поверх него будут отрисованы графические объекты (TLabel, TBitmapImage и т.д.),<br>///затем поверх всего будут выведены изображения с флагом IsBkg=False<br>///возвращаемое значение - указатель на структуру, хранящей изображение и его парметры, приведенный к типу Longint<br>///изображения будут выведены в той последовательности, в которой вызывается ImgLoad<br>procedure ImgSetVisiblePart(img:Longint; NewLeft, NewTop, NewWidth, NewHeight : integer); external 'ImgSetVisiblePart@{tmp}\botva2.dll stdcall delayload';<br>///сохраняет новые координаты видимой части изображения, новую ширину и высоту. в координатах оригинального изображения<br>///img - значение полученное при вызове ImgLoad.<br>///NewLeft,NewTop - новый левый верхний угол видимой области.<br>///NewWidth,NewHeight - новая ширина, высота видимой области.<br>///PS изначально (при вызове ImgLoad) изображение считается полностью видимым.<br>///если возникла необходимость отображать только часть картинки, то используем эту процедуру<br>procedure ImgGetVisiblePart(img:Longint; var Left, Top, Width, Height : integer); external 'ImgGetVisiblePart@{tmp}\botva2.dll stdcall delayload';<br>///возвращает координаты видимой части изображения, ширину и высоту<br>///img - значение полученное при вызове ImgLoad<br>///NewLeft,NewTop - левый верхний угол видимой области<br>///NewWidth,NewHeight - ширина, высота видимой области.<br>procedure ImgSetPosition(img :Longint; NewLeft, NewTop, NewWidth, NewHeight :integer); external 'ImgSetPosition@{tmp}\botva2.dll stdcall delayload';<br>///сохраняет новые координаты для вывода изображения, новую ширину и высоту. в координатах родительского окна<br>///img - значение полученное при вызове ImgLoad<br>///NewLeft,NewTop - новый левый верхний угол<br>///NewWidth,NewHeight - новая ширина, высота. если в ImgLoad был передан Stretch=False, то NewWidth,NewHeight игнорируются<br>procedure ImgGetPosition(img:Longint; var Left, Top, Width, Height:integer); external 'ImgGetPosition@{tmp}\botva2.dll stdcall delayload';<br>///возвращает координаты вывода изображения, ширину и высоту<br>///img - значение полученное при вызове ImgLoad<br>///Left,Top - левый верхний угол<br>///Width,Height - ширина, высота.<br>procedure ImgSetVisibility(img :Longint; Visible :boolean); external 'ImgSetVisibility@{tmp}\botva2.dll stdcall delayload';<br>///сохраняет параметр видимости изображения<br>///img - значение полученное при вызове ImgLoad<br>///Visible - видимость<br>function ImgGetVisibility(img:Longint):boolean; external 'ImgGetVisibility@{tmp}\botva2.dll stdcall delayload';<br>///img - значение полученное при вызове ImgLoad<br>///возвращаемое значение - видимость изображения<br>procedure ImgRelease(img :Longint); external 'ImgRelease@{tmp}\botva2.dll stdcall delayload';<br>///удаляет изображение из памяти<br>///img - значение полученное при вызове ImgLoad<br>procedure ImgApplyChanges(h:HWND); external 'ImgApplyChanges@{tmp}\botva2.dll stdcall delayload';<br>///формирует окончательное изображение для вывода экран,<br>///учитывая все изменения внесенные вызовами ImgLoad, ImgSetPosition, ImgSetVisibility, ImgRelease и обновляет окно<br>///h - хэндл окна, для которого необходимо сформировать новое изображение<br>function BtnCreate(hParent :HWND; Left, Top, Width, Height :integer; FileName :PAnsiChar; ShadowWidth :integer; IsCheckBtn :boolean) :HWND; external 'BtnCreate@{tmp}\botva2.dll stdcall delayload';<br>///hParent - хэндл окна-родителя, на котором будет создана кнопка<br>///Left,Top,<br>///Width,Height - без комментариев. то же что и для обычных кнопок<br>///FileName - файл с изображением состояний кнопки<br>///для обычной кнопки нужно 4 состояния кнопки (соответственно 4 изображения)<br>///для кнопки с IsCheckBtn=True нужно 8 изображений (как для чекбокса)<br>///изображения состояний должны располагаться вертикально<br>///ShadowWidth - кол-во пикселей от края рисунка кнопки, до реальной ее границы на рисунке.<br>///нужно чтобы состояние кнопки и курсор на ней менялись как положено<br>///IsCheckBtn - если True, то будет создана кнопка (аналог CheckBox) имеющая включенное и выключенное состояние<br>///если False, то создастся обычная кнопка<br>///возвращаемое значение - хэндл созданной кнопки<br>procedure BtnSetText(h :HWND; Text :PAnsiChar); external 'BtnSetText@{tmp}\botva2.dll stdcall delayload';<br>///устанавливает текст на кнопке (аналог Button.Caption:='bla-bla-bla')<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///Text - текст, который мы хотим увидеть на кнопке<br>function BtnGetText_(h:HWND; var Text:TTextBuf):integer; external 'BtnGetText@{tmp}\botva2.dll stdcall delayload';<br>///получает текст кнопки<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///Text - буфер принимающий текст кнопки<br>///возвращаемое значение - длина текста<br>procedure BtnSetTextAlignment(h :HWND; HorIndent, VertIndent :integer; Alignment :DWORD); external 'BtnSetTextAlignment@{tmp}\botva2.dll stdcall delayload';<br>///устанавливает выравнивание текста на кнопке<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///HorIndent - горизонтальный отступ текста от края кнопки<br>///VertIndent - вертикальный отступ текста от края кнопки<br>///Alignment - выравнивание текста. задается константами balLeft, balCenter, balRight, balVCenter,<br>///или комбинацией balVCenter с остальными. например, balVCenter or balRight<br>procedure BtnSetFont(h :HWND; Font :Cardinal); external 'BtnSetFont@{tmp}\botva2.dll stdcall delayload';<br>///устанавливает шрифт для кнопки<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///Font - дескриптор устанавливаемого шрифта<br>///чтобы не мучаться с WinAPI-шными функциями можно создать шрифт стандартными средствами инно и передать его хэндл<br>///например,<br>///var<br>///Font:TFont;<br>///. . .<br>///begin<br>///. . .<br>///Font:=TFont.Create;<br>///все свойства можно не устанавливать, при создании свойства заполняются значениями по умолчанию. меняем только то что нам нужно<br>///with Font do begin<br>///Name:='Tahoma';<br>///Size:=10;<br>///. . .<br>///end;<br>///BtnSetFont(hBtn,Font.Handle);<br>///. . .<br>///end;<br>///ну и при выходе из программы (или когда он станет не нужен) не забываем уничтожить свой шрифт Font.Free;<br>procedure BtnSetFontColor(h :HWND; NormalFontColor, FocusedFontColor, PressedFontColor, DisabledFontColor :Cardinal); external 'BtnSetFontColor@{tmp}\botva2.dll stdcall delayload';<br>///устанавливает цвет шрифта для кнопки во включенном и выключенном сосотоянии<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///NormalFontColor - цвет текста на кнопе в нормальном состоянии<br>///FocusedFontColor - цвет текста на кнопе в подсвеченном состоянии<br>///PressedFontColor - цвет текста на кнопе в нажатом состоянии<br>///DisabledFontColor - цвет текста на кнопе в отключенном состоянии<br>function BtnGetVisibility(h :HWND) :boolean; external 'BtnGetVisibility@{tmp}\botva2.dll stdcall delayload';<br>///получает видимость кнопки (аналог f:=Button.Visible)<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///возвращаемое значение - видимость кнопки<br>procedure BtnSetVisibility(h :HWND; Value :boolean); external 'BtnSetVisibility@{tmp}\botva2.dll stdcall delayload';<br>///устанавливает видимость кнопки (аналог Button.Visible:=True / Button.Visible:=False)<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///Value - значение видимости<br>function BtnGetEnabled(h :HWND) :boolean; external 'BtnGetEnabled@{tmp}\botva2.dll stdcall delayload';<br>///получает доступность кнопки (аналог f:=Button.Enabled)<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///возвращаемое значение - доступность кнопки<br>procedure BtnSetEnabled(h :HWND; Value :boolean); external 'BtnSetEnabled@{tmp}\botva2.dll stdcall delayload';<br>///устанвливает доступность кнопки (аналог Button.Enabled:=True / Button.Enabled:=False)<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///Value - значение доступности кнопки<br>function BtnGetChecked(h :HWND) :boolean; external 'BtnGetChecked@{tmp}\botva2.dll stdcall delayload';<br>///получает состояние (включена/выключена) кнопки (аналог f:=Checkbox.Checked)<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>procedure BtnSetChecked(h :HWND; Value :boolean); external 'BtnSetChecked@{tmp}\botva2.dll stdcall delayload';<br>///устанвливает состояние (включена/выключена) кнопки (аналог Сheckbox.Checked:=True / Сheckbox.Checked:=False)<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///Value - значение состояния кнопки<br>procedure BtnSetEvent(h :HWND; EventID :integer; Event :Longword); external 'BtnSetEvent@{tmp}\botva2.dll stdcall delayload';<br>///устанавливает событие для кнопки<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///EventID - идентификатор события, заданный константами BtnClickEventID, BtnMouseEnterEventID, BtnMouseLeaveEventID, BtnMouseMoveEventID<br>///Event - адрес процедуры выполняемой при наступлении указанного события<br>///пример использования - BtnSetEvent(hBtn, BtnClickEventID, WrapBtnCallback(@BtnClick,1));<br>procedure BtnGetPosition(h:HWND; var Left, Top, Width, Height: integer); external 'BtnGetPosition@{tmp}\botva2.dll stdcall delayload';<br>///получает координаты левого верхнего угла и размер кнопки<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///Left, Top - координаты верхнего левого угла (в координатах родительского окна)<br>///Width, Height - ширина, высота кнопки<br>procedure BtnSetPosition(h:HWND; NewLeft, NewTop, NewWidth, NewHeight: integer); external 'BtnSetPosition@{tmp}\botva2.dll stdcall delayload';<br>///устанавливает координаты левого верхнего угла и размер кнопки<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///NewLeft, NewTop - новые координаты верхнего левого угла (в координатах родительского окна)<br>///NewWidth, NewHeight - новые ширина, высота кнопки<br>procedure BtnRefresh(h :HWND); external 'BtnRefresh@{tmp}\botva2.dll stdcall delayload';<br>///немедленно перерисовывает кнопку, в обход очереди сообщений. вызывать, если кнопка не успевает перерисовываться<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>procedure BtnSetCursor(h:HWND; hCur:Cardinal); external 'BtnSetCursor@{tmp}\botva2.dll stdcall delayload';<br>///устанавливает курсор для кнопки<br>///h - хэндл кнопки (результат возвращенный BtnCreate)<br>///hCur - дескриптор устанавливаемого курсора<br>///DestroyCursor вызывать не обязательно, он будет уничтожен при вызове gdipShutDown;<br>function GetSysCursorHandle(id:integer):Cardinal; external 'GetSysCursorHandle@{tmp}\botva2.dll stdcall delayload';<br>///загружает стандартный курсор по его идентификатору<br>///id - идентификатор стандартного курсора. идентификаторы стандартных курсоров задаются константами OCR_... , значения которых ищем в инете<br>///возвращаемое значение - дескриптор загруженного курсора<br>procedure gdipShutdown; external 'gdipShutdown@{tmp}\botva2.dll stdcall delayload';<br>///обязательно вызвать при завершении приложения<br>function ArrayOfAnsiCharToAnsiString(a:TTextBuf):AnsiString;<br>var<br>i:integer;<br>begin<br>i:=0;<br>Result:='';<br>while a[i]&lt;&gt;#0 do begin<br>Result:=Result+a[i];<br>i:=i+1;<br>end;<br>end;<br>function BtnGetText(hBtn:HWND):AnsiString;<br>var<br>buf:TTextBuf;<br>begin<br>BtnGetText_(hBtn,buf);<br>Result:=ArrayOfAnsiCharToAnsiString(buf); ////медленно работает, как по другому сделать хз<br>end;<br>function ImgPBCreate(hParent :HWND; bk, pb :ansistring; Left, Top, Width, Height :integer):TImgPB;<br>begin<br>Result.Left:=Left+2;<br>Result.Top:=Top+2;<br>Result.Width:=0;<br>Result.Height:=Height-4;<br>Result.MaxWidth:=Width-4;<br>if Length(pb)&gt;0 then Result.img1:=ImgLoad(hParent,pb,Result.Left,Result.Top,0,Result.Height,True,False) else Result.img1:=0;<br>if Length(bk)&gt;0 then Result.img2:=ImgLoad(hParent,bk,Left,Top,Width,Height,True,False) else Result.img2:=0;<br>///Result.hParent:=hParent;<br>///if (Result.img1&lt;&gt;0) or (Result.img2&lt;&gt;0) then ImgApplyChanges(hParent);<br>end;<br>procedure ImgPBSetPosition(var PB :TImgPB; Percent :Extended);<br>var<br>NewWidth:integer;<br>begin<br>if PB.img1&lt;&gt;0 then begin<br>NewWidth:=Round(PB.MaxWidth*Percent/100);<br>if PB.Width&lt;&gt;NewWidth then begin<br>PB.Width:=NewWidth;<br>ImgSetPosition(PB.img1,PB.Left,PB.Top,PB.Width,PB.Height);<br>///ImgApplyChanges(PB.hParent);<br>end;<br>end;<br>end;<br>procedure ImgPBDelete(var PB :TImgPB);<br>begin<br>if PB.img1&lt;&gt;0 then ImgRelease(PB.img1);<br>if PB.img2&lt;&gt;0 then ImgRelease(PB.img2);<br>///if (PB.img1&lt;&gt;0) or (PB.img2&lt;&gt;0) then ImgApplyChanges(PB.hParent);<br>PB.img1:=0;<br>PB.img2:=0;<br>end;<script language="javascript" type="text/javascript">highlightSyntax('delphi_Tc4NTN','delphi');</script></code></blockquote><code id="delphi_Tc4NTN"><textarea id="taCode2" style="display:none;" rows="1" cols="5"></textarea><textarea id='taCode' style='display:none;' rows='1' cols='20'></textarea></code><br><div id="heading"><h1><font size="1" face="Consolas">Copyright (c) <a href="http://www.krinkels.org/" target="_blank">Krinkels Inc</a></font></h1></div></body></html>